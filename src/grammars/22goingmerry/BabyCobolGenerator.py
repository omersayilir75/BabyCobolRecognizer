# Generated by Grammarinator 23.7.post31+g3f15e2c.d20231108

import itertools

from math import inf
from grammarinator.runtime import *

class BabyCobolGenerator(Generator):


    def EOF(self, parent=None):
        pass
    EOF.min_size = RuleSize(0, 0)

    def program(self, parent=None):
        with UnparserRuleContext(self, 'program', parent) as current:
            self._reserve(1, self.identification_division, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 3), 1) as quant0:
                while quant0(current):
                    self.data_division(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 4), 1) as quant1:
                while quant1(current):
                    self.procedure_division(parent=current)
            self.EOF(parent=current)
            return current
    program.min_size = RuleSize(2, 4)

    def identification_division(self, parent=None):
        with UnparserRuleContext(self, 'identification_division', parent) as current:
            self._reserve(2, self.IDENTIFICATION, parent=current)
            self._reserve(1, self.DIVISION, parent=current)
            self.DOT(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(2, 3), 0) as quant0:
                while quant0(current):
                    self.identificationEntry(parent=current)
            return current
    identification_division.min_size = RuleSize(1, 3)

    def identificationEntry(self, parent=None):
        with UnparserRuleContext(self, 'identificationEntry', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 4), RuleSize(2, 3)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self._reserve(3, self.IDENTIFIER, parent=current)
                    self._reserve(2, self.DOT, parent=current)
                    self._reserve(1, self.IDENTIFIER, parent=current)
                    self.DOT(parent=current)
                elif choice0 == 1:
                    self._reserve(1, self.copy_statement, parent=current)
                    self.DOT(parent=current)
            return current
    identificationEntry.min_size = RuleSize(1, 3)

    def data_division(self, parent=None):
        local_ctx = dict(lines=[])
        with UnparserRuleContext(self, 'data_division', parent) as current:
            self._reserve(2, self.DATA, parent=current)
            self._reserve(1, self.DIVISION, parent=current)
            self.DOT(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(3, 3), 0) as quant0:
                while quant0(current):
                    self.line(parent=current)
                    local_ctx['lines'].append(current.last_child)
            return current
    data_division.min_size = RuleSize(1, 3)

    def line(self, parent=None):
        with UnparserRuleContext(self, 'line', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 3), RuleSize(3, 5), RuleSize(2, 3)), 0, (1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.record(parent=current)
                elif choice0 == 1:
                    self.field(parent=current)
                elif choice0 == 2:
                    self._reserve(1, self.copy_statement, parent=current)
                    self.DOT(parent=current)
            return current
    line.min_size = RuleSize(2, 3)

    def record(self, parent=None):
        with UnparserRuleContext(self, 'record', parent) as current:
            self._reserve(2, self.INT, parent=current)
            self._reserve(1, self.IDENTIFIER, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 2), 1) as quant0:
                while quant0(current):
                    self._reserve(1, self.OCCURS, parent=current)
                    with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 1) as quant1:
                        while quant1(current):
                            self.INT(parent=current)
                    self.TIMES(parent=current)
            self.DOT(parent=current)
            return current
    record.min_size = RuleSize(1, 3)

    def field(self, parent=None):
        with UnparserRuleContext(self, 'field', parent) as current:
            self._reserve(4, self.INT, parent=current)
            self._reserve(3, self.IDENTIFIER, parent=current)
            with AlternationContext(self, 0, (RuleSize(2, 3), RuleSize(2, 2)), 1, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self._reserve(2, self.PICTURE, parent=current)
                    self._reserve(1, self.IS, parent=current)
                    self.representation(parent=current)
                elif choice0 == 1:
                    self._reserve(1, self.LIKE, parent=current)
                    self.identifiers(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 2), 1) as quant0:
                while quant0(current):
                    self._reserve(1, self.OCCURS, parent=current)
                    with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 1) as quant1:
                        while quant1(current):
                            self.INT(parent=current)
                    self.TIMES(parent=current)
            self.DOT(parent=current)
            return current
    field.min_size = RuleSize(2, 5)

    def representation(self, parent=None):
        with UnparserRuleContext(self, 'representation', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                [self.IDENTIFIER, self.INT][alt0(current)](parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.INDEX(parent=current)
            return current
    representation.min_size = RuleSize(1, 1)

    def identifiers(self, parent=None):
        with UnparserRuleContext(self, 'identifiers', parent) as current:
            self.IDENTIFIER(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.INDEX(parent=current)
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 2), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.OF, parent=current)
                    self.IDENTIFIER(parent=current)
                    with QuantifierContext(self, 2, 0, 1, RuleSize(1, 1), 0) as quant2:
                        while quant2(current):
                            self.INDEX(parent=current)
            return current
    identifiers.min_size = RuleSize(1, 1)

    def procedure_division(self, parent=None):
        with UnparserRuleContext(self, 'procedure_division', parent) as current:
            self._reserve(3, self.PROCEDURE, parent=current)
            self._reserve(2, self.DIVISION, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 2) as quant0:
                while quant0(current):
                    self.USING(parent=current)
                    with QuantifierContext(self, 1, 0, inf, RuleSize(2, 3), 0) as quant1:
                        while quant1(current):
                            self.using(parent=current)
            self._reserve(1, self.DOT, parent=current)
            with QuantifierContext(self, 2, 0, inf, RuleSize(4, 1), 1) as quant2:
                while quant2(current):
                    self.statements(parent=current)
            with QuantifierContext(self, 3, 0, inf, RuleSize(5, 3), 1) as quant3:
                while quant3(current):
                    self.paragraph(parent=current)
            self.DOT(parent=current)
            return current
    procedure_division.min_size = RuleSize(1, 4)

    def paragraph(self, parent=None):
        with UnparserRuleContext(self, 'paragraph', parent) as current:
            self._reserve(2, self.IDENTIFIER, parent=current)
            self._reserve(1, self.DOT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(4, 1), 0) as quant0:
                while quant0(current):
                    self.statements(parent=current)
            return current
    paragraph.min_size = RuleSize(4, 3)

    def statements(self, parent=None):
        with UnparserRuleContext(self, 'statements', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.statement(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.DOT(parent=current)
            return current
    statements.min_size = RuleSize(3, 1)

    def using(self, parent=None):
        with UnparserRuleContext(self, 'using', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 3), RuleSize(3, 3), RuleSize(3, 3)), 0, (1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self._reserve(2, self.BY, parent=current)
                    self._reserve(1, self.REFERENCE, parent=current)
                    self.IDENTIFIER(parent=current)
                elif choice0 == 1:
                    self._reserve(2, self.BY, parent=current)
                    self._reserve(1, self.CONTENT, parent=current)
                    self.atomic(parent=current)
                elif choice0 == 2:
                    self._reserve(2, self.BY, parent=current)
                    self._reserve(1, self.VALUE, parent=current)
                    self.atomic(parent=current)
            return current
    using.min_size = RuleSize(1, 3)

    def statement(self, parent=None):
        with UnparserRuleContext(self, 'statement', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 2), RuleSize(4, 4), RuleSize(2, 6), RuleSize(2, 2), RuleSize(2, 2), RuleSize(4, 2), RuleSize(4, 4), RuleSize(5, 4), RuleSize(2, 3), RuleSize(6, 3), RuleSize(2, 2), RuleSize(3, 4), RuleSize(4, 4), RuleSize(2, 2), RuleSize(2, 2), RuleSize(2, 3), RuleSize(2, 1), RuleSize(4, 4)), 0, (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)) as alt0:
                [self.accept_statement, self.add_statement, self.alter_statement, self.call_statement, self.copy_statement, self.display_statement, self.divide_statement, self.evaluate_statement, self.go_to_statement, self.if_statement, self.loop_statement, self.move_statement, self.multiply_statement, self.next_sentence_statement, self.perform_statement, self.signal_statement, self.stop_statement, self.subtract_statement][alt0(current)](parent=current)
            return current
    statement.min_size = RuleSize(2, 1)

    def accept_statement(self, parent=None):
        local_ctx = dict(f=[])
        with UnparserRuleContext(self, 'accept_statement', parent) as current:
            self._reserve(1, self.ACCEPT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(2, 1), 0) as quant0:
                while quant0(current):
                    self.identifiers(parent=current)
                    local_ctx['f'].append(current.last_child)
            return current
    accept_statement.min_size = RuleSize(2, 2)

    def add_statement(self, parent=None):
        local_ctx = dict(add=[], to=[], ident=[])
        with UnparserRuleContext(self, 'add_statement', parent) as current:
            self._reserve(3, self.ADD, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 2) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
                    local_ctx['add'].append(current.last_child)
            self._reserve(1, self.TO, parent=current)
            self.atomic(parent=current)
            local_ctx['to'].append(current.last_child)
            with QuantifierContext(self, 1, 0, inf, RuleSize(2, 2), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.GIVING, parent=current)
                    self.identifiers(parent=current)
                    local_ctx['ident'].append(current.last_child)
            return current
    add_statement.min_size = RuleSize(3, 4)

    def alter_statement(self, parent=None):
        with UnparserRuleContext(self, 'alter_statement', parent) as current:
            self._reserve(5, self.ALTER, parent=current)
            self._reserve(4, self.IDENTIFIER, parent=current)
            self._reserve(3, self.TO, parent=current)
            self._reserve(2, self.PROCEED, parent=current)
            self._reserve(1, self.TO, parent=current)
            self.IDENTIFIER(parent=current)
            return current
    alter_statement.min_size = RuleSize(1, 6)

    def call_statement(self, parent=None):
        with UnparserRuleContext(self, 'call_statement', parent) as current:
            self._reserve(1, self.CALL, parent=current)
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                [self.IDENTIFIER, self.LITERAL][alt0(current)](parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 4), 0) as quant0:
                while quant0(current):
                    self._reserve(3, self.USING, parent=current)
                    with QuantifierContext(self, 1, 1, inf, RuleSize(2, 3), 0) as quant1:
                        while quant1(current):
                            self.call_types(parent=current)
            return current
    call_statement.min_size = RuleSize(1, 2)

    def copy_statement(self, parent=None):
        local_ctx = dict(replace=None, by=None)
        with UnparserRuleContext(self, 'copy_statement', parent) as current:
            self._reserve(1, self.COPY, parent=current)
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                [self.IDENTIFIER, self.LITERAL][alt0(current)](parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 4), 0) as quant0:
                while quant0(current):
                    self._reserve(3, self.REPLACING, parent=current)
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 3), 0) as quant1:
                        while quant1(current):
                            self._reserve(2, self.COPYLITERAL, parent=current)
                            local_ctx['replace'] = current.last_child
                            self._reserve(1, self.BY, parent=current)
                            self.COPYLITERAL(parent=current)
                            local_ctx['by'] = current.last_child
            return current
    copy_statement.min_size = RuleSize(1, 2)

    def display_statement(self, parent=None):
        with UnparserRuleContext(self, 'display_statement', parent) as current:
            self._reserve(1, self.DISPLAY, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
                    with QuantifierContext(self, 1, 0, 1, RuleSize(2, 3), 0) as quant1:
                        while quant1(current):
                            self._reserve(2, self.DELIMITED, parent=current)
                            self._reserve(1, self.BY, parent=current)
                            self.display_types(parent=current)
            with QuantifierContext(self, 2, 0, 1, RuleSize(1, 3), 0) as quant2:
                while quant2(current):
                    self._reserve(2, self.WITH, parent=current)
                    self._reserve(1, self.NO, parent=current)
                    self.ADVANCING(parent=current)
            return current
    display_statement.min_size = RuleSize(3, 2)

    def divide_statement(self, parent=None):
        local_ctx = dict(div=None, into=[], giving_id=[], remainder_id=None)
        with UnparserRuleContext(self, 'divide_statement', parent) as current:
            self._reserve(3, self.DIVIDE, parent=current)
            self._reserve(2, self.atomic, parent=current)
            local_ctx['div'] = current.last_child
            self._reserve(1, self.INTO, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
                    local_ctx['into'].append(current.last_child)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 2), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.GIVING, parent=current)
                    with QuantifierContext(self, 2, 1, inf, RuleSize(2, 1), 0) as quant2:
                        while quant2(current):
                            self.identifiers(parent=current)
                            local_ctx['giving_id'].append(current.last_child)
                    with QuantifierContext(self, 3, 0, 1, RuleSize(2, 2), 0) as quant3:
                        while quant3(current):
                            self._reserve(1, self.REMAINDER, parent=current)
                            self.identifiers(parent=current)
                            local_ctx['remainder_id'] = current.last_child
            return current
    divide_statement.min_size = RuleSize(3, 4)

    def go_to_statement(self, parent=None):
        with UnparserRuleContext(self, 'go_to_statement', parent) as current:
            self._reserve(2, self.GO, parent=current)
            self._reserve(1, self.TO, parent=current)
            self.IDENTIFIER(parent=current)
            return current
    go_to_statement.min_size = RuleSize(1, 3)

    def evaluate_statement(self, parent=None):
        with UnparserRuleContext(self, 'evaluate_statement', parent) as current:
            self._reserve(3, self.EVALUATE, parent=current)
            self._reserve(3, self.anyExpression, parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(3, 2), 3) as quant0:
                while quant0(current):
                    self._reserve(1, self.ALSO, parent=current)
                    self.expression(parent=current)
            with QuantifierContext(self, 1, 1, inf, RuleSize(3, 2), 1) as quant1:
                while quant1(current):
                    self._reserve(1, self.evaluate_WhenClause, parent=current)
                    with QuantifierContext(self, 2, 1, inf, RuleSize(3, 1), 0) as quant2:
                        while quant2(current):
                            self.statement(parent=current)
            self.END(parent=current)
            return current
    evaluate_statement.min_size = RuleSize(4, 4)

    def if_statement(self, parent=None):
        local_ctx = dict(then=[], esle=[])
        with UnparserRuleContext(self, 'if_statement', parent) as current:
            self._reserve(2, self.IF, parent=current)
            self._reserve(2, self.booleanExpression, parent=current)
            self._reserve(1, self.THEN, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.statement(parent=current)
                    local_ctx['then'].append(current.last_child)
            with QuantifierContext(self, 1, 0, 1, RuleSize(3, 2), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.ELSE, parent=current)
                    with QuantifierContext(self, 2, 1, inf, RuleSize(3, 1), 0) as quant2:
                        while quant2(current):
                            self.statement(parent=current)
                            local_ctx['esle'].append(current.last_child)
            with QuantifierContext(self, 3, 0, 1, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.END(parent=current)
            return current
    if_statement.min_size = RuleSize(5, 3)

    def loop_statement(self, parent=None):
        local_ctx = dict(loops=[])
        with UnparserRuleContext(self, 'loop_statement', parent) as current:
            self._reserve(1, self.LOOP, parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(2, 1), 1) as quant0:
                while quant0(current):
                    self.loop_types(parent=current)
                    local_ctx['loops'].append(current.last_child)
            self.END(parent=current)
            return current
    loop_statement.min_size = RuleSize(1, 2)

    def move_statement(self, parent=None):
        local_ctx = dict(move_ids=[])
        with UnparserRuleContext(self, 'move_statement', parent) as current:
            self._reserve(3, self.MOVE, parent=current)
            self._reserve(2, self.move_types, parent=current)
            self._reserve(1, self.TO, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(2, 1), 0) as quant0:
                while quant0(current):
                    self.identifiers(parent=current)
                    local_ctx['move_ids'].append(current.last_child)
            return current
    move_statement.min_size = RuleSize(2, 4)

    def multiply_statement(self, parent=None):
        local_ctx = dict(multiply=None, by=[], giving_id=None)
        with UnparserRuleContext(self, 'multiply_statement', parent) as current:
            self._reserve(3, self.MULTIPLY, parent=current)
            self._reserve(2, self.atomic, parent=current)
            local_ctx['multiply'] = current.last_child
            self._reserve(1, self.BY, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
                    local_ctx['by'].append(current.last_child)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 2), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.GIVING, parent=current)
                    self.identifiers(parent=current)
                    local_ctx['giving_id'] = current.last_child
            return current
    multiply_statement.min_size = RuleSize(3, 4)

    def next_sentence_statement(self, parent=None):
        with UnparserRuleContext(self, 'next_sentence_statement', parent) as current:
            self._reserve(1, self.NEXT, parent=current)
            self.SENTENCE(parent=current)
            return current
    next_sentence_statement.min_size = RuleSize(1, 2)

    def perform_statement(self, parent=None):
        with UnparserRuleContext(self, 'perform_statement', parent) as current:
            self._reserve(1, self.PERFORM, parent=current)
            self.IDENTIFIER(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 2), 0) as quant0:
                while quant0(current):
                    self._reserve(1, self.THROUGH, parent=current)
                    self.IDENTIFIER(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(3, 2), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.atomic, parent=current)
                    self.TIMES(parent=current)
            return current
    perform_statement.min_size = RuleSize(1, 2)

    def signal_statement(self, parent=None):
        with UnparserRuleContext(self, 'signal_statement', parent) as current:
            self._reserve(2, self.SIGNAL, parent=current)
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 1, (1, 1)) as alt0:
                [self.IDENTIFIER, self.OFF][alt0(current)](parent=current)
            self.ONERROR(parent=current)
            return current
    signal_statement.min_size = RuleSize(1, 3)

    def stop_statement(self, parent=None):
        with UnparserRuleContext(self, 'stop_statement', parent) as current:
            self.STOP(parent=current)
            return current
    stop_statement.min_size = RuleSize(1, 1)

    def subtract_statement(self, parent=None):
        local_ctx = dict(subtract=[], fr=[])
        with UnparserRuleContext(self, 'subtract_statement', parent) as current:
            self._reserve(3, self.SUBTRACT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 2) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
                    local_ctx['subtract'].append(current.last_child)
            self._reserve(1, self.FROM, parent=current)
            with QuantifierContext(self, 1, 1, inf, RuleSize(3, 1), 0) as quant1:
                while quant1(current):
                    self.atomic(parent=current)
                    local_ctx['fr'].append(current.last_child)
            with QuantifierContext(self, 2, 0, inf, RuleSize(2, 2), 0) as quant2:
                while quant2(current):
                    self._reserve(1, self.GIVING, parent=current)
                    self.identifiers(parent=current)
            return current
    subtract_statement.min_size = RuleSize(3, 4)

    def call_types(self, parent=None):
        with UnparserRuleContext(self, 'call_types', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 3), RuleSize(3, 3), RuleSize(3, 3)), 0, (1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self._reserve(2, self.BY, parent=current)
                    self._reserve(1, self.REFERENCE, parent=current)
                    self.IDENTIFIER(parent=current)
                elif choice0 == 1:
                    self._reserve(2, self.BY, parent=current)
                    self._reserve(1, self.CONTENT, parent=current)
                    self.atomic(parent=current)
                elif choice0 == 2:
                    self._reserve(2, self.BY, parent=current)
                    self._reserve(1, self.VALUE, parent=current)
                    self.atomic(parent=current)
            return current
    call_types.min_size = RuleSize(1, 3)

    def display_types(self, parent=None):
        with UnparserRuleContext(self, 'display_types', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(2, 1)), 0, (1, 1, 1)) as alt0:
                [self.SIZE, self.SPACE, self.literal][alt0(current)](parent=current)
            return current
    display_types.min_size = RuleSize(1, 1)

    def move_types(self, parent=None):
        with UnparserRuleContext(self, 'move_types', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(3, 1)), 0, (1, 1, 1, 1)) as alt0:
                [self.SPACES, self.HIGH, self.LOW, self.atomic][alt0(current)](parent=current)
            return current
    move_types.min_size = RuleSize(1, 1)

    def loop_types(self, parent=None):
        local_ctx = dict(fr=None, to=None, by=None)
        with UnparserRuleContext(self, 'loop_types', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(5, 1), RuleSize(5, 1), RuleSize(3, 1)), 0, (1, 1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.VARYING(parent=current)
                    with QuantifierContext(self, 0, 0, 1, RuleSize(2, 1), 0) as quant0:
                        while quant0(current):
                            self.identifiers(parent=current)
                    with QuantifierContext(self, 1, 0, 1, RuleSize(3, 2), 0) as quant1:
                        while quant1(current):
                            self._reserve(1, self.FROM, parent=current)
                            self.atomic(parent=current)
                            local_ctx['fr'] = current.last_child
                    with QuantifierContext(self, 2, 0, 1, RuleSize(3, 2), 0) as quant2:
                        while quant2(current):
                            self._reserve(1, self.TO, parent=current)
                            self.atomic(parent=current)
                            local_ctx['to'] = current.last_child
                    with QuantifierContext(self, 3, 0, 1, RuleSize(3, 2), 0) as quant3:
                        while quant3(current):
                            self._reserve(1, self.BY, parent=current)
                            self.atomic(parent=current)
                            local_ctx['by'] = current.last_child
                elif choice0 == 1:
                    self.WHILE(parent=current)
                    self.booleanExpression(parent=current)
                elif choice0 == 2:
                    self.UNTIL(parent=current)
                    self.booleanExpression(parent=current)
                elif choice0 == 3:
                    self.statement(parent=current)
            return current
    loop_types.min_size = RuleSize(1, 1)

    def evaluate_WhenClause(self, parent=None):
        with UnparserRuleContext(self, 'evaluate_WhenClause', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 2)), 0, (1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.WHEN(parent=current)
                    with QuantifierContext(self, 0, 0, inf, RuleSize(3, 2), 0) as quant0:
                        while quant0(current):
                            with QuantifierContext(self, 1, 1, inf, RuleSize(3, 1), 1) as quant1:
                                while quant1(current):
                                    self.atomic(parent=current)
                                    with QuantifierContext(self, 2, 0, 1, RuleSize(3, 2), 0) as quant2:
                                        while quant2(current):
                                            self._reserve(1, self.THROUGH, parent=current)
                                            self.atomic(parent=current)
                            self.ALSO(parent=current)
                elif choice0 == 1:
                    self.WHEN(parent=current)
                    with QuantifierContext(self, 3, 0, inf, RuleSize(3, 1), 0) as quant3:
                        while quant3(current):
                            self.atomic(parent=current)
                            with QuantifierContext(self, 4, 0, 1, RuleSize(3, 2), 0) as quant4:
                                while quant4(current):
                                    self._reserve(1, self.THROUGH, parent=current)
                                    self.atomic(parent=current)
                elif choice0 == 2:
                    self._reserve(1, self.WHEN, parent=current)
                    self.OTHER(parent=current)
            return current
    evaluate_WhenClause.min_size = RuleSize(1, 1)

    def anyExpression(self, parent=None):
        with UnparserRuleContext(self, 'anyExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 1), RuleSize(5, 0), RuleSize(3, 1)), 0, (1, 1, 1)) as alt0:
                [self.arithmeticExpression, self.booleanExpression, self.stringExpression][alt0(current)](parent=current)
            return current
    anyExpression.min_size = RuleSize(3, 0)

    def arithmeticExpression(self, parent=None):
        with UnparserRuleContext(self, 'arithmeticExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(3, 3)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.arithmeticAtomic(parent=current)
                elif choice0 == 1:
                    self._reserve(2, self.arithmeticExpression, parent=current)
                    self._reserve(1, self.arithmeticOp, parent=current)
                    self.arithmeticExpression(parent=current)
            return current
    arithmeticExpression.min_size = RuleSize(2, 1)

    def arithmeticAtomic(self, parent=None):
        with UnparserRuleContext(self, 'arithmeticAtomic', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.identifiers(parent=current)
                elif choice0 == 1:
                    with AlternationContext(self, 1, (RuleSize(1, 1), RuleSize(2, 2)), 0, (1, 1)) as alt1:
                        [self.INT, self.DOUBLE][alt1(current)](parent=current)
            return current
    arithmeticAtomic.min_size = RuleSize(1, 1)

    def stringExpression(self, parent=None):
        with UnparserRuleContext(self, 'stringExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(3, 3)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.stringAtomic(parent=current)
                elif choice0 == 1:
                    self._reserve(2, self.stringExpression, parent=current)
                    self._reserve(1, self.T__0, parent=current)
                    self.stringExpression(parent=current)
            return current
    stringExpression.min_size = RuleSize(2, 1)

    def stringAtomic(self, parent=None):
        with UnparserRuleContext(self, 'stringAtomic', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                [self.identifiers, self.LITERAL][alt0(current)](parent=current)
            return current
    stringAtomic.min_size = RuleSize(1, 1)

    def atomic(self, parent=None):
        with UnparserRuleContext(self, 'atomic', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(2, 1)), 0, (1, 1)) as alt0:
                [self.literal, self.identifiers][alt0(current)](parent=current)
            return current
    atomic.min_size = RuleSize(2, 1)

    def booleanExpression(self, parent=None):
        local_ctx = dict(left=None, right=[])
        with UnparserRuleContext(self, 'booleanExpression', parent) as current:
            self.booleanTerm(parent=current)
            local_ctx['left'] = current.last_child
            with QuantifierContext(self, 0, 0, inf, RuleSize(4, 1), 0) as quant0:
                while quant0(current):
                    with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                        [self.OR, self.XOR][alt0(current)](parent=current)
                    self.booleanTerm(parent=current)
                    local_ctx['right'].append(current.last_child)
            return current
    booleanExpression.min_size = RuleSize(4, 0)

    def booleanTerm(self, parent=None):
        local_ctx = dict(left=None, right=[])
        with UnparserRuleContext(self, 'booleanTerm', parent) as current:
            self.booleanFactor(parent=current)
            local_ctx['left'] = current.last_child
            with QuantifierContext(self, 0, 0, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.AND(parent=current)
                    self.booleanFactor(parent=current)
                    local_ctx['right'].append(current.last_child)
            return current
    booleanTerm.min_size = RuleSize(3, 0)

    def booleanFactor(self, parent=None):
        with UnparserRuleContext(self, 'booleanFactor', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 0), RuleSize(5, 2)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.booleanValue(parent=current)
                elif choice0 == 1:
                    self._reserve(1, self.T__1, parent=current)
                    self._reserve(1, self.booleanExpression, parent=current)
                    self.T__2(parent=current)
            return current
    booleanFactor.min_size = RuleSize(2, 0)

    def booleanValue(self, parent=None):
        with UnparserRuleContext(self, 'booleanValue', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(1, 0), RuleSize(2, 1)), 0, (1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.booleanOp(parent=current)
                elif choice0 == 1:
                    self.comparisonExpression(parent=current)
                elif choice0 == 2:
                    self.NOT(parent=current)
                    self.booleanValue(parent=current)
            return current
    booleanValue.min_size = RuleSize(1, 0)

    def comparisonExpression(self, parent=None):
        local_ctx = dict(right=[], left=None)
        with UnparserRuleContext(self, 'comparisonExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(6, 1), RuleSize(0, 0)), 0, (1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    with QuantifierContext(self, 0, 0, 1, RuleSize(6, 1), 0) as quant0:
                        while quant0(current):
                            self.additiveExpression(parent=current)
                            local_ctx['right'].append(current.last_child)
                elif choice0 == 1:
                    self.additiveExpression(parent=current)
                    local_ctx['left'] = current.last_child
                    with QuantifierContext(self, 1, 0, inf, RuleSize(6, 2), 0) as quant1:
                        while quant1(current):
                            self._reserve(1, self.comparisonOp, parent=current)
                            self.additiveExpression(parent=current)
                            local_ctx['right'].append(current.last_child)
                elif choice0 == 2:
                    with QuantifierContext(self, 2, 0, inf, RuleSize(6, 2), 0) as quant2:
                        while quant2(current):
                            self._reserve(1, self.comparisonOp, parent=current)
                            self.additiveExpression(parent=current)
                            local_ctx['right'].append(current.last_child)
            return current
    comparisonExpression.min_size = RuleSize(0, 0)

    def additiveExpression(self, parent=None):
        with UnparserRuleContext(self, 'additiveExpression', parent) as current:
            self.multiplicativeExpression(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(5, 2), 0) as quant0:
                while quant0(current):
                    self._reserve(1, self.arithmeticOp, parent=current)
                    self.multiplicativeExpression(parent=current)
            return current
    additiveExpression.min_size = RuleSize(5, 1)

    def multiplicativeExpression(self, parent=None):
        with UnparserRuleContext(self, 'multiplicativeExpression', parent) as current:
            self.primaryExpression(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(4, 2), 0) as quant0:
                while quant0(current):
                    self._reserve(1, self.arithmeticOp, parent=current)
                    self.primaryExpression(parent=current)
            return current
    multiplicativeExpression.min_size = RuleSize(4, 1)

    def primaryExpression(self, parent=None):
        with UnparserRuleContext(self, 'primaryExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 1), RuleSize(5, 2)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.atomic(parent=current)
                elif choice0 == 1:
                    self._reserve(1, self.T__1, parent=current)
                    self._reserve(1, self.booleanExpression, parent=current)
                    self.T__2(parent=current)
            return current
    primaryExpression.min_size = RuleSize(3, 1)

    def expression(self, parent=None):
        local_ctx = dict(left=None, right=None)
        with UnparserRuleContext(self, 'expression', parent) as current:
            self.factor(parent=current)
            local_ctx['left'] = current.last_child
            with QuantifierContext(self, 0, 0, inf, RuleSize(3, 2), 0) as quant0:
                while quant0(current):
                    self._reserve(1, self.anyOperation, parent=current)
                    self.factor(parent=current)
                    local_ctx['right'] = current.last_child
            return current
    expression.min_size = RuleSize(2, 1)

    def factor(self, parent=None):
        with UnparserRuleContext(self, 'factor', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(1, 1), RuleSize(3, 1)), 0, (1, 1, 1)) as alt0:
                [self.literal, self.IDENTIFIER, self.anyOperation][alt0(current)](parent=current)
            return current
    factor.min_size = RuleSize(1, 1)

    def int(self, parent=None):
        with UnparserRuleContext(self, 'int', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 1) as quant0:
                while quant0(current):
                    with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                        [self.DASH, self.T__0][alt0(current)](parent=current)
            self.INT(parent=current)
            return current
    int.min_size = RuleSize(1, 1)

    def literal(self, parent=None):
        with UnparserRuleContext(self, 'literal', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(2, 2), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1, 1, 1, 1)) as alt0:
                [self.int, self.DOUBLE, self.LITERAL, self.TRUE, self.FALSE][alt0(current)](parent=current)
            return current
    literal.min_size = RuleSize(1, 1)

    def anyOperation(self, parent=None):
        with UnparserRuleContext(self, 'anyOperation', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(2, 1), RuleSize(2, 1), RuleSize(2, 1)), 0, (1, 1, 1, 1)) as alt0:
                [self.comparisonOp, self.arithmeticOp, self.logicalOp, self.booleanOp][alt0(current)](parent=current)
            return current
    anyOperation.min_size = RuleSize(2, 1)

    def comparisonOp(self, parent=None):
        with UnparserRuleContext(self, 'comparisonOp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1, 1, 1, 1)) as alt0:
                [self.T__3, self.T__4, self.T__5, self.T__6, self.T__7][alt0(current)](parent=current)
            return current
    comparisonOp.min_size = RuleSize(1, 1)

    def arithmeticOp(self, parent=None):
        with UnparserRuleContext(self, 'arithmeticOp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1, 1, 1, 1)) as alt0:
                [self.T__0, self.DASH, self.T__8, self.T__9, self.T__10][alt0(current)](parent=current)
            return current
    arithmeticOp.min_size = RuleSize(1, 1)

    def logicalOp(self, parent=None):
        with UnparserRuleContext(self, 'logicalOp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                [self.OR, self.AND][alt0(current)](parent=current)
            return current
    logicalOp.min_size = RuleSize(1, 1)

    def booleanOp(self, parent=None):
        with UnparserRuleContext(self, 'booleanOp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                [self.TRUE, self.FALSE][alt0(current)](parent=current)
            return current
    booleanOp.min_size = RuleSize(1, 1)

    def IDENTIFICATION(self, parent=None):
        with UnlexerRuleContext(self, 'IDENTIFICATION', parent) as current:
            current.src += 'IDENTIFICATION'
            return current
    IDENTIFICATION.min_size = RuleSize(0, 0)

    def DIVISION(self, parent=None):
        with UnlexerRuleContext(self, 'DIVISION', parent) as current:
            current.src += 'DIVISION'
            return current
    DIVISION.min_size = RuleSize(0, 0)

    def PROCEDURE(self, parent=None):
        with UnlexerRuleContext(self, 'PROCEDURE', parent) as current:
            current.src += 'PROCEDURE'
            return current
    PROCEDURE.min_size = RuleSize(0, 0)

    def PROGRAM(self, parent=None):
        with UnlexerRuleContext(self, 'PROGRAM', parent) as current:
            current.src += 'PROGRAM'
            return current
    PROGRAM.min_size = RuleSize(0, 0)

    def ID(self, parent=None):
        with UnlexerRuleContext(self, 'ID', parent) as current:
            current.src += 'ID'
            return current
    ID.min_size = RuleSize(0, 0)

    def RUN(self, parent=None):
        with UnlexerRuleContext(self, 'RUN', parent) as current:
            current.src += 'RUN'
            return current
    RUN.min_size = RuleSize(0, 0)

    def DATA(self, parent=None):
        with UnlexerRuleContext(self, 'DATA', parent) as current:
            current.src += 'DATA'
            return current
    DATA.min_size = RuleSize(0, 0)

    def CALL(self, parent=None):
        with UnlexerRuleContext(self, 'CALL', parent) as current:
            current.src += 'CALL'
            return current
    CALL.min_size = RuleSize(0, 0)

    def COPY(self, parent=None):
        with UnlexerRuleContext(self, 'COPY', parent) as current:
            current.src += 'COPY'
            return current
    COPY.min_size = RuleSize(0, 0)

    def DISPLAY(self, parent=None):
        with UnlexerRuleContext(self, 'DISPLAY', parent) as current:
            current.src += 'DISPLAY'
            return current
    DISPLAY.min_size = RuleSize(0, 0)

    def SIZE(self, parent=None):
        with UnlexerRuleContext(self, 'SIZE', parent) as current:
            current.src += 'SIZE'
            return current
    SIZE.min_size = RuleSize(0, 0)

    def SPACE(self, parent=None):
        with UnlexerRuleContext(self, 'SPACE', parent) as current:
            current.src += 'SPACE'
            return current
    SPACE.min_size = RuleSize(0, 0)

    def WITH(self, parent=None):
        with UnlexerRuleContext(self, 'WITH', parent) as current:
            current.src += 'WITH'
            return current
    WITH.min_size = RuleSize(0, 0)

    def NO(self, parent=None):
        with UnlexerRuleContext(self, 'NO', parent) as current:
            current.src += 'NO'
            return current
    NO.min_size = RuleSize(0, 0)

    def ADVANCING(self, parent=None):
        with UnlexerRuleContext(self, 'ADVANCING', parent) as current:
            current.src += 'ADVANCING'
            return current
    ADVANCING.min_size = RuleSize(0, 0)

    def STOP(self, parent=None):
        with UnlexerRuleContext(self, 'STOP', parent) as current:
            current.src += 'STOP'
            return current
    STOP.min_size = RuleSize(0, 0)

    def MOVE(self, parent=None):
        with UnlexerRuleContext(self, 'MOVE', parent) as current:
            current.src += 'MOVE'
            return current
    MOVE.min_size = RuleSize(0, 0)

    def TO(self, parent=None):
        with UnlexerRuleContext(self, 'TO', parent) as current:
            current.src += 'TO'
            return current
    TO.min_size = RuleSize(0, 0)

    def SUBTRACT(self, parent=None):
        with UnlexerRuleContext(self, 'SUBTRACT', parent) as current:
            current.src += 'SUBTRACT'
            return current
    SUBTRACT.min_size = RuleSize(0, 0)

    def FROM(self, parent=None):
        with UnlexerRuleContext(self, 'FROM', parent) as current:
            current.src += 'FROM'
            return current
    FROM.min_size = RuleSize(0, 0)

    def GIVING(self, parent=None):
        with UnlexerRuleContext(self, 'GIVING', parent) as current:
            current.src += 'GIVING'
            return current
    GIVING.min_size = RuleSize(0, 0)

    def MULTIPLY(self, parent=None):
        with UnlexerRuleContext(self, 'MULTIPLY', parent) as current:
            current.src += 'MULTIPLY'
            return current
    MULTIPLY.min_size = RuleSize(0, 0)

    def BY(self, parent=None):
        with UnlexerRuleContext(self, 'BY', parent) as current:
            current.src += 'BY'
            return current
    BY.min_size = RuleSize(0, 0)

    def PERFORM(self, parent=None):
        with UnlexerRuleContext(self, 'PERFORM', parent) as current:
            current.src += 'PERFORM'
            return current
    PERFORM.min_size = RuleSize(0, 0)

    def TIMES(self, parent=None):
        with UnlexerRuleContext(self, 'TIMES', parent) as current:
            current.src += 'TIMES'
            return current
    TIMES.min_size = RuleSize(0, 0)

    def IF(self, parent=None):
        with UnlexerRuleContext(self, 'IF', parent) as current:
            current.src += 'IF'
            return current
    IF.min_size = RuleSize(0, 0)

    def THEN(self, parent=None):
        with UnlexerRuleContext(self, 'THEN', parent) as current:
            current.src += 'THEN'
            return current
    THEN.min_size = RuleSize(0, 0)

    def ELSE(self, parent=None):
        with UnlexerRuleContext(self, 'ELSE', parent) as current:
            current.src += 'ELSE'
            return current
    ELSE.min_size = RuleSize(0, 0)

    def END(self, parent=None):
        with UnlexerRuleContext(self, 'END', parent) as current:
            current.src += 'END'
            return current
    END.min_size = RuleSize(0, 0)

    def ACCEPT(self, parent=None):
        with UnlexerRuleContext(self, 'ACCEPT', parent) as current:
            current.src += 'ACCEPT'
            return current
    ACCEPT.min_size = RuleSize(0, 0)

    def ADD(self, parent=None):
        with UnlexerRuleContext(self, 'ADD', parent) as current:
            current.src += 'ADD'
            return current
    ADD.min_size = RuleSize(0, 0)

    def DIVIDE(self, parent=None):
        with UnlexerRuleContext(self, 'DIVIDE', parent) as current:
            current.src += 'DIVIDE'
            return current
    DIVIDE.min_size = RuleSize(0, 0)

    def DELIMITED(self, parent=None):
        with UnlexerRuleContext(self, 'DELIMITED', parent) as current:
            current.src += 'DELIMITED'
            return current
    DELIMITED.min_size = RuleSize(0, 0)

    def INTO(self, parent=None):
        with UnlexerRuleContext(self, 'INTO', parent) as current:
            current.src += 'INTO'
            return current
    INTO.min_size = RuleSize(0, 0)

    def EVALUATE(self, parent=None):
        with UnlexerRuleContext(self, 'EVALUATE', parent) as current:
            current.src += 'EVALUATE'
            return current
    EVALUATE.min_size = RuleSize(0, 0)

    def ALSO(self, parent=None):
        with UnlexerRuleContext(self, 'ALSO', parent) as current:
            current.src += 'ALSO'
            return current
    ALSO.min_size = RuleSize(0, 0)

    def WHEN(self, parent=None):
        with UnlexerRuleContext(self, 'WHEN', parent) as current:
            current.src += 'WHEN'
            return current
    WHEN.min_size = RuleSize(0, 0)

    def OTHER(self, parent=None):
        with UnlexerRuleContext(self, 'OTHER', parent) as current:
            current.src += 'OTHER'
            return current
    OTHER.min_size = RuleSize(0, 0)

    def TRUE(self, parent=None):
        with UnlexerRuleContext(self, 'TRUE', parent) as current:
            current.src += 'TRUE'
            return current
    TRUE.min_size = RuleSize(0, 0)

    def FALSE(self, parent=None):
        with UnlexerRuleContext(self, 'FALSE', parent) as current:
            current.src += 'FALSE'
            return current
    FALSE.min_size = RuleSize(0, 0)

    def NOT(self, parent=None):
        with UnlexerRuleContext(self, 'NOT', parent) as current:
            current.src += 'NOT'
            return current
    NOT.min_size = RuleSize(0, 0)

    def OR(self, parent=None):
        with UnlexerRuleContext(self, 'OR', parent) as current:
            current.src += 'OR'
            return current
    OR.min_size = RuleSize(0, 0)

    def AND(self, parent=None):
        with UnlexerRuleContext(self, 'AND', parent) as current:
            current.src += 'AND'
            return current
    AND.min_size = RuleSize(0, 0)

    def XOR(self, parent=None):
        with UnlexerRuleContext(self, 'XOR', parent) as current:
            current.src += 'XOR'
            return current
    XOR.min_size = RuleSize(0, 0)

    def NEXT(self, parent=None):
        with UnlexerRuleContext(self, 'NEXT', parent) as current:
            current.src += 'NEXT'
            return current
    NEXT.min_size = RuleSize(0, 0)

    def SENTENCE(self, parent=None):
        with UnlexerRuleContext(self, 'SENTENCE', parent) as current:
            current.src += 'SENTENCE'
            return current
    SENTENCE.min_size = RuleSize(0, 0)

    def REMAINDER(self, parent=None):
        with UnlexerRuleContext(self, 'REMAINDER', parent) as current:
            current.src += 'REMAINDER'
            return current
    REMAINDER.min_size = RuleSize(0, 0)

    def LOOP(self, parent=None):
        with UnlexerRuleContext(self, 'LOOP', parent) as current:
            current.src += 'LOOP'
            return current
    LOOP.min_size = RuleSize(0, 0)

    def VARYING(self, parent=None):
        with UnlexerRuleContext(self, 'VARYING', parent) as current:
            current.src += 'VARYING'
            return current
    VARYING.min_size = RuleSize(0, 0)

    def WHILE(self, parent=None):
        with UnlexerRuleContext(self, 'WHILE', parent) as current:
            current.src += 'WHILE'
            return current
    WHILE.min_size = RuleSize(0, 0)

    def REPLACING(self, parent=None):
        with UnlexerRuleContext(self, 'REPLACING', parent) as current:
            current.src += 'REPLACING'
            return current
    REPLACING.min_size = RuleSize(0, 0)

    def UNTIL(self, parent=None):
        with UnlexerRuleContext(self, 'UNTIL', parent) as current:
            current.src += 'UNTIL'
            return current
    UNTIL.min_size = RuleSize(0, 0)

    def OF(self, parent=None):
        with UnlexerRuleContext(self, 'OF', parent) as current:
            current.src += 'OF'
            return current
    OF.min_size = RuleSize(0, 0)

    def THROUGH(self, parent=None):
        with UnlexerRuleContext(self, 'THROUGH', parent) as current:
            current.src += 'THROUGH'
            return current
    THROUGH.min_size = RuleSize(0, 0)

    def PICTURE(self, parent=None):
        with UnlexerRuleContext(self, 'PICTURE', parent) as current:
            current.src += 'PICTURE'
            return current
    PICTURE.min_size = RuleSize(0, 0)

    def PARAGRAPH(self, parent=None):
        with UnlexerRuleContext(self, 'PARAGRAPH', parent) as current:
            current.src += 'PARAGRAPH'
            return current
    PARAGRAPH.min_size = RuleSize(0, 0)

    def IS(self, parent=None):
        with UnlexerRuleContext(self, 'IS', parent) as current:
            current.src += 'IS'
            return current
    IS.min_size = RuleSize(0, 0)

    def LIKE(self, parent=None):
        with UnlexerRuleContext(self, 'LIKE', parent) as current:
            current.src += 'LIKE'
            return current
    LIKE.min_size = RuleSize(0, 0)

    def OCCURS(self, parent=None):
        with UnlexerRuleContext(self, 'OCCURS', parent) as current:
            current.src += 'OCCURS'
            return current
    OCCURS.min_size = RuleSize(0, 0)

    def GO(self, parent=None):
        with UnlexerRuleContext(self, 'GO', parent) as current:
            current.src += 'GO'
            return current
    GO.min_size = RuleSize(0, 0)

    def SPACES(self, parent=None):
        with UnlexerRuleContext(self, 'SPACES', parent) as current:
            current.src += 'SPACES'
            return current
    SPACES.min_size = RuleSize(0, 0)

    def VALUE(self, parent=None):
        with UnlexerRuleContext(self, 'VALUE', parent) as current:
            current.src += 'VALUE'
            return current
    VALUE.min_size = RuleSize(0, 0)

    def HIGH(self, parent=None):
        with UnlexerRuleContext(self, 'HIGH', parent) as current:
            current.src += 'HIGH-VALUES'
            return current
    HIGH.min_size = RuleSize(0, 0)

    def LOW(self, parent=None):
        with UnlexerRuleContext(self, 'LOW', parent) as current:
            current.src += 'LOW-VALUES'
            return current
    LOW.min_size = RuleSize(0, 0)

    def USING(self, parent=None):
        with UnlexerRuleContext(self, 'USING', parent) as current:
            current.src += 'USING'
            return current
    USING.min_size = RuleSize(0, 0)

    def REFERENCE(self, parent=None):
        with UnlexerRuleContext(self, 'REFERENCE', parent) as current:
            current.src += 'REFERENCE'
            return current
    REFERENCE.min_size = RuleSize(0, 0)

    def CONTENT(self, parent=None):
        with UnlexerRuleContext(self, 'CONTENT', parent) as current:
            current.src += 'CONTENT'
            return current
    CONTENT.min_size = RuleSize(0, 0)

    def SIGNAL(self, parent=None):
        with UnlexerRuleContext(self, 'SIGNAL', parent) as current:
            current.src += 'SIGNAL'
            return current
    SIGNAL.min_size = RuleSize(0, 0)

    def ONERROR(self, parent=None):
        with UnlexerRuleContext(self, 'ONERROR', parent) as current:
            current.src += 'ON ERROR'
            return current
    ONERROR.min_size = RuleSize(0, 0)

    def OFF(self, parent=None):
        with UnlexerRuleContext(self, 'OFF', parent) as current:
            current.src += 'OFF'
            return current
    OFF.min_size = RuleSize(0, 0)

    def ALTER(self, parent=None):
        with UnlexerRuleContext(self, 'ALTER', parent) as current:
            current.src += 'ALTER'
            return current
    ALTER.min_size = RuleSize(0, 0)

    def PROCEED(self, parent=None):
        with UnlexerRuleContext(self, 'PROCEED', parent) as current:
            current.src += 'PROCEED'
            return current
    PROCEED.min_size = RuleSize(0, 0)

    def WS(self, parent=None):
        with UnlexerRuleContext(self, 'WS', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1, 1, 1)) as alt0:
                        current.src += [' ', '\t', '\r', '\n'][alt0(current)]
            return current
    WS.min_size = RuleSize(0, 0)

    def INT(self, parent=None):
        with UnlexerRuleContext(self, 'INT', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[1])
            return current
    INT.min_size = RuleSize(0, 0)

    def DOUBLE(self, parent=None):
        with UnlexerRuleContext(self, 'DOUBLE', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(0, 0), 1) as quant0:
                while quant0(current):
                    with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                        current.src += ['-', '+'][alt0(current)]
            self.INT(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(1, 2), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.DOT, parent=current)
                    self.INT(parent=current)
            return current
    DOUBLE.min_size = RuleSize(1, 1)

    def LITERAL(self, parent=None):
        with UnlexerRuleContext(self, 'LITERAL', parent) as current:
            current.src += '"'
            with QuantifierContext(self, 0, 0, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[2])
            current.src += '"'
            return current
    LITERAL.min_size = RuleSize(0, 0)

    def COPYLITERAL(self, parent=None):
        with UnlexerRuleContext(self, 'COPYLITERAL', parent) as current:
            current.src += '==='
            with QuantifierContext(self, 0, 0, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[3])
            current.src += '==='
            return current
    COPYLITERAL.min_size = RuleSize(0, 0)

    def DOT(self, parent=None):
        with UnlexerRuleContext(self, 'DOT', parent) as current:
            current.src += '.'
            return current
    DOT.min_size = RuleSize(0, 0)

    def IDENTIFIER(self, parent=None):
        with UnlexerRuleContext(self, 'IDENTIFIER', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[4])
            with QuantifierContext(self, 1, 1, inf, RuleSize(0, 0), 0) as quant1:
                while quant1(current):
                    current.src += self._model.charset(current, 1, self._charsets[1])
            with QuantifierContext(self, 2, 0, inf, RuleSize(0, 0), 0) as quant2:
                while quant2(current):
                    with QuantifierContext(self, 3, 1, inf, RuleSize(0, 0), 0) as quant3:
                        while quant3(current):
                            current.src += self._model.charset(current, 2, self._charsets[5])
                    with QuantifierContext(self, 4, 1, inf, RuleSize(0, 0), 0) as quant4:
                        while quant4(current):
                            current.src += self._model.charset(current, 3, self._charsets[6])
            return current
    IDENTIFIER.min_size = RuleSize(0, 0)

    def VAR(self, parent=None):
        with UnlexerRuleContext(self, 'VAR', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[4])
            return current
    VAR.min_size = RuleSize(0, 0)

    def DIGIT(self, parent=None):
        with UnlexerRuleContext(self, 'DIGIT', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += '-'
            with QuantifierContext(self, 1, 1, inf, RuleSize(0, 0), 0) as quant1:
                while quant1(current):
                    current.src += self._model.charset(current, 0, self._charsets[1])
            return current
    DIGIT.min_size = RuleSize(0, 0)

    def DASH(self, parent=None):
        with UnlexerRuleContext(self, 'DASH', parent) as current:
            current.src += '-'
            return current
    DASH.min_size = RuleSize(0, 0)

    def COMMA(self, parent=None):
        with UnlexerRuleContext(self, 'COMMA', parent) as current:
            current.src += ','
            return current
    COMMA.min_size = RuleSize(0, 0)

    def INDEX(self, parent=None):
        with UnlexerRuleContext(self, 'INDEX', parent) as current:
            current.src += '('
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    with QuantifierContext(self, 0, 0, inf, RuleSize(0, 0), 0) as quant0:
                        while quant0(current):
                            current.src += self._model.charset(current, 0, self._charsets[1])
                elif choice0 == 1:
                    self.IDENTIFIER(parent=current)
            current.src += ')'
            return current
    INDEX.min_size = RuleSize(0, 0)

    def COMMENT(self, parent=None):
        with UnlexerRuleContext(self, 'COMMENT', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += '\r'
            current.src += '\n'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.WS(parent=current)
            current.src += '*'
            with QuantifierContext(self, 2, 0, inf, RuleSize(0, 0), 0) as quant2:
                while quant2(current):
                    current.src += self._model.charset(current, 0, self._charsets[0])
            with QuantifierContext(self, 3, 0, 1, RuleSize(0, 0), 0) as quant3:
                while quant3(current):
                    current.src += '\r'
            current.src += '\n'
            return current
    COMMENT.min_size = RuleSize(0, 0)

    def T__0(self, parent=None):
        with UnlexerRuleContext(self, 'T__0', parent) as current:
            current.src += '+'
            return current
    T__0.min_size = RuleSize(0, 0)

    def T__1(self, parent=None):
        with UnlexerRuleContext(self, 'T__1', parent) as current:
            current.src += '('
            return current
    T__1.min_size = RuleSize(0, 0)

    def T__2(self, parent=None):
        with UnlexerRuleContext(self, 'T__2', parent) as current:
            current.src += ')'
            return current
    T__2.min_size = RuleSize(0, 0)

    def T__3(self, parent=None):
        with UnlexerRuleContext(self, 'T__3', parent) as current:
            current.src += '='
            return current
    T__3.min_size = RuleSize(0, 0)

    def T__4(self, parent=None):
        with UnlexerRuleContext(self, 'T__4', parent) as current:
            current.src += '>'
            return current
    T__4.min_size = RuleSize(0, 0)

    def T__5(self, parent=None):
        with UnlexerRuleContext(self, 'T__5', parent) as current:
            current.src += '<'
            return current
    T__5.min_size = RuleSize(0, 0)

    def T__6(self, parent=None):
        with UnlexerRuleContext(self, 'T__6', parent) as current:
            current.src += '>='
            return current
    T__6.min_size = RuleSize(0, 0)

    def T__7(self, parent=None):
        with UnlexerRuleContext(self, 'T__7', parent) as current:
            current.src += '<='
            return current
    T__7.min_size = RuleSize(0, 0)

    def T__8(self, parent=None):
        with UnlexerRuleContext(self, 'T__8', parent) as current:
            current.src += '*'
            return current
    T__8.min_size = RuleSize(0, 0)

    def T__9(self, parent=None):
        with UnlexerRuleContext(self, 'T__9', parent) as current:
            current.src += '**'
            return current
    T__9.min_size = RuleSize(0, 0)

    def T__10(self, parent=None):
        with UnlexerRuleContext(self, 'T__10', parent) as current:
            current.src += '/'
            return current
    T__10.min_size = RuleSize(0, 0)

    _default_rule = program

    _charsets = {
        0: list(itertools.chain.from_iterable([range(0x20, 0x7f)])),
        1: list(itertools.chain.from_iterable([range(0x30, 0x3a)])),
        2: list(itertools.chain.from_iterable([range(0x20, 0x22), range(0x23, 0x7f)])),
        3: list(itertools.chain.from_iterable([range(0x20, 0x3d), range(0x3e, 0x7f)])),
        4: list(itertools.chain.from_iterable([range(0x41, 0x5b), range(0x61, 0x7b)])),
        5: list(itertools.chain.from_iterable([range(0x2d, 0x2e), range(0x5f, 0x60)])),
        6: list(itertools.chain.from_iterable([range(0x30, 0x3a), range(0x41, 0x5b), range(0x61, 0x7b)])),
    }
