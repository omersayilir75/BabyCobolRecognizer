# Generated by Grammarinator 23.7.post31+g3f15e2c.d20231108

import itertools

from math import inf
from grammarinator.runtime import *

class babyGenerator(Generator):


    def EOF(self, parent=None):
        pass
    EOF.min_size = RuleSize(0, 0)

    def A(self, parent=None):
        with UnlexerRuleContext(self, 'A', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['a', 'A'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    A.min_size = RuleSize(0, 0)

    def B(self, parent=None):
        with UnlexerRuleContext(self, 'B', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['b', 'B'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    B.min_size = RuleSize(0, 0)

    def C(self, parent=None):
        with UnlexerRuleContext(self, 'C', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['c', 'C'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    C.min_size = RuleSize(0, 0)

    def D(self, parent=None):
        with UnlexerRuleContext(self, 'D', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['d', 'D'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    D.min_size = RuleSize(0, 0)

    def E(self, parent=None):
        with UnlexerRuleContext(self, 'E', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['e', 'E'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    E.min_size = RuleSize(0, 0)

    def F(self, parent=None):
        with UnlexerRuleContext(self, 'F', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['f', 'F'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    F.min_size = RuleSize(0, 0)

    def G(self, parent=None):
        with UnlexerRuleContext(self, 'G', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['g', 'G'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    G.min_size = RuleSize(0, 0)

    def H(self, parent=None):
        with UnlexerRuleContext(self, 'H', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['h', 'H'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    H.min_size = RuleSize(0, 0)

    def I(self, parent=None):
        with UnlexerRuleContext(self, 'I', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['i', 'I'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    I.min_size = RuleSize(0, 0)

    def J(self, parent=None):
        with UnlexerRuleContext(self, 'J', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['j', 'J'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    J.min_size = RuleSize(0, 0)

    def K(self, parent=None):
        with UnlexerRuleContext(self, 'K', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['k', 'K'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    K.min_size = RuleSize(0, 0)

    def L(self, parent=None):
        with UnlexerRuleContext(self, 'L', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['l', 'L'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    L.min_size = RuleSize(0, 0)

    def M(self, parent=None):
        with UnlexerRuleContext(self, 'M', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['m', 'M'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    M.min_size = RuleSize(0, 0)

    def N(self, parent=None):
        with UnlexerRuleContext(self, 'N', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['n', 'N'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    N.min_size = RuleSize(0, 0)

    def O(self, parent=None):
        with UnlexerRuleContext(self, 'O', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['o', 'O'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    O.min_size = RuleSize(0, 0)

    def P(self, parent=None):
        with UnlexerRuleContext(self, 'P', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['p', 'P'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    P.min_size = RuleSize(0, 0)

    def Q(self, parent=None):
        with UnlexerRuleContext(self, 'Q', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['q', 'Q'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    Q.min_size = RuleSize(0, 0)

    def R(self, parent=None):
        with UnlexerRuleContext(self, 'R', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['r', 'R'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    R.min_size = RuleSize(0, 0)

    def S(self, parent=None):
        with UnlexerRuleContext(self, 'S', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['s', 'S'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    S.min_size = RuleSize(0, 0)

    def T(self, parent=None):
        with UnlexerRuleContext(self, 'T', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['t', 'T'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    T.min_size = RuleSize(0, 0)

    def U(self, parent=None):
        with UnlexerRuleContext(self, 'U', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['u', 'U'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    U.min_size = RuleSize(0, 0)

    def V(self, parent=None):
        with UnlexerRuleContext(self, 'V', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['v', 'V'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    V.min_size = RuleSize(0, 0)

    def W(self, parent=None):
        with UnlexerRuleContext(self, 'W', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['w', 'W'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    W.min_size = RuleSize(0, 0)

    def X(self, parent=None):
        with UnlexerRuleContext(self, 'X', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['x', 'X'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    X.min_size = RuleSize(0, 0)

    def Y(self, parent=None):
        with UnlexerRuleContext(self, 'Y', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['y', 'Y'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    Y.min_size = RuleSize(0, 0)

    def Z(self, parent=None):
        with UnlexerRuleContext(self, 'Z', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['z', 'Z'][alt0(current)]
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.WS(parent=current)
            return current
    Z.min_size = RuleSize(0, 0)

    def GOTO(self, parent=None):
        with UnlexerRuleContext(self, 'GOTO', parent) as current:
            self._reserve(3, self.G, parent=current)
            self._reserve(2, self.O, parent=current)
            self._reserve(1, self.T, parent=current)
            self.O(parent=current)
            return current
    GOTO.min_size = RuleSize(1, 4)

    def WITHNOADVANCING(self, parent=None):
        with UnlexerRuleContext(self, 'WITHNOADVANCING', parent) as current:
            self._reserve(14, self.W, parent=current)
            self._reserve(13, self.I, parent=current)
            self._reserve(12, self.T, parent=current)
            self._reserve(11, self.H, parent=current)
            self._reserve(10, self.N, parent=current)
            self._reserve(9, self.O, parent=current)
            self._reserve(8, self.A, parent=current)
            self._reserve(7, self.D, parent=current)
            self._reserve(6, self.V, parent=current)
            self._reserve(5, self.A, parent=current)
            self._reserve(4, self.N, parent=current)
            self._reserve(3, self.C, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.N, parent=current)
            self.G(parent=current)
            return current
    WITHNOADVANCING.min_size = RuleSize(1, 15)

    def DELIMITEDBY(self, parent=None):
        with UnlexerRuleContext(self, 'DELIMITEDBY', parent) as current:
            self._reserve(10, self.D, parent=current)
            self._reserve(9, self.E, parent=current)
            self._reserve(8, self.L, parent=current)
            self._reserve(7, self.I, parent=current)
            self._reserve(6, self.M, parent=current)
            self._reserve(5, self.I, parent=current)
            self._reserve(4, self.T, parent=current)
            self._reserve(3, self.E, parent=current)
            self._reserve(2, self.D, parent=current)
            self._reserve(1, self.B, parent=current)
            self.Y(parent=current)
            return current
    DELIMITEDBY.min_size = RuleSize(1, 11)

    def HIGHVALUES(self, parent=None):
        with UnlexerRuleContext(self, 'HIGHVALUES', parent) as current:
            self._reserve(9, self.H, parent=current)
            self._reserve(8, self.I, parent=current)
            self._reserve(7, self.G, parent=current)
            self._reserve(6, self.H, parent=current)
            current.src += '-'
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 6) as quant0:
                while quant0(current):
                    self.WS(parent=current)
            self._reserve(5, self.V, parent=current)
            self._reserve(4, self.A, parent=current)
            self._reserve(3, self.L, parent=current)
            self._reserve(2, self.U, parent=current)
            self._reserve(1, self.E, parent=current)
            self.S(parent=current)
            return current
    HIGHVALUES.min_size = RuleSize(1, 10)

    def LOWVALUES(self, parent=None):
        with UnlexerRuleContext(self, 'LOWVALUES', parent) as current:
            self._reserve(8, self.L, parent=current)
            self._reserve(7, self.O, parent=current)
            self._reserve(6, self.W, parent=current)
            current.src += '-'
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 6) as quant0:
                while quant0(current):
                    self.WS(parent=current)
            self._reserve(5, self.V, parent=current)
            self._reserve(4, self.A, parent=current)
            self._reserve(3, self.L, parent=current)
            self._reserve(2, self.U, parent=current)
            self._reserve(1, self.E, parent=current)
            self.S(parent=current)
            return current
    LOWVALUES.min_size = RuleSize(1, 9)

    def SPACES(self, parent=None):
        with UnlexerRuleContext(self, 'SPACES', parent) as current:
            self._reserve(5, self.S, parent=current)
            self._reserve(4, self.P, parent=current)
            self._reserve(3, self.A, parent=current)
            self._reserve(2, self.C, parent=current)
            self._reserve(1, self.E, parent=current)
            self.S(parent=current)
            return current
    SPACES.min_size = RuleSize(1, 6)

    def SPACE(self, parent=None):
        with UnlexerRuleContext(self, 'SPACE', parent) as current:
            self._reserve(4, self.S, parent=current)
            self._reserve(3, self.P, parent=current)
            self._reserve(2, self.A, parent=current)
            self._reserve(1, self.C, parent=current)
            self.E(parent=current)
            return current
    SPACE.min_size = RuleSize(1, 5)

    def ACCEPT(self, parent=None):
        with UnlexerRuleContext(self, 'ACCEPT', parent) as current:
            self._reserve(5, self.A, parent=current)
            self._reserve(4, self.C, parent=current)
            self._reserve(3, self.C, parent=current)
            self._reserve(2, self.E, parent=current)
            self._reserve(1, self.P, parent=current)
            self.T(parent=current)
            return current
    ACCEPT.min_size = RuleSize(1, 6)

    def ADD(self, parent=None):
        with UnlexerRuleContext(self, 'ADD', parent) as current:
            self._reserve(2, self.A, parent=current)
            self._reserve(1, self.D, parent=current)
            self.D(parent=current)
            return current
    ADD.min_size = RuleSize(1, 3)

    def GIVING(self, parent=None):
        with UnlexerRuleContext(self, 'GIVING', parent) as current:
            self._reserve(5, self.G, parent=current)
            self._reserve(4, self.I, parent=current)
            self._reserve(3, self.V, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.N, parent=current)
            self.G(parent=current)
            return current
    GIVING.min_size = RuleSize(1, 6)

    def DISPLAY(self, parent=None):
        with UnlexerRuleContext(self, 'DISPLAY', parent) as current:
            self._reserve(6, self.D, parent=current)
            self._reserve(5, self.I, parent=current)
            self._reserve(4, self.S, parent=current)
            self._reserve(3, self.P, parent=current)
            self._reserve(2, self.L, parent=current)
            self._reserve(1, self.A, parent=current)
            self.Y(parent=current)
            return current
    DISPLAY.min_size = RuleSize(1, 7)

    def SIZE(self, parent=None):
        with UnlexerRuleContext(self, 'SIZE', parent) as current:
            self._reserve(3, self.S, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.Z, parent=current)
            self.E(parent=current)
            return current
    SIZE.min_size = RuleSize(1, 4)

    def DIVIDE(self, parent=None):
        with UnlexerRuleContext(self, 'DIVIDE', parent) as current:
            self._reserve(5, self.D, parent=current)
            self._reserve(4, self.I, parent=current)
            self._reserve(3, self.V, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.D, parent=current)
            self.E(parent=current)
            return current
    DIVIDE.min_size = RuleSize(1, 6)

    def INTO(self, parent=None):
        with UnlexerRuleContext(self, 'INTO', parent) as current:
            self._reserve(3, self.I, parent=current)
            self._reserve(2, self.N, parent=current)
            self._reserve(1, self.T, parent=current)
            self.O(parent=current)
            return current
    INTO.min_size = RuleSize(1, 4)

    def REMAINDER(self, parent=None):
        with UnlexerRuleContext(self, 'REMAINDER', parent) as current:
            self._reserve(8, self.R, parent=current)
            self._reserve(7, self.E, parent=current)
            self._reserve(6, self.M, parent=current)
            self._reserve(5, self.A, parent=current)
            self._reserve(4, self.I, parent=current)
            self._reserve(3, self.N, parent=current)
            self._reserve(2, self.D, parent=current)
            self._reserve(1, self.E, parent=current)
            self.R(parent=current)
            return current
    REMAINDER.min_size = RuleSize(1, 9)

    def EVALUATE(self, parent=None):
        with UnlexerRuleContext(self, 'EVALUATE', parent) as current:
            self._reserve(7, self.E, parent=current)
            self._reserve(6, self.V, parent=current)
            self._reserve(5, self.A, parent=current)
            self._reserve(4, self.L, parent=current)
            self._reserve(3, self.U, parent=current)
            self._reserve(2, self.A, parent=current)
            self._reserve(1, self.T, parent=current)
            self.E(parent=current)
            return current
    EVALUATE.min_size = RuleSize(1, 8)

    def WHEN(self, parent=None):
        with UnlexerRuleContext(self, 'WHEN', parent) as current:
            self._reserve(3, self.W, parent=current)
            self._reserve(2, self.H, parent=current)
            self._reserve(1, self.E, parent=current)
            self.N(parent=current)
            return current
    WHEN.min_size = RuleSize(1, 4)

    def OTHER(self, parent=None):
        with UnlexerRuleContext(self, 'OTHER', parent) as current:
            self._reserve(4, self.O, parent=current)
            self._reserve(3, self.T, parent=current)
            self._reserve(2, self.H, parent=current)
            self._reserve(1, self.E, parent=current)
            self.R(parent=current)
            return current
    OTHER.min_size = RuleSize(1, 5)

    def END(self, parent=None):
        with UnlexerRuleContext(self, 'END', parent) as current:
            self._reserve(2, self.E, parent=current)
            self._reserve(1, self.N, parent=current)
            self.D(parent=current)
            return current
    END.min_size = RuleSize(1, 3)

    def IF(self, parent=None):
        with UnlexerRuleContext(self, 'IF', parent) as current:
            self._reserve(1, self.I, parent=current)
            self.F(parent=current)
            return current
    IF.min_size = RuleSize(1, 2)

    def THEN(self, parent=None):
        with UnlexerRuleContext(self, 'THEN', parent) as current:
            self._reserve(3, self.T, parent=current)
            self._reserve(2, self.H, parent=current)
            self._reserve(1, self.E, parent=current)
            self.N(parent=current)
            return current
    THEN.min_size = RuleSize(1, 4)

    def ELSE(self, parent=None):
        with UnlexerRuleContext(self, 'ELSE', parent) as current:
            self._reserve(3, self.E, parent=current)
            self._reserve(2, self.L, parent=current)
            self._reserve(1, self.S, parent=current)
            self.E(parent=current)
            return current
    ELSE.min_size = RuleSize(1, 4)

    def NOT(self, parent=None):
        with UnlexerRuleContext(self, 'NOT', parent) as current:
            self._reserve(2, self.N, parent=current)
            self._reserve(1, self.O, parent=current)
            self.T(parent=current)
            return current
    NOT.min_size = RuleSize(1, 3)

    def MOVE(self, parent=None):
        with UnlexerRuleContext(self, 'MOVE', parent) as current:
            self._reserve(3, self.M, parent=current)
            self._reserve(2, self.O, parent=current)
            self._reserve(1, self.V, parent=current)
            self.E(parent=current)
            return current
    MOVE.min_size = RuleSize(1, 4)

    def MULTIPLY(self, parent=None):
        with UnlexerRuleContext(self, 'MULTIPLY', parent) as current:
            self._reserve(7, self.M, parent=current)
            self._reserve(6, self.U, parent=current)
            self._reserve(5, self.L, parent=current)
            self._reserve(4, self.T, parent=current)
            self._reserve(3, self.I, parent=current)
            self._reserve(2, self.P, parent=current)
            self._reserve(1, self.L, parent=current)
            self.Y(parent=current)
            return current
    MULTIPLY.min_size = RuleSize(1, 8)

    def BY(self, parent=None):
        with UnlexerRuleContext(self, 'BY', parent) as current:
            self._reserve(1, self.B, parent=current)
            self.Y(parent=current)
            return current
    BY.min_size = RuleSize(1, 2)

    def PERFORM(self, parent=None):
        with UnlexerRuleContext(self, 'PERFORM', parent) as current:
            self._reserve(6, self.P, parent=current)
            self._reserve(5, self.E, parent=current)
            self._reserve(4, self.R, parent=current)
            self._reserve(3, self.F, parent=current)
            self._reserve(2, self.O, parent=current)
            self._reserve(1, self.R, parent=current)
            self.M(parent=current)
            return current
    PERFORM.min_size = RuleSize(1, 7)

    def THROUGH(self, parent=None):
        with UnlexerRuleContext(self, 'THROUGH', parent) as current:
            self._reserve(6, self.T, parent=current)
            self._reserve(5, self.H, parent=current)
            self._reserve(4, self.R, parent=current)
            self._reserve(3, self.O, parent=current)
            self._reserve(2, self.U, parent=current)
            self._reserve(1, self.G, parent=current)
            self.H(parent=current)
            return current
    THROUGH.min_size = RuleSize(1, 7)

    def TIMES(self, parent=None):
        with UnlexerRuleContext(self, 'TIMES', parent) as current:
            self._reserve(4, self.T, parent=current)
            self._reserve(3, self.I, parent=current)
            self._reserve(2, self.M, parent=current)
            self._reserve(1, self.E, parent=current)
            self.S(parent=current)
            return current
    TIMES.min_size = RuleSize(1, 5)

    def STOP(self, parent=None):
        with UnlexerRuleContext(self, 'STOP', parent) as current:
            self._reserve(3, self.S, parent=current)
            self._reserve(2, self.T, parent=current)
            self._reserve(1, self.O, parent=current)
            self.P(parent=current)
            return current
    STOP.min_size = RuleSize(1, 4)

    def SUBTRACT(self, parent=None):
        with UnlexerRuleContext(self, 'SUBTRACT', parent) as current:
            self._reserve(7, self.S, parent=current)
            self._reserve(6, self.U, parent=current)
            self._reserve(5, self.B, parent=current)
            self._reserve(4, self.T, parent=current)
            self._reserve(3, self.R, parent=current)
            self._reserve(2, self.A, parent=current)
            self._reserve(1, self.C, parent=current)
            self.T(parent=current)
            return current
    SUBTRACT.min_size = RuleSize(1, 8)

    def FROM(self, parent=None):
        with UnlexerRuleContext(self, 'FROM', parent) as current:
            self._reserve(3, self.F, parent=current)
            self._reserve(2, self.R, parent=current)
            self._reserve(1, self.O, parent=current)
            self.M(parent=current)
            return current
    FROM.min_size = RuleSize(1, 4)

    def AND(self, parent=None):
        with UnlexerRuleContext(self, 'AND', parent) as current:
            self._reserve(2, self.A, parent=current)
            self._reserve(1, self.N, parent=current)
            self.D(parent=current)
            return current
    AND.min_size = RuleSize(1, 3)

    def XOR(self, parent=None):
        with UnlexerRuleContext(self, 'XOR', parent) as current:
            self._reserve(2, self.X, parent=current)
            self._reserve(1, self.O, parent=current)
            self.R(parent=current)
            return current
    XOR.min_size = RuleSize(1, 3)

    def OR(self, parent=None):
        with UnlexerRuleContext(self, 'OR', parent) as current:
            self._reserve(1, self.O, parent=current)
            self.R(parent=current)
            return current
    OR.min_size = RuleSize(1, 2)

    def TRUE(self, parent=None):
        with UnlexerRuleContext(self, 'TRUE', parent) as current:
            self._reserve(3, self.T, parent=current)
            self._reserve(2, self.R, parent=current)
            self._reserve(1, self.U, parent=current)
            self.E(parent=current)
            return current
    TRUE.min_size = RuleSize(1, 4)

    def FALSE(self, parent=None):
        with UnlexerRuleContext(self, 'FALSE', parent) as current:
            self._reserve(4, self.F, parent=current)
            self._reserve(3, self.A, parent=current)
            self._reserve(2, self.L, parent=current)
            self._reserve(1, self.S, parent=current)
            self.E(parent=current)
            return current
    FALSE.min_size = RuleSize(1, 5)

    def LOOP(self, parent=None):
        with UnlexerRuleContext(self, 'LOOP', parent) as current:
            self._reserve(3, self.L, parent=current)
            self._reserve(2, self.O, parent=current)
            self._reserve(1, self.O, parent=current)
            self.P(parent=current)
            return current
    LOOP.min_size = RuleSize(1, 4)

    def VARYING(self, parent=None):
        with UnlexerRuleContext(self, 'VARYING', parent) as current:
            self._reserve(6, self.V, parent=current)
            self._reserve(5, self.A, parent=current)
            self._reserve(4, self.R, parent=current)
            self._reserve(3, self.Y, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.N, parent=current)
            self.G(parent=current)
            return current
    VARYING.min_size = RuleSize(1, 7)

    def WHILE(self, parent=None):
        with UnlexerRuleContext(self, 'WHILE', parent) as current:
            self._reserve(4, self.W, parent=current)
            self._reserve(3, self.H, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.L, parent=current)
            self.E(parent=current)
            return current
    WHILE.min_size = RuleSize(1, 5)

    def UNTIL(self, parent=None):
        with UnlexerRuleContext(self, 'UNTIL', parent) as current:
            self._reserve(4, self.U, parent=current)
            self._reserve(3, self.N, parent=current)
            self._reserve(2, self.T, parent=current)
            self._reserve(1, self.I, parent=current)
            self.L(parent=current)
            return current
    UNTIL.min_size = RuleSize(1, 5)

    def LIKE(self, parent=None):
        with UnlexerRuleContext(self, 'LIKE', parent) as current:
            self._reserve(3, self.L, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.K, parent=current)
            self.E(parent=current)
            return current
    LIKE.min_size = RuleSize(1, 4)

    def OCCURS(self, parent=None):
        with UnlexerRuleContext(self, 'OCCURS', parent) as current:
            self._reserve(5, self.O, parent=current)
            self._reserve(4, self.C, parent=current)
            self._reserve(3, self.C, parent=current)
            self._reserve(2, self.U, parent=current)
            self._reserve(1, self.R, parent=current)
            self.S(parent=current)
            return current
    OCCURS.min_size = RuleSize(1, 6)

    def IDENTIFICATION(self, parent=None):
        with UnlexerRuleContext(self, 'IDENTIFICATION', parent) as current:
            self._reserve(13, self.I, parent=current)
            self._reserve(12, self.D, parent=current)
            self._reserve(11, self.E, parent=current)
            self._reserve(10, self.N, parent=current)
            self._reserve(9, self.T, parent=current)
            self._reserve(8, self.I, parent=current)
            self._reserve(7, self.F, parent=current)
            self._reserve(6, self.I, parent=current)
            self._reserve(5, self.C, parent=current)
            self._reserve(4, self.A, parent=current)
            self._reserve(3, self.T, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.O, parent=current)
            self.N(parent=current)
            return current
    IDENTIFICATION.min_size = RuleSize(1, 14)

    def DIVISION(self, parent=None):
        with UnlexerRuleContext(self, 'DIVISION', parent) as current:
            self._reserve(7, self.D, parent=current)
            self._reserve(6, self.I, parent=current)
            self._reserve(5, self.V, parent=current)
            self._reserve(4, self.I, parent=current)
            self._reserve(3, self.S, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.O, parent=current)
            self.N(parent=current)
            return current
    DIVISION.min_size = RuleSize(1, 8)

    def PROCEDURE(self, parent=None):
        with UnlexerRuleContext(self, 'PROCEDURE', parent) as current:
            self._reserve(8, self.P, parent=current)
            self._reserve(7, self.R, parent=current)
            self._reserve(6, self.O, parent=current)
            self._reserve(5, self.C, parent=current)
            self._reserve(4, self.E, parent=current)
            self._reserve(3, self.D, parent=current)
            self._reserve(2, self.U, parent=current)
            self._reserve(1, self.R, parent=current)
            self.E(parent=current)
            return current
    PROCEDURE.min_size = RuleSize(1, 9)

    def DATA(self, parent=None):
        with UnlexerRuleContext(self, 'DATA', parent) as current:
            self._reserve(3, self.D, parent=current)
            self._reserve(2, self.A, parent=current)
            self._reserve(1, self.T, parent=current)
            self.A(parent=current)
            return current
    DATA.min_size = RuleSize(1, 4)

    def PICTURE(self, parent=None):
        with UnlexerRuleContext(self, 'PICTURE', parent) as current:
            self._reserve(6, self.P, parent=current)
            self._reserve(5, self.I, parent=current)
            self._reserve(4, self.C, parent=current)
            self._reserve(3, self.T, parent=current)
            self._reserve(2, self.U, parent=current)
            self._reserve(1, self.R, parent=current)
            self.E(parent=current)
            return current
    PICTURE.min_size = RuleSize(1, 7)

    def NEXTSENTENCE(self, parent=None):
        with UnlexerRuleContext(self, 'NEXTSENTENCE', parent) as current:
            self._reserve(11, self.N, parent=current)
            self._reserve(10, self.E, parent=current)
            self._reserve(9, self.X, parent=current)
            self._reserve(8, self.T, parent=current)
            self._reserve(7, self.S, parent=current)
            self._reserve(6, self.E, parent=current)
            self._reserve(5, self.N, parent=current)
            self._reserve(4, self.T, parent=current)
            self._reserve(3, self.E, parent=current)
            self._reserve(2, self.N, parent=current)
            self._reserve(1, self.C, parent=current)
            self.E(parent=current)
            return current
    NEXTSENTENCE.min_size = RuleSize(1, 12)

    def ALTER(self, parent=None):
        with UnlexerRuleContext(self, 'ALTER', parent) as current:
            self._reserve(4, self.A, parent=current)
            self._reserve(3, self.L, parent=current)
            self._reserve(2, self.T, parent=current)
            self._reserve(1, self.E, parent=current)
            self.R(parent=current)
            return current
    ALTER.min_size = RuleSize(1, 5)

    def TOPROCEEDTO(self, parent=None):
        with UnlexerRuleContext(self, 'TOPROCEEDTO', parent) as current:
            self._reserve(10, self.T, parent=current)
            self._reserve(9, self.O, parent=current)
            self._reserve(8, self.P, parent=current)
            self._reserve(7, self.R, parent=current)
            self._reserve(6, self.O, parent=current)
            self._reserve(5, self.C, parent=current)
            self._reserve(4, self.E, parent=current)
            self._reserve(3, self.E, parent=current)
            self._reserve(2, self.D, parent=current)
            self._reserve(1, self.T, parent=current)
            self.O(parent=current)
            return current
    TOPROCEEDTO.min_size = RuleSize(1, 11)

    def IS(self, parent=None):
        with UnlexerRuleContext(self, 'IS', parent) as current:
            self._reserve(1, self.I, parent=current)
            self.S(parent=current)
            return current
    IS.min_size = RuleSize(1, 2)

    def TO(self, parent=None):
        with UnlexerRuleContext(self, 'TO', parent) as current:
            self._reserve(1, self.T, parent=current)
            self.O(parent=current)
            return current
    TO.min_size = RuleSize(1, 2)

    def NUMERICALDIGIT(self, parent=None):
        with UnlexerRuleContext(self, 'NUMERICALDIGIT', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.S(parent=current)
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(2, 2)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    with QuantifierContext(self, 1, 1, inf, RuleSize(0, 0), 0) as quant1:
                        while quant1(current):
                            current.src += self._model.charset(current, 0, self._charsets[1])
                elif choice0 == 1:
                    with QuantifierContext(self, 2, 1, inf, RuleSize(0, 0), 2) as quant2:
                        while quant2(current):
                            current.src += self._model.charset(current, 1, self._charsets[1])
                    current.src += '('
                    self.NUMERIC_LITERAL(parent=current)
                    current.src += ')'
            with QuantifierContext(self, 3, 0, 1, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.V(parent=current)
                    with AlternationContext(self, 1, (RuleSize(0, 0), RuleSize(2, 2)), 0, (1, 1)) as alt1:
                        choice1 = alt1(current)
                        if choice1 == 0:
                            with QuantifierContext(self, 4, 1, inf, RuleSize(0, 0), 0) as quant4:
                                while quant4(current):
                                    with AlternationContext(self, 2, (RuleSize(0, 0), RuleSize(1, 1)), 0, (1, 1)) as alt2:
                                        choice2 = alt2(current)
                                        if choice2 == 0:
                                            current.src += self._model.charset(current, 2, self._charsets[1])
                                        elif choice2 == 1:
                                            self.LEADINGDIGIT(parent=current)
                        elif choice1 == 1:
                            with QuantifierContext(self, 5, 1, inf, RuleSize(0, 0), 2) as quant5:
                                while quant5(current):
                                    with AlternationContext(self, 3, (RuleSize(0, 0), RuleSize(1, 1)), 0, (1, 1)) as alt3:
                                        choice3 = alt3(current)
                                        if choice3 == 0:
                                            current.src += self._model.charset(current, 3, self._charsets[1])
                                        elif choice3 == 1:
                                            self.LEADINGDIGIT(parent=current)
                            current.src += '('
                            self.NUMERIC_LITERAL(parent=current)
                            current.src += ')'
            return current
    NUMERICALDIGIT.min_size = RuleSize(0, 0)

    def SINGLECHARACTER(self, parent=None):
        with UnlexerRuleContext(self, 'SINGLECHARACTER', parent) as current:
            current.src += 'X'
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += 'X'
            return current
    SINGLECHARACTER.min_size = RuleSize(0, 0)

    def ALPHABETICALCHARACTER(self, parent=None):
        with UnlexerRuleContext(self, 'ALPHABETICALCHARACTER', parent) as current:
            current.src += 'A'
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += 'A'
            return current
    ALPHABETICALCHARACTER.min_size = RuleSize(0, 0)

    def LEADINGDIGIT(self, parent=None):
        with UnlexerRuleContext(self, 'LEADINGDIGIT', parent) as current:
            current.src += 'Z'
            return current
    LEADINGDIGIT.min_size = RuleSize(0, 0)

    def DECIMAL(self, parent=None):
        with UnlexerRuleContext(self, 'DECIMAL', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 1) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[1])
            self.V(parent=current)
            with QuantifierContext(self, 1, 1, inf, RuleSize(0, 0), 0) as quant1:
                while quant1(current):
                    current.src += self._model.charset(current, 1, self._charsets[1])
            return current
    DECIMAL.min_size = RuleSize(1, 1)

    def NUMERIC_LITERAL(self, parent=None):
        with UnlexerRuleContext(self, 'NUMERIC_LITERAL', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(0, 0), 1) as quant0:
                while quant0(current):
                    with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                        current.src += ['-', '+'][alt0(current)]
            with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.NUMBER(parent=current)
            with QuantifierContext(self, 2, 0, 1, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    with AlternationContext(self, 1, (RuleSize(0, 0), RuleSize(0, 0)), 1, (1, 1)) as alt1:
                        current.src += ['.', ','][alt1(current)]
                    with QuantifierContext(self, 3, 1, inf, RuleSize(1, 1), 0) as quant3:
                        while quant3(current):
                            self.NUMBER(parent=current)
            return current
    NUMERIC_LITERAL.min_size = RuleSize(1, 1)

    def NON_NUMERIC_LITERAL(self, parent=None):
        with UnlexerRuleContext(self, 'NON_NUMERIC_LITERAL', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['"', '\''][alt0(current)]
            with QuantifierContext(self, 0, 0, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[2])
            with AlternationContext(self, 1, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt1:
                current.src += ['"', '\''][alt1(current)]
            return current
    NON_NUMERIC_LITERAL.min_size = RuleSize(0, 0)

    def IDENTIFIER(self, parent=None):
        with UnlexerRuleContext(self, 'IDENTIFIER', parent) as current:
            self.NAME(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.NUMBER(parent=current)
            return current
    IDENTIFIER.min_size = RuleSize(1, 1)

    def NAME(self, parent=None):
        with UnlexerRuleContext(self, 'NAME', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[3])
            return current
    NAME.min_size = RuleSize(0, 0)

    def NUMBER(self, parent=None):
        with UnlexerRuleContext(self, 'NUMBER', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[4])
            return current
    NUMBER.min_size = RuleSize(0, 0)

    def COMMENT(self, parent=None):
        with UnlexerRuleContext(self, 'COMMENT', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += '\r'
            current.src += '\n'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.WS(parent=current)
            current.src += '*'
            with QuantifierContext(self, 2, 0, inf, RuleSize(0, 0), 0) as quant2:
                while quant2(current):
                    current.src += self._model.charset(current, 0, self._charsets[0])
            with QuantifierContext(self, 3, 0, 1, RuleSize(0, 0), 0) as quant3:
                while quant3(current):
                    current.src += '\r'
            current.src += '\n'
            return current
    COMMENT.min_size = RuleSize(0, 0)

    def DOT(self, parent=None):
        with UnlexerRuleContext(self, 'DOT', parent) as current:
            current.src += '.'
            return current
    DOT.min_size = RuleSize(0, 0)

    def WS(self, parent=None):
        with UnlexerRuleContext(self, 'WS', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[5])
            return current
    WS.min_size = RuleSize(0, 0)

    def program(self, parent=None):
        with UnparserRuleContext(self, 'program', parent) as current:
            self._reserve(30, self.identificationDivision, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(5, 20), 30) as quant0:
                while quant0(current):
                    self.dataDivision(parent=current)
            self._reserve(1, self.procedureDivision, parent=current)
            self.EOF(parent=current)
            return current
    program.min_size = RuleSize(7, 60)

    def identificationDivision(self, parent=None):
        with UnparserRuleContext(self, 'identificationDivision', parent) as current:
            self._reserve(15, self.IDENTIFICATION, parent=current)
            self._reserve(6, self.DIVISION, parent=current)
            self._reserve(5, self.DOT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(4, 5), 0) as quant0:
                while quant0(current):
                    self._reserve(3, self.divName, parent=current)
                    self._reserve(2, self.DOT, parent=current)
                    self._reserve(1, self.divValue, parent=current)
                    self.DOT(parent=current)
            return current
    identificationDivision.min_size = RuleSize(4, 30)

    def divName(self, parent=None):
        with UnparserRuleContext(self, 'divName', parent) as current:
            self.identifier(parent=current)
            return current
    divName.min_size = RuleSize(3, 2)

    def divValue(self, parent=None):
        with UnparserRuleContext(self, 'divValue', parent) as current:
            self.literal(parent=current)
            return current
    divValue.min_size = RuleSize(2, 1)

    def dataDivision(self, parent=None):
        with UnparserRuleContext(self, 'dataDivision', parent) as current:
            self._reserve(15, self.DATA, parent=current)
            self._reserve(6, self.DIVISION, parent=current)
            self._reserve(5, self.DOT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(4, 5), 0) as quant0:
                while quant0(current):
                    self.dataDivisionBody(parent=current)
            return current
    dataDivision.min_size = RuleSize(4, 20)

    def dataDivisionBody(self, parent=None):
        with UnparserRuleContext(self, 'dataDivisionBody', parent) as current:
            self._reserve(3, self.level, parent=current)
            self._reserve(1, self.identifier, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(3, 7), 1) as quant0:
                while quant0(current):
                    with AlternationContext(self, 0, (RuleSize(3, 12), RuleSize(4, 7)), 0, (1, 1)) as alt0:
                        [self.picture_representation, self.like_identifier][alt0(current)](parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(3, 15), 1) as quant1:
                while quant1(current):
                    self.occurs(parent=current)
            self.DOT(parent=current)
            return current
    dataDivisionBody.min_size = RuleSize(3, 5)

    def level(self, parent=None):
        with UnparserRuleContext(self, 'level', parent) as current:
            self.NUMERIC_LITERAL(parent=current)
            return current
    level.min_size = RuleSize(2, 2)

    def picture_representation(self, parent=None):
        with UnparserRuleContext(self, 'picture_representation', parent) as current:
            self._reserve(4, self.PICTURE, parent=current)
            self._reserve(1, self.IS, parent=current)
            self.representation(parent=current)
            return current
    picture_representation.min_size = RuleSize(2, 12)

    def like_identifier(self, parent=None):
        with UnparserRuleContext(self, 'like_identifier', parent) as current:
            self._reserve(2, self.LIKE, parent=current)
            self.identifier(parent=current)
            return current
    like_identifier.min_size = RuleSize(3, 7)

    def representation(self, parent=None):
        with UnparserRuleContext(self, 'representation', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(2, 2)), 0, (1, 1, 1, 1)) as alt0:
                [self.NUMERICALDIGIT, self.ALPHABETICALCHARACTER, self.SINGLECHARACTER, self.DECIMAL][alt0(current)](parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(3, 4), 0) as quant0:
                while quant0(current):
                    self.representation_shortened(parent=current)
            return current
    representation.min_size = RuleSize(1, 1)

    def representation_shortened(self, parent=None):
        with UnparserRuleContext(self, 'representation_shortened', parent) as current:
            self._reserve(3, self.T__0, parent=current)
            self._reserve(1, self.NUMERIC_LITERAL, parent=current)
            self.T__1(parent=current)
            return current
    representation_shortened.min_size = RuleSize(2, 4)

    def occurs(self, parent=None):
        with UnparserRuleContext(self, 'occurs', parent) as current:
            self._reserve(8, self.OCCURS, parent=current)
            self._reserve(6, self.NUMERIC_LITERAL, parent=current)
            self.TIMES(parent=current)
            return current
    occurs.min_size = RuleSize(2, 15)

    def procedureDivision(self, parent=None):
        with UnparserRuleContext(self, 'procedureDivision', parent) as current:
            self._reserve(19, self.PROCEDURE, parent=current)
            self._reserve(10, self.DIVISION, parent=current)
            self._reserve(9, self.DOT, parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(5, 6), 9) as quant0:
                while quant0(current):
                    self.sentence(parent=current)
            with QuantifierContext(self, 1, 1, inf, RuleSize(6, 9), 0) as quant1:
                while quant1(current):
                    self.paragraph(parent=current)
            return current
    procedureDivision.min_size = RuleSize(6, 29)

    def paragraph(self, parent=None):
        with UnparserRuleContext(self, 'paragraph', parent) as current:
            self._reserve(7, self.paragraphName, parent=current)
            self._reserve(6, self.DOT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(5, 6), 0) as quant0:
                while quant0(current):
                    self.sentence(parent=current)
            return current
    paragraph.min_size = RuleSize(5, 9)

    def paragraphName(self, parent=None):
        with UnparserRuleContext(self, 'paragraphName', parent) as current:
            self.identifier(parent=current)
            return current
    paragraphName.min_size = RuleSize(3, 2)

    def sentence(self, parent=None):
        with UnparserRuleContext(self, 'sentence', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(4, 5), 1) as quant0:
                while quant0(current):
                    self.stmt(parent=current)
            self.DOT(parent=current)
            return current
    sentence.min_size = RuleSize(4, 6)

    def stmt(self, parent=None):
        with UnparserRuleContext(self, 'stmt', parent) as current:
            with AlternationContext(self, 0, (RuleSize(4, 9), RuleSize(5, 9), RuleSize(3, 8), RuleSize(5, 14), RuleSize(5, 14), RuleSize(6, 18), RuleSize(5, 11), RuleSize(5, 14), RuleSize(5, 10), RuleSize(5, 16), RuleSize(3, 5), RuleSize(3, 9), RuleSize(3, 13), RuleSize(5, 7), RuleSize(5, 22)), 0, (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)) as alt0:
                [self.acceptStmt, self.addStmt, self.displayStmt, self.divideStmt, self.evaluateStmt, self.ifStmt, self.moveStmt, self.multiplyStmt, self.performStmt, self.subtractStmt, self.stopStmt, self.loopStmt, self.nextSentence, self.gotoStmt, self.alterStmt][alt0(current)](parent=current)
            return current
    stmt.min_size = RuleSize(3, 5)

    def nextSentence(self, parent=None):
        with UnparserRuleContext(self, 'nextSentence', parent) as current:
            self.NEXTSENTENCE(parent=current)
            return current
    nextSentence.min_size = RuleSize(2, 13)

    def acceptStmt(self, parent=None):
        with UnparserRuleContext(self, 'acceptStmt', parent) as current:
            self._reserve(2, self.ACCEPT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 2), 0) as quant0:
                while quant0(current):
                    self.identifier(parent=current)
            return current
    acceptStmt.min_size = RuleSize(3, 9)

    def addStmt(self, parent=None):
        with UnparserRuleContext(self, 'addStmt', parent) as current:
            self._reserve(4, self.add, parent=current)
            self.to(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(4, 9), 0) as quant0:
                while quant0(current):
                    self.giving(parent=current)
            return current
    addStmt.min_size = RuleSize(4, 9)

    def add(self, parent=None):
        with UnparserRuleContext(self, 'add', parent) as current:
            self._reserve(1, self.ADD, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
            return current
    add.min_size = RuleSize(3, 5)

    def to(self, parent=None):
        with UnparserRuleContext(self, 'to', parent) as current:
            self._reserve(1, self.TO, parent=current)
            self.atomic(parent=current)
            return current
    to.min_size = RuleSize(3, 4)

    def giving(self, parent=None):
        with UnparserRuleContext(self, 'giving', parent) as current:
            self._reserve(2, self.GIVING, parent=current)
            self.identifier(parent=current)
            return current
    giving.min_size = RuleSize(3, 9)

    def divideStmt(self, parent=None):
        with UnparserRuleContext(self, 'divideStmt', parent) as current:
            self._reserve(6, self.divide, parent=current)
            self.into(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(4, 9), 0) as quant0:
                while quant0(current):
                    self.giving(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(4, 12), 0) as quant1:
                while quant1(current):
                    self.remainder(parent=current)
            return current
    divideStmt.min_size = RuleSize(4, 14)

    def divide(self, parent=None):
        with UnparserRuleContext(self, 'divide', parent) as current:
            self._reserve(1, self.DIVIDE, parent=current)
            self.atomic(parent=current)
            return current
    divide.min_size = RuleSize(3, 8)

    def into(self, parent=None):
        with UnparserRuleContext(self, 'into', parent) as current:
            self._reserve(1, self.INTO, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
            return current
    into.min_size = RuleSize(3, 6)

    def remainder(self, parent=None):
        with UnparserRuleContext(self, 'remainder', parent) as current:
            self._reserve(2, self.REMAINDER, parent=current)
            self.identifier(parent=current)
            return current
    remainder.min_size = RuleSize(3, 12)

    def multiplyStmt(self, parent=None):
        with UnparserRuleContext(self, 'multiplyStmt', parent) as current:
            self._reserve(4, self.multiply, parent=current)
            self.by(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(4, 9), 0) as quant0:
                while quant0(current):
                    self.giving(parent=current)
            return current
    multiplyStmt.min_size = RuleSize(4, 14)

    def multiply(self, parent=None):
        with UnparserRuleContext(self, 'multiply', parent) as current:
            self._reserve(1, self.MULTIPLY, parent=current)
            self.atomic(parent=current)
            return current
    multiply.min_size = RuleSize(3, 10)

    def by(self, parent=None):
        with UnparserRuleContext(self, 'by', parent) as current:
            self._reserve(1, self.BY, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
            return current
    by.min_size = RuleSize(3, 4)

    def subtractStmt(self, parent=None):
        with UnparserRuleContext(self, 'subtractStmt', parent) as current:
            self._reserve(6, self.subtract, parent=current)
            self.fr(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(4, 9), 0) as quant0:
                while quant0(current):
                    self.giving(parent=current)
            return current
    subtractStmt.min_size = RuleSize(4, 16)

    def subtract(self, parent=None):
        with UnparserRuleContext(self, 'subtract', parent) as current:
            self._reserve(1, self.SUBTRACT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
            return current
    subtract.min_size = RuleSize(3, 10)

    def fr(self, parent=None):
        with UnparserRuleContext(self, 'fr', parent) as current:
            self._reserve(1, self.FROM, parent=current)
            self.atomic(parent=current)
            return current
    fr.min_size = RuleSize(3, 6)

    def moveStmt(self, parent=None):
        with UnparserRuleContext(self, 'moveStmt', parent) as current:
            self._reserve(5, self.move, parent=current)
            self.moveTo(parent=current)
            return current
    moveStmt.min_size = RuleSize(4, 11)

    def move(self, parent=None):
        with UnparserRuleContext(self, 'move', parent) as current:
            self._reserve(1, self.MOVE, parent=current)
            with AlternationContext(self, 0, (RuleSize(3, 1), RuleSize(2, 11), RuleSize(2, 10), RuleSize(2, 7)), 0, (1, 1, 1, 1)) as alt0:
                [self.atomic, self.HIGHVALUES, self.LOWVALUES, self.SPACES][alt0(current)](parent=current)
            return current
    move.min_size = RuleSize(2, 6)

    def moveTo(self, parent=None):
        with UnparserRuleContext(self, 'moveTo', parent) as current:
            self._reserve(2, self.TO, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 2), 0) as quant0:
                while quant0(current):
                    self.identifier(parent=current)
            return current
    moveTo.min_size = RuleSize(3, 5)

    def displayStmt(self, parent=None):
        with UnparserRuleContext(self, 'displayStmt', parent) as current:
            self.DISPLAY(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(4, 1), 0) as quant0:
                while quant0(current):
                    self.displayExpr(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 16), 0) as quant1:
                while quant1(current):
                    self.WITHNOADVANCING(parent=current)
            return current
    displayStmt.min_size = RuleSize(2, 8)

    def displayExpr(self, parent=None):
        with UnparserRuleContext(self, 'displayExpr', parent) as current:
            self.atomic(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 13), 0) as quant0:
                while quant0(current):
                    self._reserve(1, self.DELIMITEDBY, parent=current)
                    with AlternationContext(self, 0, (RuleSize(2, 6), RuleSize(2, 5), RuleSize(2, 1)), 0, (1, 1, 1)) as alt0:
                        [self.SPACE, self.SIZE, self.literal][alt0(current)](parent=current)
            return current
    displayExpr.min_size = RuleSize(3, 1)

    def ifStmt(self, parent=None):
        with UnparserRuleContext(self, 'ifStmt', parent) as current:
            self._reserve(15, self.IF, parent=current)
            self._reserve(10, self.booleanExpression, parent=current)
            self.ifThen(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(5, 10), 0) as quant0:
                while quant0(current):
                    self.ifElse(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 4), 0) as quant1:
                while quant1(current):
                    self.END(parent=current)
            return current
    ifStmt.min_size = RuleSize(5, 18)

    def ifThen(self, parent=None):
        with UnparserRuleContext(self, 'ifThen', parent) as current:
            self._reserve(5, self.THEN, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(4, 5), 0) as quant0:
                while quant0(current):
                    self.stmt(parent=current)
            return current
    ifThen.min_size = RuleSize(4, 10)

    def ifElse(self, parent=None):
        with UnparserRuleContext(self, 'ifElse', parent) as current:
            self._reserve(5, self.ELSE, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(4, 5), 0) as quant0:
                while quant0(current):
                    self.stmt(parent=current)
            return current
    ifElse.min_size = RuleSize(4, 10)

    def booleanExpression(self, parent=None):
        with UnparserRuleContext(self, 'booleanExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 5), RuleSize(2, 6), RuleSize(4, 5), RuleSize(3, 9), RuleSize(3, 10)), 0, (1, 1, 1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.TRUE(parent=current)
                elif choice0 == 1:
                    self.FALSE(parent=current)
                elif choice0 == 2:
                    self._reserve(3, self.arithmeticExpression, parent=current)
                    self._reserve(2, self.comparisonOp, parent=current)
                    self.arithmeticExpression(parent=current)
                elif choice0 == 3:
                    self._reserve(5, self.NOT, parent=current)
                    self.booleanExpression(parent=current)
                elif choice0 == 4:
                    self._reserve(5, self.booleanExpression, parent=current)
                    self._reserve(2, self.booleanOp, parent=current)
                    with AlternationContext(self, 1, (RuleSize(3, 5), RuleSize(4, 2)), 0, (1, 1)) as alt1:
                        [self.booleanExpression, self.contractedBoolean][alt1(current)](parent=current)
            return current
    booleanExpression.min_size = RuleSize(2, 5)

    def contractedBoolean(self, parent=None):
        with UnparserRuleContext(self, 'contractedBoolean', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 2), RuleSize(3, 3)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.arithmeticAtomic(parent=current)
                elif choice0 == 1:
                    self._reserve(2, self.comparisonOp, parent=current)
                    self.arithmeticAtomic(parent=current)
            return current
    contractedBoolean.min_size = RuleSize(3, 2)

    def arithmeticExpression(self, parent=None):
        with UnparserRuleContext(self, 'arithmeticExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 2), RuleSize(4, 5)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.arithmeticAtomic(parent=current)
                elif choice0 == 1:
                    self._reserve(3, self.arithmeticExpression, parent=current)
                    self._reserve(2, self.arithmeticOp, parent=current)
                    self.arithmeticExpression(parent=current)
            return current
    arithmeticExpression.min_size = RuleSize(3, 2)

    def arithmeticAtomic(self, parent=None):
        with UnparserRuleContext(self, 'arithmeticAtomic', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 2), RuleSize(2, 2)), 0, (1, 1)) as alt0:
                [self.identifier, self.NUMERIC_LITERAL][alt0(current)](parent=current)
            return current
    arithmeticAtomic.min_size = RuleSize(2, 2)

    def comparisonOp(self, parent=None):
        with UnparserRuleContext(self, 'comparisonOp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1, 1, 1, 1)) as alt0:
                [self.T__2, self.T__3, self.T__4, self.T__5, self.T__6][alt0(current)](parent=current)
            return current
    comparisonOp.min_size = RuleSize(1, 1)

    def arithmeticOp(self, parent=None):
        with UnparserRuleContext(self, 'arithmeticOp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1, 1, 1, 1)) as alt0:
                [self.T__7, self.T__8, self.T__9, self.T__10, self.T__11][alt0(current)](parent=current)
            return current
    arithmeticOp.min_size = RuleSize(1, 1)

    def booleanOp(self, parent=None):
        with UnparserRuleContext(self, 'booleanOp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 4), RuleSize(2, 3), RuleSize(2, 4)), 0, (1, 1, 1)) as alt0:
                [self.AND, self.OR, self.XOR][alt0(current)](parent=current)
            return current
    booleanOp.min_size = RuleSize(2, 3)

    def stringExpression(self, parent=None):
        with UnparserRuleContext(self, 'stringExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(3, 3)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.stringAtomic(parent=current)
                elif choice0 == 1:
                    self._reserve(2, self.stringExpression, parent=current)
                    self._reserve(1, self.T__7, parent=current)
                    self.stringExpression(parent=current)
            return current
    stringExpression.min_size = RuleSize(2, 1)

    def stringAtomic(self, parent=None):
        with UnparserRuleContext(self, 'stringAtomic', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 2), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                [self.identifier, self.NON_NUMERIC_LITERAL][alt0(current)](parent=current)
            return current
    stringAtomic.min_size = RuleSize(1, 1)

    def evaluateStmt(self, parent=None):
        with UnparserRuleContext(self, 'evaluateStmt', parent) as current:
            self._reserve(5, self.EVALUATE, parent=current)
            self._reserve(4, self.anyExpression, parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(6, 11), 4) as quant0:
                while quant0(current):
                    self.whenBlock(parent=current)
            self.END(parent=current)
            return current
    evaluateStmt.min_size = RuleSize(4, 14)

    def anyExpression(self, parent=None):
        with UnparserRuleContext(self, 'anyExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(4, 2), RuleSize(3, 5), RuleSize(3, 1)), 0, (1, 1, 1)) as alt0:
                [self.arithmeticExpression, self.booleanExpression, self.stringExpression][alt0(current)](parent=current)
            return current
    anyExpression.min_size = RuleSize(3, 1)

    def whenBlock(self, parent=None):
        with UnparserRuleContext(self, 'whenBlock', parent) as current:
            with AlternationContext(self, 0, (RuleSize(5, 11), RuleSize(5, 16)), 0, (1, 1)) as alt0:
                [self.whenAtomic, self.whenOther][alt0(current)](parent=current)
            return current
    whenBlock.min_size = RuleSize(5, 11)

    def whenAtomic(self, parent=None):
        with UnparserRuleContext(self, 'whenAtomic', parent) as current:
            self._reserve(6, self.WHEN, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 5) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
            with QuantifierContext(self, 1, 1, inf, RuleSize(4, 5), 0) as quant1:
                while quant1(current):
                    self.stmt(parent=current)
            return current
    whenAtomic.min_size = RuleSize(4, 11)

    def whenOther(self, parent=None):
        with UnparserRuleContext(self, 'whenOther', parent) as current:
            self._reserve(11, self.WHEN, parent=current)
            self._reserve(5, self.OTHER, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(4, 5), 0) as quant0:
                while quant0(current):
                    self.stmt(parent=current)
            return current
    whenOther.min_size = RuleSize(4, 16)

    def loopStmt(self, parent=None):
        with UnparserRuleContext(self, 'loopStmt', parent) as current:
            self._reserve(4, self.LOOP, parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(4, 5), 4) as quant0:
                while quant0(current):
                    self.loopChoice(parent=current)
            self.END(parent=current)
            return current
    loopStmt.min_size = RuleSize(2, 9)

    def loopChoice(self, parent=None):
        with UnparserRuleContext(self, 'loopChoice', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 8), RuleSize(4, 11), RuleSize(4, 11), RuleSize(4, 5)), 0, (1, 1, 1, 1)) as alt0:
                [self.varyingLoop, self.whileLoop, self.untilLoop, self.stmt][alt0(current)](parent=current)
            return current
    loopChoice.min_size = RuleSize(3, 5)

    def varyingLoop(self, parent=None):
        with UnparserRuleContext(self, 'varyingLoop', parent) as current:
            self.VARYING(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(3, 2), 0) as quant0:
                while quant0(current):
                    self.identifier(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(3, 6), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.FROM, parent=current)
                    self.atomic(parent=current)
            with QuantifierContext(self, 2, 0, 1, RuleSize(3, 4), 0) as quant2:
                while quant2(current):
                    self._reserve(1, self.TO, parent=current)
                    self.atomic(parent=current)
            with QuantifierContext(self, 3, 0, 1, RuleSize(3, 4), 0) as quant3:
                while quant3(current):
                    self._reserve(1, self.BY, parent=current)
                    self.atomic(parent=current)
            return current
    varyingLoop.min_size = RuleSize(2, 8)

    def whileLoop(self, parent=None):
        with UnparserRuleContext(self, 'whileLoop', parent) as current:
            self._reserve(5, self.WHILE, parent=current)
            self.booleanExpression(parent=current)
            return current
    whileLoop.min_size = RuleSize(3, 11)

    def untilLoop(self, parent=None):
        with UnparserRuleContext(self, 'untilLoop', parent) as current:
            self._reserve(5, self.UNTIL, parent=current)
            self.booleanExpression(parent=current)
            return current
    untilLoop.min_size = RuleSize(3, 11)

    def performStmt(self, parent=None):
        with UnparserRuleContext(self, 'performStmt', parent) as current:
            self._reserve(2, self.PERFORM, parent=current)
            self.procedureName(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(5, 10), 0) as quant0:
                while quant0(current):
                    self.through(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(4, 7), 0) as quant1:
                while quant1(current):
                    self.times(parent=current)
            return current
    performStmt.min_size = RuleSize(4, 10)

    def procedureName(self, parent=None):
        with UnparserRuleContext(self, 'procedureName', parent) as current:
            with AlternationContext(self, 0, (RuleSize(4, 2), RuleSize(4, 2), RuleSize(3, 2)), 0, (1, 1, 1)) as alt0:
                [self.sectionName, self.paragraphName, self.identifier][alt0(current)](parent=current)
            return current
    procedureName.min_size = RuleSize(3, 2)

    def sectionName(self, parent=None):
        with UnparserRuleContext(self, 'sectionName', parent) as current:
            self.identifier(parent=current)
            return current
    sectionName.min_size = RuleSize(3, 2)

    def through(self, parent=None):
        with UnparserRuleContext(self, 'through', parent) as current:
            self._reserve(2, self.THROUGH, parent=current)
            self.procedureName(parent=current)
            return current
    through.min_size = RuleSize(4, 10)

    def times(self, parent=None):
        with UnparserRuleContext(self, 'times', parent) as current:
            self._reserve(6, self.atomic, parent=current)
            self.TIMES(parent=current)
            return current
    times.min_size = RuleSize(3, 7)

    def gotoStmt(self, parent=None):
        with UnparserRuleContext(self, 'gotoStmt', parent) as current:
            self._reserve(2, self.GOTO, parent=current)
            self.procedureName(parent=current)
            return current
    gotoStmt.min_size = RuleSize(4, 7)

    def alterStmt(self, parent=None):
        with UnparserRuleContext(self, 'alterStmt', parent) as current:
            self._reserve(16, self.ALTER, parent=current)
            self._reserve(14, self.procedureName, parent=current)
            self._reserve(2, self.TOPROCEEDTO, parent=current)
            self.procedureName(parent=current)
            return current
    alterStmt.min_size = RuleSize(4, 22)

    def stopStmt(self, parent=None):
        with UnparserRuleContext(self, 'stopStmt', parent) as current:
            self.STOP(parent=current)
            return current
    stopStmt.min_size = RuleSize(2, 5)

    def atomic(self, parent=None):
        with UnparserRuleContext(self, 'atomic', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 2), RuleSize(2, 1)), 0, (1, 1)) as alt0:
                [self.identifier, self.literal][alt0(current)](parent=current)
            return current
    atomic.min_size = RuleSize(2, 1)

    def identifier(self, parent=None):
        with UnparserRuleContext(self, 'identifier', parent) as current:
            self.IDENTIFIER(parent=current)
            return current
    identifier.min_size = RuleSize(2, 2)

    def literal(self, parent=None):
        with UnparserRuleContext(self, 'literal', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 2), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                [self.NUMERIC_LITERAL, self.NON_NUMERIC_LITERAL][alt0(current)](parent=current)
            return current
    literal.min_size = RuleSize(1, 1)

    def T__0(self, parent=None):
        with UnlexerRuleContext(self, 'T__0', parent) as current:
            current.src += '('
            return current
    T__0.min_size = RuleSize(0, 0)

    def T__1(self, parent=None):
        with UnlexerRuleContext(self, 'T__1', parent) as current:
            current.src += ')'
            return current
    T__1.min_size = RuleSize(0, 0)

    def T__2(self, parent=None):
        with UnlexerRuleContext(self, 'T__2', parent) as current:
            current.src += '='
            return current
    T__2.min_size = RuleSize(0, 0)

    def T__3(self, parent=None):
        with UnlexerRuleContext(self, 'T__3', parent) as current:
            current.src += '>'
            return current
    T__3.min_size = RuleSize(0, 0)

    def T__4(self, parent=None):
        with UnlexerRuleContext(self, 'T__4', parent) as current:
            current.src += '<'
            return current
    T__4.min_size = RuleSize(0, 0)

    def T__5(self, parent=None):
        with UnlexerRuleContext(self, 'T__5', parent) as current:
            current.src += '>='
            return current
    T__5.min_size = RuleSize(0, 0)

    def T__6(self, parent=None):
        with UnlexerRuleContext(self, 'T__6', parent) as current:
            current.src += '<='
            return current
    T__6.min_size = RuleSize(0, 0)

    def T__7(self, parent=None):
        with UnlexerRuleContext(self, 'T__7', parent) as current:
            current.src += '+'
            return current
    T__7.min_size = RuleSize(0, 0)

    def T__8(self, parent=None):
        with UnlexerRuleContext(self, 'T__8', parent) as current:
            current.src += '-'
            return current
    T__8.min_size = RuleSize(0, 0)

    def T__9(self, parent=None):
        with UnlexerRuleContext(self, 'T__9', parent) as current:
            current.src += '**'
            return current
    T__9.min_size = RuleSize(0, 0)

    def T__10(self, parent=None):
        with UnlexerRuleContext(self, 'T__10', parent) as current:
            current.src += '/'
            return current
    T__10.min_size = RuleSize(0, 0)

    def T__11(self, parent=None):
        with UnlexerRuleContext(self, 'T__11', parent) as current:
            current.src += '*'
            return current
    T__11.min_size = RuleSize(0, 0)

    _default_rule = A

    _charsets = {
        0: list(itertools.chain.from_iterable([range(0x20, 0x7f)])),
        1: list(itertools.chain.from_iterable([range(0x39, 0x3a)])),
        2: list(itertools.chain.from_iterable([range(0x20, 0x22), range(0x23, 0x27), range(0x28, 0x7f)])),
        3: list(itertools.chain.from_iterable([range(0x2d, 0x2e), range(0x30, 0x3a), range(0x41, 0x5b), range(0x61, 0x7b)])),
        4: list(itertools.chain.from_iterable([range(0x30, 0x3a)])),
        5: list(itertools.chain.from_iterable([range(0x9, 0xa), range(0xa, 0xb), range(0xc, 0xd), range(0xd, 0xe), range(0x20, 0x21)])),
    }
