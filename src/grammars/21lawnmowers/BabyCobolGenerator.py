# Generated by Grammarinator 23.7.post31+g3f15e2c.d20231108

import itertools

from math import inf
from grammarinator.runtime import *

class BabyCobolGenerator(Generator):


    def EOF(self, parent=None):
        pass
    EOF.min_size = RuleSize(0, 0)

    def program(self, parent=None):
        with UnparserRuleContext(self, 'program', parent) as current:
            self._reserve(26, self.identification_division, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(3, 14), 26) as quant0:
                while quant0(current):
                    self.data_division(parent=current)
            self._reserve(1, self.procedure_division, parent=current)
            self.EOF(parent=current)
            return current
    program.min_size = RuleSize(9, 64)

    def identification_division(self, parent=None):
        with UnparserRuleContext(self, 'identification_division', parent) as current:
            self._reserve(15, self.IDENTIFICATION_DIVISION, parent=current)
            self._reserve(14, self.DOT, parent=current)
            self.identification_division_content(parent=current)
            return current
    identification_division.min_size = RuleSize(5, 38)

    def data_division(self, parent=None):
        with UnparserRuleContext(self, 'data_division', parent) as current:
            self._reserve(1, self.DATA_DIVISION, parent=current)
            self.DOT(parent=current)
            self.data_division_content(parent=current)
            return current
    data_division.min_size = RuleSize(2, 14)

    def procedure_division(self, parent=None):
        with UnparserRuleContext(self, 'procedure_division', parent) as current:
            self._reserve(7, self.PROCEDURE_DIVISION, parent=current)
            self._reserve(6, self.DOT, parent=current)
            self.procedure_division_content(parent=current)
            return current
    procedure_division.min_size = RuleSize(8, 25)

    def identification_division_content(self, parent=None):
        with UnparserRuleContext(self, 'identification_division_content', parent) as current:
            self.program_id(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(4, 11), 0) as quant0:
                while quant0(current):
                    self.author(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(4, 24), 0) as quant1:
                while quant1(current):
                    self.date_written(parent=current)
            return current
    identification_division_content.min_size = RuleSize(4, 14)

    def data_division_content(self, parent=None):
        with UnparserRuleContext(self, 'data_division_content', parent) as current:
            with QuantifierContext(self, 0, 0, inf, RuleSize(4, 5), 0) as quant0:
                while quant0(current):
                    self.data_declaration(parent=current)
            return current
    data_division_content.min_size = RuleSize(0, 0)

    def procedure_division_content(self, parent=None):
        with UnparserRuleContext(self, 'procedure_division_content', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(7, 6), 0) as quant0:
                while quant0(current):
                    self.block(parent=current)
            return current
    procedure_division_content.min_size = RuleSize(7, 6)

    def program_id(self, parent=None):
        with UnparserRuleContext(self, 'program_id', parent) as current:
            self._reserve(4, self.PROGRAM_ID, parent=current)
            self._reserve(3, self.DOT, parent=current)
            self._reserve(1, self.atomic, parent=current)
            self.DOT(parent=current)
            return current
    program_id.min_size = RuleSize(3, 14)

    def author(self, parent=None):
        with UnparserRuleContext(self, 'author', parent) as current:
            self._reserve(4, self.AUTHOR, parent=current)
            self._reserve(3, self.DOT, parent=current)
            self._reserve(1, self.atomic, parent=current)
            self.DOT(parent=current)
            return current
    author.min_size = RuleSize(3, 11)

    def date_written(self, parent=None):
        with UnparserRuleContext(self, 'date_written', parent) as current:
            self._reserve(12, self.DATE_WRITTEN, parent=current)
            self._reserve(11, self.DOT, parent=current)
            self._reserve(1, self.DATE_VALUE, parent=current)
            self.DOT(parent=current)
            return current
    date_written.min_size = RuleSize(3, 24)

    def data_declaration(self, parent=None):
        with UnparserRuleContext(self, 'data_declaration', parent) as current:
            self._reserve(3, self.NUMBER, parent=current)
            self._reserve(1, self.atomic, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(4, 7), 1) as quant0:
                while quant0(current):
                    self.data_type(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(3, 15), 1) as quant1:
                while quant1(current):
                    self.occurs(parent=current)
            self.DOT(parent=current)
            return current
    data_declaration.min_size = RuleSize(3, 5)

    def data_type(self, parent=None):
        with UnparserRuleContext(self, 'data_type', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 11), RuleSize(4, 7)), 0, (1, 1)) as alt0:
                [self.picture_type, self.like_type][alt0(current)](parent=current)
            return current
    data_type.min_size = RuleSize(3, 7)

    def picture_type(self, parent=None):
        with UnparserRuleContext(self, 'picture_type', parent) as current:
            self._reserve(1, self.PICTURE_IS, parent=current)
            self.data_rep(parent=current)
            return current
    picture_type.min_size = RuleSize(2, 11)

    def like_type(self, parent=None):
        with UnparserRuleContext(self, 'like_type', parent) as current:
            self._reserve(2, self.LIKE, parent=current)
            self.identifier(parent=current)
            return current
    like_type.min_size = RuleSize(3, 7)

    def data_rep(self, parent=None):
        with UnparserRuleContext(self, 'data_rep', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                [self.NUMBER_REP, self.STRING_REP][alt0(current)](parent=current)
            return current
    data_rep.min_size = RuleSize(1, 1)

    def occurs(self, parent=None):
        with UnparserRuleContext(self, 'occurs', parent) as current:
            self._reserve(8, self.OCCURS, parent=current)
            self._reserve(6, self.NUMBER, parent=current)
            self.TIMES(parent=current)
            return current
    occurs.min_size = RuleSize(2, 15)

    def block(self, parent=None):
        with UnparserRuleContext(self, 'block', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(3, 3), 6) as quant0:
                while quant0(current):
                    self._reserve(1, self.atomic, parent=current)
                    self.DOT(parent=current)
            with QuantifierContext(self, 1, 1, inf, RuleSize(6, 6), 0) as quant1:
                while quant1(current):
                    self.sentence(parent=current)
            return current
    block.min_size = RuleSize(6, 6)

    def sentence(self, parent=None):
        with UnparserRuleContext(self, 'sentence', parent) as current:
            self._reserve(1, self.sentence_content, parent=current)
            self.DOT(parent=current)
            return current
    sentence.min_size = RuleSize(5, 6)

    def sentence_content(self, parent=None):
        with UnparserRuleContext(self, 'sentence_content', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(4, 5), 0) as quant0:
                while quant0(current):
                    self.statement(parent=current)
            return current
    sentence_content.min_size = RuleSize(4, 5)

    def statement(self, parent=None):
        with UnparserRuleContext(self, 'statement', parent) as current:
            with AlternationContext(self, 0, (RuleSize(4, 9), RuleSize(4, 11), RuleSize(3, 8), RuleSize(4, 16), RuleSize(5, 15), RuleSize(4, 7), RuleSize(7, 18), RuleSize(3, 9), RuleSize(4, 12), RuleSize(4, 16), RuleSize(3, 13), RuleSize(4, 10), RuleSize(3, 5), RuleSize(4, 18)), 0, (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)) as alt0:
                [self.accept_statement, self.add_statement, self.display_statement, self.divide_statement, self.evaluate_statement, self.goto_statement, self.if_statement, self.loop_statement, self.move_statement, self.multiply_statement, self.next_sentence_statement, self.perform_statement, self.stop_statement, self.subtract_statement][alt0(current)](parent=current)
            return current
    statement.min_size = RuleSize(3, 5)

    def accept_statement(self, parent=None):
        with UnparserRuleContext(self, 'accept_statement', parent) as current:
            self._reserve(2, self.ACCEPT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 2), 0) as quant0:
                while quant0(current):
                    self.identifier(parent=current)
            return current
    accept_statement.min_size = RuleSize(3, 9)

    def add_statement(self, parent=None):
        with UnparserRuleContext(self, 'add_statement', parent) as current:
            self._reserve(7, self.ADD, parent=current)
            self._reserve(5, self.atomic, parent=current)
            self._reserve(2, self.TO, parent=current)
            self.atomic(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(4, 9), 0) as quant0:
                while quant0(current):
                    self.giving(parent=current)
            return current
    add_statement.min_size = RuleSize(3, 11)

    def display_statement(self, parent=None):
        with UnparserRuleContext(self, 'display_statement', parent) as current:
            self.DISPLAY(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(4, 2), 0) as quant0:
                while quant0(current):
                    self.display_expression(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 16), 0) as quant1:
                while quant1(current):
                    self.WITH_NO_ADVANCING(parent=current)
            return current
    display_statement.min_size = RuleSize(2, 8)

    def display_expression(self, parent=None):
        with UnparserRuleContext(self, 'display_expression', parent) as current:
            self.atomic(parent=current)
            return current
    display_expression.min_size = RuleSize(3, 2)

    def divide_statement(self, parent=None):
        with UnparserRuleContext(self, 'divide_statement', parent) as current:
            self._reserve(9, self.DIVIDE, parent=current)
            self._reserve(7, self.atomic, parent=current)
            self._reserve(2, self.INTO, parent=current)
            self.atomic(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(4, 9), 0) as quant0:
                while quant0(current):
                    self.giving(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(4, 12), 0) as quant1:
                while quant1(current):
                    self.divide_remainder(parent=current)
            return current
    divide_statement.min_size = RuleSize(3, 16)

    def divide_remainder(self, parent=None):
        with UnparserRuleContext(self, 'divide_remainder', parent) as current:
            self._reserve(2, self.REMAINDER, parent=current)
            self.identifier(parent=current)
            return current
    divide_remainder.min_size = RuleSize(3, 12)

    def evaluate_statement(self, parent=None):
        with UnparserRuleContext(self, 'evaluate_statement', parent) as current:
            self._reserve(6, self.EVALUATE, parent=current)
            self._reserve(4, self.any_expression, parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(6, 12), 4) as quant0:
                while quant0(current):
                    self.when_block(parent=current)
            self.END(parent=current)
            return current
    evaluate_statement.min_size = RuleSize(4, 15)

    def when_block(self, parent=None):
        with UnparserRuleContext(self, 'when_block', parent) as current:
            self._reserve(7, self.WHEN, parent=current)
            with AlternationContext(self, 0, (RuleSize(3, 2), RuleSize(2, 6)), 5, (1, 1)) as alt0:
                [self.atomic, self.OTHER][alt0(current)](parent=current)
            self.sentence_content(parent=current)
            return current
    when_block.min_size = RuleSize(5, 12)

    def goto_statement(self, parent=None):
        with UnparserRuleContext(self, 'goto_statement', parent) as current:
            self._reserve(2, self.GO_TO, parent=current)
            self.atomic(parent=current)
            return current
    goto_statement.min_size = RuleSize(3, 7)

    def if_statement(self, parent=None):
        with UnparserRuleContext(self, 'if_statement', parent) as current:
            self._reserve(15, self.IF, parent=current)
            self._reserve(10, self.boolean_expression, parent=current)
            self._reserve(5, self.THEN, parent=current)
            self.then_block(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(6, 10), 0) as quant0:
                while quant0(current):
                    self._reserve(5, self.ELSE, parent=current)
                    self.else_block(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 4), 0) as quant1:
                while quant1(current):
                    self.END(parent=current)
            return current
    if_statement.min_size = RuleSize(6, 18)

    def then_block(self, parent=None):
        with UnparserRuleContext(self, 'then_block', parent) as current:
            self.sentence_content(parent=current)
            return current
    then_block.min_size = RuleSize(5, 5)

    def else_block(self, parent=None):
        with UnparserRuleContext(self, 'else_block', parent) as current:
            self.sentence_content(parent=current)
            return current
    else_block.min_size = RuleSize(5, 5)

    def loop_statement(self, parent=None):
        with UnparserRuleContext(self, 'loop_statement', parent) as current:
            self._reserve(4, self.LOOP, parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(4, 5), 4) as quant0:
                while quant0(current):
                    self.inner_loop_statement(parent=current)
            self.END(parent=current)
            return current
    loop_statement.min_size = RuleSize(2, 9)

    def inner_loop_statement(self, parent=None):
        with UnparserRuleContext(self, 'inner_loop_statement', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 8), RuleSize(4, 11), RuleSize(4, 11), RuleSize(4, 5)), 0, (1, 1, 1, 1)) as alt0:
                [self.varying_statement, self.while_statement, self.until_statement, self.statement][alt0(current)](parent=current)
            return current
    inner_loop_statement.min_size = RuleSize(3, 5)

    def varying_statement(self, parent=None):
        with UnparserRuleContext(self, 'varying_statement', parent) as current:
            self.VARYING(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(4, 2), 0) as quant0:
                while quant0(current):
                    self.varying_variant(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(4, 7), 0) as quant1:
                while quant1(current):
                    self.varying_from(parent=current)
            with QuantifierContext(self, 2, 0, 1, RuleSize(4, 5), 0) as quant2:
                while quant2(current):
                    self.varying_to(parent=current)
            with QuantifierContext(self, 3, 0, 1, RuleSize(4, 5), 0) as quant3:
                while quant3(current):
                    self.varying_by(parent=current)
            return current
    varying_statement.min_size = RuleSize(2, 8)

    def varying_variant(self, parent=None):
        with UnparserRuleContext(self, 'varying_variant', parent) as current:
            self.identifier(parent=current)
            return current
    varying_variant.min_size = RuleSize(3, 2)

    def varying_from(self, parent=None):
        with UnparserRuleContext(self, 'varying_from', parent) as current:
            self._reserve(2, self.FROM, parent=current)
            self.atomic(parent=current)
            return current
    varying_from.min_size = RuleSize(3, 7)

    def varying_to(self, parent=None):
        with UnparserRuleContext(self, 'varying_to', parent) as current:
            self._reserve(2, self.TO, parent=current)
            self.atomic(parent=current)
            return current
    varying_to.min_size = RuleSize(3, 5)

    def varying_by(self, parent=None):
        with UnparserRuleContext(self, 'varying_by', parent) as current:
            self._reserve(2, self.BY, parent=current)
            self.atomic(parent=current)
            return current
    varying_by.min_size = RuleSize(3, 5)

    def while_statement(self, parent=None):
        with UnparserRuleContext(self, 'while_statement', parent) as current:
            self._reserve(5, self.WHILE, parent=current)
            self.boolean_expression(parent=current)
            return current
    while_statement.min_size = RuleSize(3, 11)

    def until_statement(self, parent=None):
        with UnparserRuleContext(self, 'until_statement', parent) as current:
            self._reserve(5, self.UNTIL, parent=current)
            self.boolean_expression(parent=current)
            return current
    until_statement.min_size = RuleSize(3, 11)

    def move_statement(self, parent=None):
        with UnparserRuleContext(self, 'move_statement', parent) as current:
            self._reserve(7, self.MOVE, parent=current)
            with AlternationContext(self, 0, (RuleSize(3, 2), RuleSize(2, 7), RuleSize(2, 11), RuleSize(2, 10)), 5, (1, 1, 1, 1)) as alt0:
                [self.atomic, self.SPACES, self.HIGH_VALUES, self.LOW_VALUES][alt0(current)](parent=current)
            self._reserve(2, self.TO, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 2), 0) as quant0:
                while quant0(current):
                    self.identifier(parent=current)
            return current
    move_statement.min_size = RuleSize(3, 12)

    def multiply_statement(self, parent=None):
        with UnparserRuleContext(self, 'multiply_statement', parent) as current:
            self._reserve(7, self.MULTIPLY, parent=current)
            self._reserve(5, self.atomic, parent=current)
            self._reserve(2, self.BY, parent=current)
            self.atomic(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(4, 9), 0) as quant0:
                while quant0(current):
                    self.giving(parent=current)
            return current
    multiply_statement.min_size = RuleSize(3, 16)

    def next_sentence_statement(self, parent=None):
        with UnparserRuleContext(self, 'next_sentence_statement', parent) as current:
            self.NEXT_SENTENCE(parent=current)
            return current
    next_sentence_statement.min_size = RuleSize(2, 13)

    def perform_statement(self, parent=None):
        with UnparserRuleContext(self, 'perform_statement', parent) as current:
            self._reserve(2, self.PERFORM, parent=current)
            self.atomic(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(4, 10), 0) as quant0:
                while quant0(current):
                    self.perform_through(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 8), 0) as quant1:
                while quant1(current):
                    self._reserve(6, self.NUMBER, parent=current)
                    self.TIMES(parent=current)
            return current
    perform_statement.min_size = RuleSize(3, 10)

    def perform_through(self, parent=None):
        with UnparserRuleContext(self, 'perform_through', parent) as current:
            self._reserve(2, self.THROUGH, parent=current)
            self.atomic(parent=current)
            return current
    perform_through.min_size = RuleSize(3, 10)

    def stop_statement(self, parent=None):
        with UnparserRuleContext(self, 'stop_statement', parent) as current:
            self.STOP(parent=current)
            return current
    stop_statement.min_size = RuleSize(2, 5)

    def subtract_statement(self, parent=None):
        with UnparserRuleContext(self, 'subtract_statement', parent) as current:
            self._reserve(9, self.SUBTRACT, parent=current)
            self._reserve(7, self.atomic, parent=current)
            self._reserve(2, self.FROM, parent=current)
            self.atomic(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(4, 9), 0) as quant0:
                while quant0(current):
                    self.giving(parent=current)
            return current
    subtract_statement.min_size = RuleSize(3, 18)

    def giving(self, parent=None):
        with UnparserRuleContext(self, 'giving', parent) as current:
            self._reserve(2, self.GIVING, parent=current)
            self.identifier(parent=current)
            return current
    giving.min_size = RuleSize(3, 9)

    def any_expression(self, parent=None):
        with UnparserRuleContext(self, 'any_expression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(4, 2), RuleSize(3, 5), RuleSize(4, 2)), 0, (1, 1, 1)) as alt0:
                [self.arithmetic_expression, self.boolean_expression, self.string_expression][alt0(current)](parent=current)
            return current
    any_expression.min_size = RuleSize(3, 2)

    def arithmetic_expression(self, parent=None):
        with UnparserRuleContext(self, 'arithmetic_expression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 2), RuleSize(4, 6)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.atomic(parent=current)
                elif choice0 == 1:
                    self._reserve(4, self.arithmetic_expression, parent=current)
                    self._reserve(2, self.ARITHMETIC_OPERATOR, parent=current)
                    self.arithmetic_expression(parent=current)
            return current
    arithmetic_expression.min_size = RuleSize(3, 2)

    def boolean_expression(self, parent=None):
        with UnparserRuleContext(self, 'boolean_expression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 5), RuleSize(2, 6), RuleSize(4, 6), RuleSize(3, 9), RuleSize(3, 14), RuleSize(4, 6)), 0, (1, 1, 1, 1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.TRUE(parent=current)
                elif choice0 == 1:
                    self.FALSE(parent=current)
                elif choice0 == 2:
                    self._reserve(4, self.arithmetic_expression, parent=current)
                    self._reserve(2, self.COMPARISON_OPERATOR, parent=current)
                    self.arithmetic_expression(parent=current)
                elif choice0 == 3:
                    self._reserve(5, self.NOT, parent=current)
                    self.boolean_expression(parent=current)
                elif choice0 == 4:
                    self._reserve(9, self.boolean_expression, parent=current)
                    self._reserve(5, self.BOOLEAN_OPERATOR, parent=current)
                    self.boolean_expression(parent=current)
                elif choice0 == 5:
                    self.contracted_expression(parent=current)
            return current
    boolean_expression.min_size = RuleSize(2, 5)

    def string_expression(self, parent=None):
        with UnparserRuleContext(self, 'string_expression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 2), RuleSize(4, 6)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.atomic(parent=current)
                elif choice0 == 1:
                    self._reserve(4, self.string_expression, parent=current)
                    self._reserve(2, self.ARITHMETIC_OPERATOR, parent=current)
                    self.string_expression(parent=current)
            return current
    string_expression.min_size = RuleSize(3, 2)

    def contracted_expression(self, parent=None):
        with UnparserRuleContext(self, 'contracted_expression', parent) as current:
            self._reserve(4, self.atomic, parent=current)
            self._reserve(2, self.COMPARISON_OPERATOR, parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(4, 6), 2) as quant0:
                while quant0(current):
                    self.contracted_expression_part(parent=current)
            self.atomic(parent=current)
            return current
    contracted_expression.min_size = RuleSize(3, 6)

    def contracted_expression_part(self, parent=None):
        with UnparserRuleContext(self, 'contracted_expression_part', parent) as current:
            self._reserve(4, self.atomic, parent=current)
            self.BOOLEAN_OPERATOR(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 2), 0) as quant0:
                while quant0(current):
                    self.COMPARISON_OPERATOR(parent=current)
            return current
    contracted_expression_part.min_size = RuleSize(3, 6)

    def atomic(self, parent=None):
        with UnparserRuleContext(self, 'atomic', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 2), RuleSize(2, 2), RuleSize(3, 2)), 0, (1, 1, 1)) as alt0:
                [self.NUMBER, self.ATOMIC, self.identifier][alt0(current)](parent=current)
            return current
    atomic.min_size = RuleSize(2, 2)

    def identifier(self, parent=None):
        with UnparserRuleContext(self, 'identifier', parent) as current:
            self.ATOMIC(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(2, 5), 0) as quant0:
                while quant0(current):
                    self._reserve(2, self.OF, parent=current)
                    self.ATOMIC(parent=current)
            return current
    identifier.min_size = RuleSize(2, 2)

    def ACCEPT(self, parent=None):
        with UnlexerRuleContext(self, 'ACCEPT', parent) as current:
            self._reserve(5, self.A, parent=current)
            self._reserve(4, self.C, parent=current)
            self._reserve(3, self.C, parent=current)
            self._reserve(2, self.E, parent=current)
            self._reserve(1, self.P, parent=current)
            self.T(parent=current)
            return current
    ACCEPT.min_size = RuleSize(1, 6)

    def ADD(self, parent=None):
        with UnlexerRuleContext(self, 'ADD', parent) as current:
            self._reserve(2, self.A, parent=current)
            self._reserve(1, self.D, parent=current)
            self.D(parent=current)
            return current
    ADD.min_size = RuleSize(1, 3)

    def DISPLAY(self, parent=None):
        with UnlexerRuleContext(self, 'DISPLAY', parent) as current:
            self._reserve(6, self.D, parent=current)
            self._reserve(5, self.I, parent=current)
            self._reserve(4, self.S, parent=current)
            self._reserve(3, self.P, parent=current)
            self._reserve(2, self.L, parent=current)
            self._reserve(1, self.A, parent=current)
            self.Y(parent=current)
            return current
    DISPLAY.min_size = RuleSize(1, 7)

    def DIVIDE(self, parent=None):
        with UnlexerRuleContext(self, 'DIVIDE', parent) as current:
            self._reserve(5, self.D, parent=current)
            self._reserve(4, self.I, parent=current)
            self._reserve(3, self.V, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.D, parent=current)
            self.E(parent=current)
            return current
    DIVIDE.min_size = RuleSize(1, 6)

    def EVALUATE(self, parent=None):
        with UnlexerRuleContext(self, 'EVALUATE', parent) as current:
            self._reserve(7, self.E, parent=current)
            self._reserve(6, self.V, parent=current)
            self._reserve(5, self.A, parent=current)
            self._reserve(4, self.L, parent=current)
            self._reserve(3, self.U, parent=current)
            self._reserve(2, self.A, parent=current)
            self._reserve(1, self.T, parent=current)
            self.E(parent=current)
            return current
    EVALUATE.min_size = RuleSize(1, 8)

    def GO_TO(self, parent=None):
        with UnlexerRuleContext(self, 'GO_TO', parent) as current:
            self._reserve(3, self.G, parent=current)
            self._reserve(2, self.O, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(0, 0), 2) as quant0:
                while quant0(current):
                    current.src += ' '
            self._reserve(1, self.T, parent=current)
            self.O(parent=current)
            return current
    GO_TO.min_size = RuleSize(1, 4)

    def IF(self, parent=None):
        with UnlexerRuleContext(self, 'IF', parent) as current:
            self._reserve(1, self.I, parent=current)
            self.F(parent=current)
            return current
    IF.min_size = RuleSize(1, 2)

    def LOOP(self, parent=None):
        with UnlexerRuleContext(self, 'LOOP', parent) as current:
            self._reserve(3, self.L, parent=current)
            self._reserve(2, self.O, parent=current)
            self._reserve(1, self.O, parent=current)
            self.P(parent=current)
            return current
    LOOP.min_size = RuleSize(1, 4)

    def MOVE(self, parent=None):
        with UnlexerRuleContext(self, 'MOVE', parent) as current:
            self._reserve(3, self.M, parent=current)
            self._reserve(2, self.O, parent=current)
            self._reserve(1, self.V, parent=current)
            self.E(parent=current)
            return current
    MOVE.min_size = RuleSize(1, 4)

    def MULTIPLY(self, parent=None):
        with UnlexerRuleContext(self, 'MULTIPLY', parent) as current:
            self._reserve(7, self.M, parent=current)
            self._reserve(6, self.U, parent=current)
            self._reserve(5, self.L, parent=current)
            self._reserve(4, self.T, parent=current)
            self._reserve(3, self.I, parent=current)
            self._reserve(2, self.P, parent=current)
            self._reserve(1, self.L, parent=current)
            self.Y(parent=current)
            return current
    MULTIPLY.min_size = RuleSize(1, 8)

    def NEXT_SENTENCE(self, parent=None):
        with UnlexerRuleContext(self, 'NEXT_SENTENCE', parent) as current:
            self._reserve(11, self.N, parent=current)
            self._reserve(10, self.E, parent=current)
            self._reserve(9, self.X, parent=current)
            self._reserve(8, self.T, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(0, 0), 8) as quant0:
                while quant0(current):
                    current.src += ' '
            self._reserve(7, self.S, parent=current)
            self._reserve(6, self.E, parent=current)
            self._reserve(5, self.N, parent=current)
            self._reserve(4, self.T, parent=current)
            self._reserve(3, self.E, parent=current)
            self._reserve(2, self.N, parent=current)
            self._reserve(1, self.C, parent=current)
            self.E(parent=current)
            return current
    NEXT_SENTENCE.min_size = RuleSize(1, 12)

    def STOP(self, parent=None):
        with UnlexerRuleContext(self, 'STOP', parent) as current:
            self._reserve(3, self.S, parent=current)
            self._reserve(2, self.T, parent=current)
            self._reserve(1, self.O, parent=current)
            self.P(parent=current)
            return current
    STOP.min_size = RuleSize(1, 4)

    def SUBTRACT(self, parent=None):
        with UnlexerRuleContext(self, 'SUBTRACT', parent) as current:
            self._reserve(7, self.S, parent=current)
            self._reserve(6, self.U, parent=current)
            self._reserve(5, self.B, parent=current)
            self._reserve(4, self.T, parent=current)
            self._reserve(3, self.R, parent=current)
            self._reserve(2, self.A, parent=current)
            self._reserve(1, self.C, parent=current)
            self.T(parent=current)
            return current
    SUBTRACT.min_size = RuleSize(1, 8)

    def IDENTIFICATION_DIVISION(self, parent=None):
        with UnlexerRuleContext(self, 'IDENTIFICATION_DIVISION', parent) as current:
            self._reserve(21, self.I, parent=current)
            self._reserve(20, self.D, parent=current)
            self._reserve(19, self.E, parent=current)
            self._reserve(18, self.N, parent=current)
            self._reserve(17, self.T, parent=current)
            self._reserve(16, self.I, parent=current)
            self._reserve(15, self.F, parent=current)
            self._reserve(14, self.I, parent=current)
            self._reserve(13, self.C, parent=current)
            self._reserve(12, self.A, parent=current)
            self._reserve(11, self.T, parent=current)
            self._reserve(10, self.I, parent=current)
            self._reserve(9, self.O, parent=current)
            self._reserve(8, self.N, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(0, 0), 8) as quant0:
                while quant0(current):
                    current.src += ' '
            self._reserve(7, self.D, parent=current)
            self._reserve(6, self.I, parent=current)
            self._reserve(5, self.V, parent=current)
            self._reserve(4, self.I, parent=current)
            self._reserve(3, self.S, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.O, parent=current)
            self.N(parent=current)
            return current
    IDENTIFICATION_DIVISION.min_size = RuleSize(1, 22)

    def PROGRAM_ID(self, parent=None):
        with UnlexerRuleContext(self, 'PROGRAM_ID', parent) as current:
            self._reserve(8, self.P, parent=current)
            self._reserve(7, self.R, parent=current)
            self._reserve(6, self.O, parent=current)
            self._reserve(5, self.G, parent=current)
            self._reserve(4, self.R, parent=current)
            self._reserve(3, self.A, parent=current)
            self._reserve(2, self.M, parent=current)
            current.src += '-'
            self._reserve(1, self.I, parent=current)
            self.D(parent=current)
            return current
    PROGRAM_ID.min_size = RuleSize(1, 9)

    def AUTHOR(self, parent=None):
        with UnlexerRuleContext(self, 'AUTHOR', parent) as current:
            self._reserve(5, self.A, parent=current)
            self._reserve(4, self.U, parent=current)
            self._reserve(3, self.T, parent=current)
            self._reserve(2, self.H, parent=current)
            self._reserve(1, self.O, parent=current)
            self.R(parent=current)
            return current
    AUTHOR.min_size = RuleSize(1, 6)

    def DATE_WRITTEN(self, parent=None):
        with UnlexerRuleContext(self, 'DATE_WRITTEN', parent) as current:
            self._reserve(10, self.D, parent=current)
            self._reserve(9, self.A, parent=current)
            self._reserve(8, self.T, parent=current)
            self._reserve(7, self.E, parent=current)
            current.src += '-'
            self._reserve(6, self.W, parent=current)
            self._reserve(5, self.R, parent=current)
            self._reserve(4, self.I, parent=current)
            self._reserve(3, self.T, parent=current)
            self._reserve(2, self.T, parent=current)
            self._reserve(1, self.E, parent=current)
            self.N(parent=current)
            return current
    DATE_WRITTEN.min_size = RuleSize(1, 11)

    def DATA_DIVISION(self, parent=None):
        with UnlexerRuleContext(self, 'DATA_DIVISION', parent) as current:
            self._reserve(11, self.D, parent=current)
            self._reserve(10, self.A, parent=current)
            self._reserve(9, self.T, parent=current)
            self._reserve(8, self.A, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(0, 0), 8) as quant0:
                while quant0(current):
                    current.src += ' '
            self._reserve(7, self.D, parent=current)
            self._reserve(6, self.I, parent=current)
            self._reserve(5, self.V, parent=current)
            self._reserve(4, self.I, parent=current)
            self._reserve(3, self.S, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.O, parent=current)
            self.N(parent=current)
            return current
    DATA_DIVISION.min_size = RuleSize(1, 12)

    def PROCEDURE_DIVISION(self, parent=None):
        with UnlexerRuleContext(self, 'PROCEDURE_DIVISION', parent) as current:
            self._reserve(16, self.P, parent=current)
            self._reserve(15, self.R, parent=current)
            self._reserve(14, self.O, parent=current)
            self._reserve(13, self.C, parent=current)
            self._reserve(12, self.E, parent=current)
            self._reserve(11, self.D, parent=current)
            self._reserve(10, self.U, parent=current)
            self._reserve(9, self.R, parent=current)
            self._reserve(8, self.E, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(0, 0), 8) as quant0:
                while quant0(current):
                    current.src += ' '
            self._reserve(7, self.D, parent=current)
            self._reserve(6, self.I, parent=current)
            self._reserve(5, self.V, parent=current)
            self._reserve(4, self.I, parent=current)
            self._reserve(3, self.S, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.O, parent=current)
            self.N(parent=current)
            return current
    PROCEDURE_DIVISION.min_size = RuleSize(1, 17)

    def TO(self, parent=None):
        with UnlexerRuleContext(self, 'TO', parent) as current:
            self._reserve(1, self.T, parent=current)
            self.O(parent=current)
            return current
    TO.min_size = RuleSize(1, 2)

    def FROM(self, parent=None):
        with UnlexerRuleContext(self, 'FROM', parent) as current:
            self._reserve(3, self.F, parent=current)
            self._reserve(2, self.R, parent=current)
            self._reserve(1, self.O, parent=current)
            self.M(parent=current)
            return current
    FROM.min_size = RuleSize(1, 4)

    def BY(self, parent=None):
        with UnlexerRuleContext(self, 'BY', parent) as current:
            self._reserve(1, self.B, parent=current)
            self.Y(parent=current)
            return current
    BY.min_size = RuleSize(1, 2)

    def INTO(self, parent=None):
        with UnlexerRuleContext(self, 'INTO', parent) as current:
            self._reserve(3, self.I, parent=current)
            self._reserve(2, self.N, parent=current)
            self._reserve(1, self.T, parent=current)
            self.O(parent=current)
            return current
    INTO.min_size = RuleSize(1, 4)

    def GIVING(self, parent=None):
        with UnlexerRuleContext(self, 'GIVING', parent) as current:
            self._reserve(5, self.G, parent=current)
            self._reserve(4, self.I, parent=current)
            self._reserve(3, self.V, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.N, parent=current)
            self.G(parent=current)
            return current
    GIVING.min_size = RuleSize(1, 6)

    def REMAINDER(self, parent=None):
        with UnlexerRuleContext(self, 'REMAINDER', parent) as current:
            self._reserve(8, self.R, parent=current)
            self._reserve(7, self.E, parent=current)
            self._reserve(6, self.M, parent=current)
            self._reserve(5, self.A, parent=current)
            self._reserve(4, self.I, parent=current)
            self._reserve(3, self.N, parent=current)
            self._reserve(2, self.D, parent=current)
            self._reserve(1, self.E, parent=current)
            self.R(parent=current)
            return current
    REMAINDER.min_size = RuleSize(1, 9)

    def SPACES(self, parent=None):
        with UnlexerRuleContext(self, 'SPACES', parent) as current:
            self._reserve(5, self.S, parent=current)
            self._reserve(4, self.P, parent=current)
            self._reserve(3, self.A, parent=current)
            self._reserve(2, self.C, parent=current)
            self._reserve(1, self.E, parent=current)
            self.S(parent=current)
            return current
    SPACES.min_size = RuleSize(1, 6)

    def HIGH_VALUES(self, parent=None):
        with UnlexerRuleContext(self, 'HIGH_VALUES', parent) as current:
            self._reserve(9, self.H, parent=current)
            self._reserve(8, self.I, parent=current)
            self._reserve(7, self.G, parent=current)
            self._reserve(6, self.H, parent=current)
            current.src += '-'
            self._reserve(5, self.V, parent=current)
            self._reserve(4, self.A, parent=current)
            self._reserve(3, self.L, parent=current)
            self._reserve(2, self.U, parent=current)
            self._reserve(1, self.E, parent=current)
            self.S(parent=current)
            return current
    HIGH_VALUES.min_size = RuleSize(1, 10)

    def LOW_VALUES(self, parent=None):
        with UnlexerRuleContext(self, 'LOW_VALUES', parent) as current:
            self._reserve(8, self.L, parent=current)
            self._reserve(7, self.O, parent=current)
            self._reserve(6, self.W, parent=current)
            current.src += '-'
            self._reserve(5, self.V, parent=current)
            self._reserve(4, self.A, parent=current)
            self._reserve(3, self.L, parent=current)
            self._reserve(2, self.U, parent=current)
            self._reserve(1, self.E, parent=current)
            self.S(parent=current)
            return current
    LOW_VALUES.min_size = RuleSize(1, 9)

    def TRUE(self, parent=None):
        with UnlexerRuleContext(self, 'TRUE', parent) as current:
            self._reserve(3, self.T, parent=current)
            self._reserve(2, self.R, parent=current)
            self._reserve(1, self.U, parent=current)
            self.E(parent=current)
            return current
    TRUE.min_size = RuleSize(1, 4)

    def FALSE(self, parent=None):
        with UnlexerRuleContext(self, 'FALSE', parent) as current:
            self._reserve(4, self.F, parent=current)
            self._reserve(3, self.A, parent=current)
            self._reserve(2, self.L, parent=current)
            self._reserve(1, self.S, parent=current)
            self.E(parent=current)
            return current
    FALSE.min_size = RuleSize(1, 5)

    def NOT(self, parent=None):
        with UnlexerRuleContext(self, 'NOT', parent) as current:
            self._reserve(2, self.N, parent=current)
            self._reserve(1, self.O, parent=current)
            self.T(parent=current)
            return current
    NOT.min_size = RuleSize(1, 3)

    def ARITHMETIC_OPERATOR(self, parent=None):
        with UnlexerRuleContext(self, 'ARITHMETIC_OPERATOR', parent) as current:
            self.ArithmeticOp(parent=current)
            return current
    ARITHMETIC_OPERATOR.min_size = RuleSize(1, 1)

    def COMPARISON_OPERATOR(self, parent=None):
        with UnlexerRuleContext(self, 'COMPARISON_OPERATOR', parent) as current:
            self.ComparisonOp(parent=current)
            return current
    COMPARISON_OPERATOR.min_size = RuleSize(1, 1)

    def BOOLEAN_OPERATOR(self, parent=None):
        with UnlexerRuleContext(self, 'BOOLEAN_OPERATOR', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 3), RuleSize(2, 4), RuleSize(2, 4)), 0, (1, 1, 1)) as alt0:
                [self.Or, self.And, self.Xor][alt0(current)](parent=current)
            return current
    BOOLEAN_OPERATOR.min_size = RuleSize(2, 3)

    def WHEN(self, parent=None):
        with UnlexerRuleContext(self, 'WHEN', parent) as current:
            self._reserve(3, self.W, parent=current)
            self._reserve(2, self.H, parent=current)
            self._reserve(1, self.E, parent=current)
            self.N(parent=current)
            return current
    WHEN.min_size = RuleSize(1, 4)

    def OTHER(self, parent=None):
        with UnlexerRuleContext(self, 'OTHER', parent) as current:
            self._reserve(4, self.O, parent=current)
            self._reserve(3, self.T, parent=current)
            self._reserve(2, self.H, parent=current)
            self._reserve(1, self.E, parent=current)
            self.R(parent=current)
            return current
    OTHER.min_size = RuleSize(1, 5)

    def END(self, parent=None):
        with UnlexerRuleContext(self, 'END', parent) as current:
            self._reserve(2, self.E, parent=current)
            self._reserve(1, self.N, parent=current)
            self.D(parent=current)
            return current
    END.min_size = RuleSize(1, 3)

    def THEN(self, parent=None):
        with UnlexerRuleContext(self, 'THEN', parent) as current:
            self._reserve(3, self.T, parent=current)
            self._reserve(2, self.H, parent=current)
            self._reserve(1, self.E, parent=current)
            self.N(parent=current)
            return current
    THEN.min_size = RuleSize(1, 4)

    def ELSE(self, parent=None):
        with UnlexerRuleContext(self, 'ELSE', parent) as current:
            self._reserve(3, self.E, parent=current)
            self._reserve(2, self.L, parent=current)
            self._reserve(1, self.S, parent=current)
            self.E(parent=current)
            return current
    ELSE.min_size = RuleSize(1, 4)

    def VARYING(self, parent=None):
        with UnlexerRuleContext(self, 'VARYING', parent) as current:
            self._reserve(6, self.V, parent=current)
            self._reserve(5, self.A, parent=current)
            self._reserve(4, self.R, parent=current)
            self._reserve(3, self.Y, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.N, parent=current)
            self.G(parent=current)
            return current
    VARYING.min_size = RuleSize(1, 7)

    def WHILE(self, parent=None):
        with UnlexerRuleContext(self, 'WHILE', parent) as current:
            self._reserve(4, self.W, parent=current)
            self._reserve(3, self.H, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.L, parent=current)
            self.E(parent=current)
            return current
    WHILE.min_size = RuleSize(1, 5)

    def UNTIL(self, parent=None):
        with UnlexerRuleContext(self, 'UNTIL', parent) as current:
            self._reserve(4, self.U, parent=current)
            self._reserve(3, self.N, parent=current)
            self._reserve(2, self.T, parent=current)
            self._reserve(1, self.I, parent=current)
            self.L(parent=current)
            return current
    UNTIL.min_size = RuleSize(1, 5)

    def PERFORM(self, parent=None):
        with UnlexerRuleContext(self, 'PERFORM', parent) as current:
            self._reserve(6, self.P, parent=current)
            self._reserve(5, self.E, parent=current)
            self._reserve(4, self.R, parent=current)
            self._reserve(3, self.F, parent=current)
            self._reserve(2, self.O, parent=current)
            self._reserve(1, self.R, parent=current)
            self.M(parent=current)
            return current
    PERFORM.min_size = RuleSize(1, 7)

    def THROUGH(self, parent=None):
        with UnlexerRuleContext(self, 'THROUGH', parent) as current:
            self._reserve(6, self.T, parent=current)
            self._reserve(5, self.H, parent=current)
            self._reserve(4, self.R, parent=current)
            self._reserve(3, self.O, parent=current)
            self._reserve(2, self.U, parent=current)
            self._reserve(1, self.G, parent=current)
            self.H(parent=current)
            return current
    THROUGH.min_size = RuleSize(1, 7)

    def PICTURE_IS(self, parent=None):
        with UnlexerRuleContext(self, 'PICTURE_IS', parent) as current:
            self._reserve(8, self.P, parent=current)
            self._reserve(7, self.I, parent=current)
            self._reserve(6, self.C, parent=current)
            self._reserve(5, self.T, parent=current)
            self._reserve(4, self.U, parent=current)
            self._reserve(3, self.R, parent=current)
            self._reserve(2, self.E, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(0, 0), 2) as quant0:
                while quant0(current):
                    current.src += ' '
            self._reserve(1, self.I, parent=current)
            self.S(parent=current)
            return current
    PICTURE_IS.min_size = RuleSize(1, 9)

    def LIKE(self, parent=None):
        with UnlexerRuleContext(self, 'LIKE', parent) as current:
            self._reserve(3, self.L, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.K, parent=current)
            self.E(parent=current)
            return current
    LIKE.min_size = RuleSize(1, 4)

    def OCCURS(self, parent=None):
        with UnlexerRuleContext(self, 'OCCURS', parent) as current:
            self._reserve(5, self.O, parent=current)
            self._reserve(4, self.C, parent=current)
            self._reserve(3, self.C, parent=current)
            self._reserve(2, self.U, parent=current)
            self._reserve(1, self.R, parent=current)
            self.S(parent=current)
            return current
    OCCURS.min_size = RuleSize(1, 6)

    def TIMES(self, parent=None):
        with UnlexerRuleContext(self, 'TIMES', parent) as current:
            self._reserve(4, self.T, parent=current)
            self._reserve(3, self.I, parent=current)
            self._reserve(2, self.M, parent=current)
            self._reserve(1, self.E, parent=current)
            self.S(parent=current)
            return current
    TIMES.min_size = RuleSize(1, 5)

    def OF(self, parent=None):
        with UnlexerRuleContext(self, 'OF', parent) as current:
            self._reserve(1, self.O, parent=current)
            self.F(parent=current)
            return current
    OF.min_size = RuleSize(1, 2)

    def NUMBER_REP(self, parent=None):
        with UnlexerRuleContext(self, 'NUMBER_REP', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.S(parent=current)
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(1, 2)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            self.Z(parent=current)
                elif choice0 == 1:
                    self._reserve(1, self.Z, parent=current)
                    self.REP_AMOUNT(parent=current)
            with AlternationContext(self, 1, (RuleSize(0, 0), RuleSize(1, 1)), 0, (1, 1)) as alt1:
                choice1 = alt1(current)
                if choice1 == 0:
                    with QuantifierContext(self, 2, 1, inf, RuleSize(0, 0), 0) as quant2:
                        while quant2(current):
                            current.src += '9'
                elif choice1 == 1:
                    current.src += '9'
                    self.REP_AMOUNT(parent=current)
            with QuantifierContext(self, 3, 0, 1, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.V(parent=current)
            with AlternationContext(self, 2, (RuleSize(0, 0), RuleSize(1, 1)), 0, (1, 1)) as alt2:
                choice2 = alt2(current)
                if choice2 == 0:
                    with QuantifierContext(self, 4, 0, inf, RuleSize(0, 0), 0) as quant4:
                        while quant4(current):
                            current.src += '9'
                elif choice2 == 1:
                    current.src += '9'
                    self.REP_AMOUNT(parent=current)
            return current
    NUMBER_REP.min_size = RuleSize(0, 0)

    def STRING_REP(self, parent=None):
        with UnlexerRuleContext(self, 'STRING_REP', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(0, 0)), 0, (1, 1, 1)) as alt0:
                        choice0 = alt0(current)
                        if choice0 == 0:
                            self.A(parent=current)
                            with QuantifierContext(self, 1, 0, 1, RuleSize(1, 1), 0) as quant1:
                                while quant1(current):
                                    self.REP_AMOUNT(parent=current)
                        elif choice0 == 1:
                            self.X(parent=current)
                            with QuantifierContext(self, 2, 0, 1, RuleSize(1, 1), 0) as quant2:
                                while quant2(current):
                                    self.REP_AMOUNT(parent=current)
                        elif choice0 == 2:
                            current.src += '9'
                            with QuantifierContext(self, 3, 0, 1, RuleSize(1, 1), 0) as quant3:
                                while quant3(current):
                                    self.REP_AMOUNT(parent=current)
            return current
    STRING_REP.min_size = RuleSize(0, 0)

    def REP_AMOUNT(self, parent=None):
        with UnlexerRuleContext(self, 'REP_AMOUNT', parent) as current:
            current.src += '('
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[1])
            current.src += ')'
            return current
    REP_AMOUNT.min_size = RuleSize(0, 0)

    def DATE_VALUE(self, parent=None):
        with UnlexerRuleContext(self, 'DATE_VALUE', parent) as current:
            self.Date(parent=current)
            return current
    DATE_VALUE.min_size = RuleSize(2, 9)

    def WITH_NO_ADVANCING(self, parent=None):
        with UnlexerRuleContext(self, 'WITH_NO_ADVANCING', parent) as current:
            self._reserve(14, self.W, parent=current)
            self._reserve(13, self.I, parent=current)
            self._reserve(12, self.T, parent=current)
            self._reserve(11, self.H, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(0, 0), 11) as quant0:
                while quant0(current):
                    current.src += ' '
            self._reserve(10, self.N, parent=current)
            self._reserve(9, self.O, parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(0, 0), 9) as quant1:
                while quant1(current):
                    current.src += ' '
            self._reserve(8, self.A, parent=current)
            self._reserve(7, self.D, parent=current)
            self._reserve(6, self.V, parent=current)
            self._reserve(5, self.A, parent=current)
            self._reserve(4, self.N, parent=current)
            self._reserve(3, self.C, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.N, parent=current)
            self.G(parent=current)
            return current
    WITH_NO_ADVANCING.min_size = RuleSize(1, 15)

    def NL(self, parent=None):
        with UnlexerRuleContext(self, 'NL', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += '\r'
            current.src += '\n'
            with QuantifierContext(self, 1, 0, inf, RuleSize(0, 0), 0) as quant1:
                while quant1(current):
                    current.src += ' '
            return current
    NL.min_size = RuleSize(0, 0)

    def DOT(self, parent=None):
        with UnlexerRuleContext(self, 'DOT', parent) as current:
            current.src += '.'
            return current
    DOT.min_size = RuleSize(0, 0)

    def NUMBER(self, parent=None):
        with UnlexerRuleContext(self, 'NUMBER', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.Digit(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    current.src += '.'
                    with QuantifierContext(self, 2, 1, inf, RuleSize(1, 1), 0) as quant2:
                        while quant2(current):
                            self.Digit(parent=current)
            return current
    NUMBER.min_size = RuleSize(1, 1)

    def ATOMIC(self, parent=None):
        with UnlexerRuleContext(self, 'ATOMIC', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.Atomic_Char(parent=current)
            return current
    ATOMIC.min_size = RuleSize(1, 1)

    def WS(self, parent=None):
        with UnlexerRuleContext(self, 'WS', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[2])
            return current
    WS.min_size = RuleSize(0, 0)

    def Atomic_Char(self, parent=None):
        with UnlexerRuleContext(self, 'Atomic_Char', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[3])
            return current
    Atomic_Char.min_size = RuleSize(0, 0)

    def Letter(self, parent=None):
        with UnlexerRuleContext(self, 'Letter', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)) as alt0:
                [self.A, self.B, self.C, self.D, self.E, self.F, self.G, self.H, self.I, self.J, self.K, self.L, self.M, self.N, self.O, self.P, self.Q, self.R, self.S, self.T, self.U, self.V, self.W, self.X, self.Y, self.Z][alt0(current)](parent=current)
            return current
    Letter.min_size = RuleSize(1, 1)

    def NINE(self, parent=None):
        with UnlexerRuleContext(self, 'NINE', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[4])
            return current
    NINE.min_size = RuleSize(0, 0)

    def Digit(self, parent=None):
        with UnlexerRuleContext(self, 'Digit', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[1])
            return current
    Digit.min_size = RuleSize(0, 0)

    def Anything(self, parent=None):
        with UnlexerRuleContext(self, 'Anything', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[0])
            return current
    Anything.min_size = RuleSize(0, 0)

    def Date(self, parent=None):
        with UnlexerRuleContext(self, 'Date', parent) as current:
            self._reserve(7, self.Digit, parent=current)
            self._reserve(6, self.Digit, parent=current)
            self._reserve(5, self.Digit, parent=current)
            self._reserve(4, self.Digit, parent=current)
            current.src += '-'
            self._reserve(3, self.Digit, parent=current)
            self._reserve(2, self.Digit, parent=current)
            current.src += '-'
            self._reserve(1, self.Digit, parent=current)
            self.Digit(parent=current)
            return current
    Date.min_size = RuleSize(1, 8)

    def Or(self, parent=None):
        with UnlexerRuleContext(self, 'Or', parent) as current:
            self._reserve(1, self.O, parent=current)
            self.R(parent=current)
            return current
    Or.min_size = RuleSize(1, 2)

    def And(self, parent=None):
        with UnlexerRuleContext(self, 'And', parent) as current:
            self._reserve(2, self.A, parent=current)
            self._reserve(1, self.N, parent=current)
            self.D(parent=current)
            return current
    And.min_size = RuleSize(1, 3)

    def Xor(self, parent=None):
        with UnlexerRuleContext(self, 'Xor', parent) as current:
            self._reserve(2, self.X, parent=current)
            self._reserve(1, self.O, parent=current)
            self.R(parent=current)
            return current
    Xor.min_size = RuleSize(1, 3)

    def ComparisonOp(self, parent=None):
        with UnlexerRuleContext(self, 'ComparisonOp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1, 1, 1, 1)) as alt0:
                current.src += ['=', '>', '<', '>=', '<='][alt0(current)]
            return current
    ComparisonOp.min_size = RuleSize(0, 0)

    def ArithmeticOp(self, parent=None):
        with UnlexerRuleContext(self, 'ArithmeticOp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1, 1, 1, 1)) as alt0:
                current.src += ['+', '-', '*', '/', '**'][alt0(current)]
            return current
    ArithmeticOp.min_size = RuleSize(0, 0)

    def ConcatOp(self, parent=None):
        with UnlexerRuleContext(self, 'ConcatOp', parent) as current:
            current.src += '+'
            return current
    ConcatOp.min_size = RuleSize(0, 0)

    def A(self, parent=None):
        with UnlexerRuleContext(self, 'A', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['a', 'A'][alt0(current)]
            return current
    A.min_size = RuleSize(0, 0)

    def B(self, parent=None):
        with UnlexerRuleContext(self, 'B', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['b', 'B'][alt0(current)]
            return current
    B.min_size = RuleSize(0, 0)

    def C(self, parent=None):
        with UnlexerRuleContext(self, 'C', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['c', 'C'][alt0(current)]
            return current
    C.min_size = RuleSize(0, 0)

    def D(self, parent=None):
        with UnlexerRuleContext(self, 'D', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['d', 'D'][alt0(current)]
            return current
    D.min_size = RuleSize(0, 0)

    def E(self, parent=None):
        with UnlexerRuleContext(self, 'E', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['e', 'E'][alt0(current)]
            return current
    E.min_size = RuleSize(0, 0)

    def F(self, parent=None):
        with UnlexerRuleContext(self, 'F', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['f', 'F'][alt0(current)]
            return current
    F.min_size = RuleSize(0, 0)

    def G(self, parent=None):
        with UnlexerRuleContext(self, 'G', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['g', 'G'][alt0(current)]
            return current
    G.min_size = RuleSize(0, 0)

    def H(self, parent=None):
        with UnlexerRuleContext(self, 'H', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['h', 'H'][alt0(current)]
            return current
    H.min_size = RuleSize(0, 0)

    def I(self, parent=None):
        with UnlexerRuleContext(self, 'I', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['i', 'I'][alt0(current)]
            return current
    I.min_size = RuleSize(0, 0)

    def J(self, parent=None):
        with UnlexerRuleContext(self, 'J', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['j', 'J'][alt0(current)]
            return current
    J.min_size = RuleSize(0, 0)

    def K(self, parent=None):
        with UnlexerRuleContext(self, 'K', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['k', 'K'][alt0(current)]
            return current
    K.min_size = RuleSize(0, 0)

    def L(self, parent=None):
        with UnlexerRuleContext(self, 'L', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['l', 'L'][alt0(current)]
            return current
    L.min_size = RuleSize(0, 0)

    def M(self, parent=None):
        with UnlexerRuleContext(self, 'M', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['m', 'M'][alt0(current)]
            return current
    M.min_size = RuleSize(0, 0)

    def N(self, parent=None):
        with UnlexerRuleContext(self, 'N', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['n', 'N'][alt0(current)]
            return current
    N.min_size = RuleSize(0, 0)

    def O(self, parent=None):
        with UnlexerRuleContext(self, 'O', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['o', 'O'][alt0(current)]
            return current
    O.min_size = RuleSize(0, 0)

    def P(self, parent=None):
        with UnlexerRuleContext(self, 'P', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['p', 'P'][alt0(current)]
            return current
    P.min_size = RuleSize(0, 0)

    def Q(self, parent=None):
        with UnlexerRuleContext(self, 'Q', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['q', 'Q'][alt0(current)]
            return current
    Q.min_size = RuleSize(0, 0)

    def R(self, parent=None):
        with UnlexerRuleContext(self, 'R', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['r', 'R'][alt0(current)]
            return current
    R.min_size = RuleSize(0, 0)

    def S(self, parent=None):
        with UnlexerRuleContext(self, 'S', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['s', 'S'][alt0(current)]
            return current
    S.min_size = RuleSize(0, 0)

    def T(self, parent=None):
        with UnlexerRuleContext(self, 'T', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['t', 'T'][alt0(current)]
            return current
    T.min_size = RuleSize(0, 0)

    def U(self, parent=None):
        with UnlexerRuleContext(self, 'U', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['u', 'U'][alt0(current)]
            return current
    U.min_size = RuleSize(0, 0)

    def V(self, parent=None):
        with UnlexerRuleContext(self, 'V', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['v', 'V'][alt0(current)]
            return current
    V.min_size = RuleSize(0, 0)

    def W(self, parent=None):
        with UnlexerRuleContext(self, 'W', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['w', 'W'][alt0(current)]
            return current
    W.min_size = RuleSize(0, 0)

    def X(self, parent=None):
        with UnlexerRuleContext(self, 'X', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['x', 'X'][alt0(current)]
            return current
    X.min_size = RuleSize(0, 0)

    def Y(self, parent=None):
        with UnlexerRuleContext(self, 'Y', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['y', 'Y'][alt0(current)]
            return current
    Y.min_size = RuleSize(0, 0)

    def Z(self, parent=None):
        with UnlexerRuleContext(self, 'Z', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['z', 'Z'][alt0(current)]
            return current
    Z.min_size = RuleSize(0, 0)

    _default_rule = program

    _charsets = {
        0: list(itertools.chain.from_iterable([range(0x20, 0x7f)])),
        1: list(itertools.chain.from_iterable([range(0x30, 0x3a)])),
        2: list(itertools.chain.from_iterable([range(0x9, 0xa), range(0xa, 0xb), range(0xc, 0xd), range(0xd, 0xe), range(0x20, 0x21)])),
        3: list(itertools.chain.from_iterable([range(0x21, 0x2e), range(0x2f, 0x7f)])),
        4: list(itertools.chain.from_iterable([range(0x39, 0x3a)])),
    }
