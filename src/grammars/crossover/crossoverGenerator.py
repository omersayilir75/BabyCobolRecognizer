# Generated by Grammarinator 23.7.post31+g3f15e2c.d20231108

import itertools

from math import inf
from grammarinator.runtime import *

class crossoverGenerator(Generator):


    def EOF(self, parent=None):
        pass
    EOF.min_size = RuleSize(0, 0)

    def program(self, parent=None):
        with UnparserRuleContext(self, 'program', parent) as current:
            self._reserve(4, self.identificationDiv, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 3), 4) as quant0:
                while quant0(current):
                    self.dataDivision(parent=current)
            self._reserve(1, self.procedure, parent=current)
            self.EOF(parent=current)
            return current
    program.min_size = RuleSize(2, 7)

    def identificationDiv(self, parent=None):
        with UnparserRuleContext(self, 'identificationDiv', parent) as current:
            self._reserve(2, self.IDENTIFICATION, parent=current)
            self._reserve(1, self.DIVISION, parent=current)
            self.DOT(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(2, 4), 0) as quant0:
                while quant0(current):
                    self.identificationEntry(parent=current)
            return current
    identificationDiv.min_size = RuleSize(1, 3)

    def identificationEntry(self, parent=None):
        with UnparserRuleContext(self, 'identificationEntry', parent) as current:
            self._reserve(3, self.IDENTIFIER, parent=current)
            self._reserve(2, self.DOT, parent=current)
            self._reserve(1, self.LITERAL, parent=current)
            self.DOT(parent=current)
            return current
    identificationEntry.min_size = RuleSize(1, 4)

    def dataDivision(self, parent=None):
        local_ctx = dict(lines=[])
        with UnparserRuleContext(self, 'dataDivision', parent) as current:
            self._reserve(2, self.DATA, parent=current)
            self._reserve(1, self.DIVISION, parent=current)
            self.DOT(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(3, 3), 0) as quant0:
                while quant0(current):
                    self.line(parent=current)
                    local_ctx['lines'].append(current.last_child)
            return current
    dataDivision.min_size = RuleSize(1, 3)

    def line(self, parent=None):
        with UnparserRuleContext(self, 'line', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 3), RuleSize(2, 5)), 0, (1, 1)) as alt0:
                [self.record, self.field][alt0(current)](parent=current)
            return current
    line.min_size = RuleSize(2, 3)

    def record(self, parent=None):
        with UnparserRuleContext(self, 'record', parent) as current:
            self._reserve(2, self.LEVEL, parent=current)
            self._reserve(1, self.IDENTIFIER, parent=current)
            self.DOT(parent=current)
            return current
    record.min_size = RuleSize(1, 3)

    def field(self, parent=None):
        with UnparserRuleContext(self, 'field', parent) as current:
            self._reserve(4, self.LEVEL, parent=current)
            self._reserve(3, self.IDENTIFIER, parent=current)
            with AlternationContext(self, 0, (RuleSize(1, 3), RuleSize(2, 2)), 1, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self._reserve(2, self.PICTURE, parent=current)
                    self._reserve(1, self.IS, parent=current)
                    self.MASK(parent=current)
                elif choice0 == 1:
                    self._reserve(1, self.LIKE, parent=current)
                    self.identifiers(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 3), 1) as quant0:
                while quant0(current):
                    self._reserve(2, self.OCCURS, parent=current)
                    self._reserve(1, self.INT, parent=current)
                    self.TIMES(parent=current)
            self.DOT(parent=current)
            return current
    field.min_size = RuleSize(1, 5)

    def procedure(self, parent=None):
        with UnparserRuleContext(self, 'procedure', parent) as current:
            self._reserve(2, self.PROCEDURE, parent=current)
            self._reserve(1, self.DIVISION, parent=current)
            self.DOT(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(3, 4), 0) as quant0:
                while quant0(current):
                    self.paragraph(parent=current)
            return current
    procedure.min_size = RuleSize(1, 3)

    def paragraph(self, parent=None):
        with UnparserRuleContext(self, 'paragraph', parent) as current:
            self._reserve(3, self.label, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(3, 2), 3) as quant0:
                while quant0(current):
                    self._reserve(1, self.USING, parent=current)
                    with QuantifierContext(self, 1, 1, inf, RuleSize(3, 1), 0) as quant1:
                        while quant1(current):
                            self.atomic(parent=current)
            self._reserve(2, self.DOT, parent=current)
            with QuantifierContext(self, 2, 0, inf, RuleSize(4, 2), 2) as quant2:
                while quant2(current):
                    self.sentence(parent=current)
            self._reserve(1, self.END, parent=current)
            self.DOT(parent=current)
            return current
    paragraph.min_size = RuleSize(2, 4)

    def sentence(self, parent=None):
        with UnparserRuleContext(self, 'sentence', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 1) as quant0:
                while quant0(current):
                    self.statement(parent=current)
            self.DOT(parent=current)
            return current
    sentence.min_size = RuleSize(3, 2)

    def statement(self, parent=None):
        with UnparserRuleContext(self, 'statement', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 1) as quant0:
                while quant0(current):
                    with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                        [self.SYMBOL_MULT, self.SYMBOL_MINUS][alt0(current)](parent=current)
            with AlternationContext(self, 1, (RuleSize(4, 2), RuleSize(2, 1), RuleSize(3, 4), RuleSize(4, 4), RuleSize(4, 4), RuleSize(3, 2), RuleSize(4, 5), RuleSize(3, 2), RuleSize(4, 4), RuleSize(4, 4), RuleSize(5, 3), RuleSize(2, 2), RuleSize(4, 3), RuleSize(2, 3), RuleSize(2, 3), RuleSize(3, 6), RuleSize(2, 2)), 0, (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)) as alt1:
                [self.display, self.stop, self.move, self.subtract, self.multiply, self.perform, self.ifStatement, self.accept, self.add, self.divide, self.evaluate, self.nextSentence, self.loop, self.gotoStatement, self.signal, self.alter, self.callStatement][alt1(current)](parent=current)
            return current
    statement.min_size = RuleSize(2, 1)

    def label(self, parent=None):
        with UnparserRuleContext(self, 'label', parent) as current:
            self.IDENTIFIER(parent=current)
            return current
    label.min_size = RuleSize(1, 1)

    def display(self, parent=None):
        with UnparserRuleContext(self, 'display', parent) as current:
            self._reserve(1, self.DISPLAY, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(1, 3), 0) as quant1:
                while quant1(current):
                    self._reserve(2, self.WITH, parent=current)
                    self._reserve(1, self.NO, parent=current)
                    self.ADVANCING(parent=current)
            return current
    display.min_size = RuleSize(3, 2)

    def stop(self, parent=None):
        with UnparserRuleContext(self, 'stop', parent) as current:
            self.STOP(parent=current)
            return current
    stop.min_size = RuleSize(1, 1)

    def move(self, parent=None):
        with UnparserRuleContext(self, 'move', parent) as current:
            self._reserve(3, self.MOVE, parent=current)
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(3, 1)), 2, (1, 1, 1, 1)) as alt0:
                [self.SPACES, self.HIGH, self.LOW, self.atomic][alt0(current)](parent=current)
            self._reserve(1, self.TO, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(2, 1), 0) as quant0:
                while quant0(current):
                    self.identifiers(parent=current)
            return current
    move.min_size = RuleSize(2, 4)

    def subtract(self, parent=None):
        local_ctx = dict(ats=[], frm=None, giving=None)
        with UnparserRuleContext(self, 'subtract', parent) as current:
            self._reserve(3, self.SUBTRACT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 2) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
                    local_ctx['ats'].append(current.last_child)
            self._reserve(1, self.FROM, parent=current)
            self.atomic(parent=current)
            local_ctx['frm'] = current.last_child
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 2), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.GIVING, parent=current)
                    self.identifiers(parent=current)
                    local_ctx['giving'] = current.last_child
            return current
    subtract.min_size = RuleSize(3, 4)

    def multiply(self, parent=None):
        local_ctx = dict(at=None, ats=[], giving=None)
        with UnparserRuleContext(self, 'multiply', parent) as current:
            self._reserve(3, self.MULTIPLY, parent=current)
            self._reserve(2, self.atomic, parent=current)
            local_ctx['at'] = current.last_child
            self._reserve(1, self.BY, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
                    local_ctx['ats'].append(current.last_child)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 2), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.GIVING, parent=current)
                    self.identifiers(parent=current)
                    local_ctx['giving'] = current.last_child
            return current
    multiply.min_size = RuleSize(3, 4)

    def perform(self, parent=None):
        local_ctx = dict(procedureName=None, through=None, times=None)
        with UnparserRuleContext(self, 'perform', parent) as current:
            self._reserve(1, self.PERFORM, parent=current)
            self.label(parent=current)
            local_ctx['procedureName'] = current.last_child
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 2), 0) as quant0:
                while quant0(current):
                    self._reserve(1, self.THROUGH, parent=current)
                    self.label(parent=current)
                    local_ctx['through'] = current.last_child
            with QuantifierContext(self, 1, 0, 1, RuleSize(3, 2), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.atomic, parent=current)
                    local_ctx['times'] = current.last_child
                    self.TIMES(parent=current)
            return current
    perform.min_size = RuleSize(2, 2)

    def ifStatement(self, parent=None):
        local_ctx = dict(t=[], f=[])
        with UnparserRuleContext(self, 'ifStatement', parent) as current:
            self._reserve(4, self.IF, parent=current)
            self._reserve(3, self.booleanExpression, parent=current)
            self._reserve(2, self.THEN, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 1) as quant0:
                while quant0(current):
                    self.statement(parent=current)
                    local_ctx['t'].append(current.last_child)
            with QuantifierContext(self, 1, 0, 1, RuleSize(3, 2), 1) as quant1:
                while quant1(current):
                    self._reserve(1, self.ELSE, parent=current)
                    with QuantifierContext(self, 2, 1, inf, RuleSize(3, 1), 0) as quant2:
                        while quant2(current):
                            self.statement(parent=current)
                            local_ctx['f'].append(current.last_child)
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                [self.END, self.DOT][alt0(current)](parent=current)
            return current
    ifStatement.min_size = RuleSize(3, 5)

    def accept(self, parent=None):
        local_ctx = dict(id=[])
        with UnparserRuleContext(self, 'accept', parent) as current:
            self._reserve(1, self.ACCEPT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(2, 1), 0) as quant0:
                while quant0(current):
                    self.identifiers(parent=current)
                    local_ctx['id'].append(current.last_child)
            return current
    accept.min_size = RuleSize(2, 2)

    def add(self, parent=None):
        local_ctx = dict(to=None, id=None)
        with UnparserRuleContext(self, 'add', parent) as current:
            self._reserve(3, self.ADD, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 2) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
            self._reserve(1, self.TO, parent=current)
            self.atomic(parent=current)
            local_ctx['to'] = current.last_child
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 2), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.GIVING, parent=current)
                    self.identifiers(parent=current)
                    local_ctx['id'] = current.last_child
            return current
    add.min_size = RuleSize(3, 4)

    def divide(self, parent=None):
        local_ctx = dict(at=None, ats=[], id=None, rem=None)
        with UnparserRuleContext(self, 'divide', parent) as current:
            self._reserve(3, self.DIVIDE, parent=current)
            self._reserve(2, self.atomic, parent=current)
            local_ctx['at'] = current.last_child
            self._reserve(1, self.INTO, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
                    local_ctx['ats'].append(current.last_child)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 2), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.GIVING, parent=current)
                    self.identifiers(parent=current)
                    local_ctx['id'] = current.last_child
            with QuantifierContext(self, 2, 0, 1, RuleSize(2, 2), 0) as quant2:
                while quant2(current):
                    self._reserve(1, self.REMAINDER, parent=current)
                    self.identifiers(parent=current)
                    local_ctx['rem'] = current.last_child
            return current
    divide.min_size = RuleSize(3, 4)

    def evaluate(self, parent=None):
        with UnparserRuleContext(self, 'evaluate', parent) as current:
            self._reserve(2, self.EVALUATE, parent=current)
            self._reserve(1, self.anyExpression, parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(5, 3), 1) as quant0:
                while quant0(current):
                    self.whenBlock(parent=current)
            self.END(parent=current)
            return current
    evaluate.min_size = RuleSize(4, 3)

    def nextSentence(self, parent=None):
        with UnparserRuleContext(self, 'nextSentence', parent) as current:
            self._reserve(1, self.NEXT, parent=current)
            self.SENTENCE(parent=current)
            return current
    nextSentence.min_size = RuleSize(1, 2)

    def loop(self, parent=None):
        with UnparserRuleContext(self, 'loop', parent) as current:
            self._reserve(2, self.LOOP, parent=current)
            self._reserve(1, self.loopExpression, parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(3, 1), 1) as quant0:
                while quant0(current):
                    self.statement(parent=current)
            self.END(parent=current)
            return current
    loop.min_size = RuleSize(3, 3)

    def gotoStatement(self, parent=None):
        with UnparserRuleContext(self, 'gotoStatement', parent) as current:
            self._reserve(2, self.GO, parent=current)
            self._reserve(1, self.TO, parent=current)
            self.IDENTIFIER(parent=current)
            return current
    gotoStatement.min_size = RuleSize(1, 3)

    def signal(self, parent=None):
        with UnparserRuleContext(self, 'signal', parent) as current:
            self._reserve(2, self.SIGNAL, parent=current)
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(1, 1)), 1, (1, 1)) as alt0:
                [self.label, self.OFF][alt0(current)](parent=current)
            self.ONERROR(parent=current)
            return current
    signal.min_size = RuleSize(1, 3)

    def alter(self, parent=None):
        local_ctx = dict(l1=None, l2=None)
        with UnparserRuleContext(self, 'alter', parent) as current:
            self._reserve(5, self.ALTER, parent=current)
            self._reserve(4, self.label, parent=current)
            local_ctx['l1'] = current.last_child
            self._reserve(3, self.TO, parent=current)
            self._reserve(2, self.PROCEED, parent=current)
            self._reserve(1, self.TO, parent=current)
            self.label(parent=current)
            local_ctx['l2'] = current.last_child
            return current
    alter.min_size = RuleSize(2, 6)

    def callStatement(self, parent=None):
        local_ctx = dict(function_name=None, program_name=None, byvalueatomicsprim=[], byreferenceatomicsprim=[], byvalueatomicsstruct=[], byreferenceatomicsstruct=[], reference_return=None, returning=None, primitive_return=None)
        with UnparserRuleContext(self, 'callStatement', parent) as current:
            self._reserve(1, self.CALL, parent=current)
            self.IDENTIFIER(parent=current)
            local_ctx['function_name'] = current.last_child
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 2), 0) as quant0:
                while quant0(current):
                    self._reserve(1, self.OF, parent=current)
                    self.IDENTIFIER(parent=current)
                    local_ctx['program_name'] = current.last_child
            with QuantifierContext(self, 1, 0, 1, RuleSize(3, 2), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.USING, parent=current)
                    with QuantifierContext(self, 2, 1, inf, RuleSize(3, 1), 0) as quant2:
                        while quant2(current):
                            with AlternationContext(self, 0, (RuleSize(3, 4), RuleSize(3, 4), RuleSize(3, 3), RuleSize(3, 4), RuleSize(3, 4), RuleSize(3, 3), RuleSize(3, 2), RuleSize(3, 2), RuleSize(3, 1)), 0, (1, 1, 1, 1, 1, 1, 1, 1, 1)) as alt0:
                                choice0 = alt0(current)
                                if choice0 == 0:
                                    self._reserve(3, self.BYVALUE, parent=current)
                                    with QuantifierContext(self, 3, 1, inf, RuleSize(3, 1), 2) as quant3:
                                        while quant3(current):
                                            self.atomic(parent=current)
                                            local_ctx['byvalueatomicsprim'].append(current.last_child)
                                    self._reserve(1, self.AS, parent=current)
                                    self.PRIMITIVE(parent=current)
                                elif choice0 == 1:
                                    self._reserve(3, self.BYREFERENCE, parent=current)
                                    with QuantifierContext(self, 4, 1, inf, RuleSize(3, 1), 2) as quant4:
                                        while quant4(current):
                                            self.atomic(parent=current)
                                            local_ctx['byreferenceatomicsprim'].append(current.last_child)
                                    self._reserve(1, self.AS, parent=current)
                                    self.PRIMITIVE(parent=current)
                                elif choice0 == 2:
                                    with QuantifierContext(self, 5, 1, inf, RuleSize(3, 1), 2) as quant5:
                                        while quant5(current):
                                            self.atomic(parent=current)
                                            local_ctx['byvalueatomicsprim'].append(current.last_child)
                                    self._reserve(1, self.AS, parent=current)
                                    self.PRIMITIVE(parent=current)
                                elif choice0 == 3:
                                    self._reserve(3, self.BYVALUE, parent=current)
                                    with QuantifierContext(self, 6, 1, inf, RuleSize(3, 1), 2) as quant6:
                                        while quant6(current):
                                            self.atomic(parent=current)
                                            local_ctx['byvalueatomicsstruct'].append(current.last_child)
                                    self._reserve(1, self.AS, parent=current)
                                    self.STRUCT(parent=current)
                                elif choice0 == 4:
                                    self._reserve(3, self.BYREFERENCE, parent=current)
                                    with QuantifierContext(self, 7, 1, inf, RuleSize(3, 1), 2) as quant7:
                                        while quant7(current):
                                            self.atomic(parent=current)
                                            local_ctx['byreferenceatomicsstruct'].append(current.last_child)
                                    self._reserve(1, self.AS, parent=current)
                                    self.STRUCT(parent=current)
                                elif choice0 == 5:
                                    with QuantifierContext(self, 8, 1, inf, RuleSize(3, 1), 2) as quant8:
                                        while quant8(current):
                                            self.atomic(parent=current)
                                            local_ctx['byvalueatomicsstruct'].append(current.last_child)
                                    self._reserve(1, self.AS, parent=current)
                                    self.STRUCT(parent=current)
                                elif choice0 == 6:
                                    self._reserve(1, self.BYVALUE, parent=current)
                                    with QuantifierContext(self, 9, 1, inf, RuleSize(3, 1), 0) as quant9:
                                        while quant9(current):
                                            self.atomic(parent=current)
                                            local_ctx['byvalueatomicsprim'].append(current.last_child)
                                elif choice0 == 7:
                                    self._reserve(1, self.BYREFERENCE, parent=current)
                                    with QuantifierContext(self, 10, 1, inf, RuleSize(3, 1), 0) as quant10:
                                        while quant10(current):
                                            self.atomic(parent=current)
                                            local_ctx['byreferenceatomicsprim'].append(current.last_child)
                                elif choice0 == 8:
                                    with QuantifierContext(self, 11, 1, inf, RuleSize(3, 1), 0) as quant11:
                                        while quant11(current):
                                            self.atomic(parent=current)
                                            local_ctx['byvalueatomicsprim'].append(current.last_child)
            with QuantifierContext(self, 12, 0, 1, RuleSize(2, 2), 0) as quant12:
                while quant12(current):
                    self._reserve(1, self.RETURNING, parent=current)
                    with QuantifierContext(self, 13, 0, 1, RuleSize(1, 1), 1) as quant13:
                        while quant13(current):
                            with AlternationContext(self, 1, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt1:
                                choice1 = alt1(current)
                                if choice1 == 0:
                                    self.BYVALUE(parent=current)
                                elif choice1 == 1:
                                    self.BYREFERENCE(parent=current)
                                    local_ctx['reference_return'] = current.last_child
                    self.identifiers(parent=current)
                    local_ctx['returning'] = current.last_child
                    with QuantifierContext(self, 14, 0, 1, RuleSize(1, 2), 0) as quant14:
                        while quant14(current):
                            self._reserve(1, self.AS, parent=current)
                            with AlternationContext(self, 2, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt2:
                                choice2 = alt2(current)
                                if choice2 == 0:
                                    self.PRIMITIVE(parent=current)
                                    local_ctx['primitive_return'] = current.last_child
                                elif choice2 == 1:
                                    self.STRUCT(parent=current)
            return current
    callStatement.min_size = RuleSize(1, 2)

    def anyExpression(self, parent=None):
        with UnparserRuleContext(self, 'anyExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(5, 1), RuleSize(5, 1), RuleSize(3, 1)), 0, (1, 1, 1)) as alt0:
                [self.arithmeticExpression, self.stringExpression, self.booleanExpression][alt0(current)](parent=current)
            return current
    anyExpression.min_size = RuleSize(3, 1)

    def arithmeticExpression(self, parent=None):
        with UnparserRuleContext(self, 'arithmeticExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(4, 1), RuleSize(6, 3)), 0, (1, 1)) as alt0:
                [self.arithmeticExpression_atomicArithmeticExp, self.arithmeticExpression_arithOpArithmeticExp][alt0(current)](parent=current)
            return current
    arithmeticExpression.min_size = RuleSize(4, 1)

    def stringExpression(self, parent=None):
        with UnparserRuleContext(self, 'stringExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(4, 1), RuleSize(6, 3)), 0, (1, 1)) as alt0:
                [self.stringExpression_atomicStringExp, self.stringExpression_additionStringExp][alt0(current)](parent=current)
            return current
    stringExpression.min_size = RuleSize(4, 1)

    def booleanExpression(self, parent=None):
        with UnparserRuleContext(self, 'booleanExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(2, 1), RuleSize(7, 5), RuleSize(6, 3), RuleSize(4, 2), RuleSize(4, 3)), 0, (1, 1, 1, 1, 1, 1)) as alt0:
                [self.booleanExpression_trueBooleanExp, self.booleanExpression_falseBooleanExp, self.booleanExpression_contractedBooleanExp, self.booleanExpression_compareOpBooleanExp, self.booleanExpression_notBooleanExp, self.booleanExpression_boolOpBooleanExp][alt0(current)](parent=current)
            return current
    booleanExpression.min_size = RuleSize(2, 1)

    def loopExpression(self, parent=None):
        with UnparserRuleContext(self, 'loopExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(4, 2), RuleSize(4, 2)), 0, (1, 1, 1)) as alt0:
                [self.loopExpression_varyingLoopExp, self.loopExpression_whileLoopExp, self.loopExpression_untilLoopExp][alt0(current)](parent=current)
            return current
    loopExpression.min_size = RuleSize(2, 1)

    def contractedBooleanPart(self, parent=None):
        with UnparserRuleContext(self, 'contractedBooleanPart', parent) as current:
            self._reserve(1, self.booleanOp, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 1), 1) as quant0:
                while quant0(current):
                    self.comparisonOp(parent=current)
            self.arithmeticExpression(parent=current)
            return current
    contractedBooleanPart.min_size = RuleSize(5, 2)

    def comparisonOp(self, parent=None):
        with UnparserRuleContext(self, 'comparisonOp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1, 1, 1, 1, 1)) as alt0:
                [self.NEQ, self.LT, self.LTE, self.EQ, self.GT, self.GTE][alt0(current)](parent=current)
            return current
    comparisonOp.min_size = RuleSize(1, 1)

    def booleanOp(self, parent=None):
        with UnparserRuleContext(self, 'booleanOp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1, 1)) as alt0:
                [self.OR, self.AND, self.XOR][alt0(current)](parent=current)
            return current
    booleanOp.min_size = RuleSize(1, 1)

    def arithmeticOp(self, parent=None):
        with UnparserRuleContext(self, 'arithmeticOp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1, 1, 1, 1)) as alt0:
                [self.SYMBOL_PLUS, self.SYMBOL_MINUS, self.SYMBOL_MULT, self.SYMBOL_DIV, self.SYMBOL_EXP][alt0(current)](parent=current)
            return current
    arithmeticOp.min_size = RuleSize(1, 1)

    def whenBlock(self, parent=None):
        with UnparserRuleContext(self, 'whenBlock', parent) as current:
            with AlternationContext(self, 0, (RuleSize(5, 3), RuleSize(4, 3)), 0, (1, 1)) as alt0:
                [self.whenBlock_whenAnyExpression, self.whenBlock_whenOther][alt0(current)](parent=current)
            return current
    whenBlock.min_size = RuleSize(4, 3)

    def atomic(self, parent=None):
        with UnparserRuleContext(self, 'atomic', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 1), RuleSize(3, 3), RuleSize(2, 1), RuleSize(3, 1)), 0, (1, 1, 1, 1)) as alt0:
                [self.atomic_intLiteral, self.atomic_doubleLiteral, self.atomic_stringLiteral, self.atomic_identifier][alt0(current)](parent=current)
            return current
    atomic.min_size = RuleSize(2, 1)

    def identifiers(self, parent=None):
        with UnparserRuleContext(self, 'identifiers', parent) as current:
            self.IDENTIFIER(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 2), 0) as quant0:
                while quant0(current):
                    self._reserve(1, self.OF, parent=current)
                    self.IDENTIFIER(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 3), 0) as quant1:
                while quant1(current):
                    self._reserve(2, self.T__0, parent=current)
                    self._reserve(1, self.int, parent=current)
                    self.T__1(parent=current)
            return current
    identifiers.min_size = RuleSize(1, 1)

    def int(self, parent=None):
        with UnparserRuleContext(self, 'int', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 1) as quant0:
                while quant0(current):
                    with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                        [self.SYMBOL_MINUS, self.SYMBOL_PLUS][alt0(current)](parent=current)
            self.INT(parent=current)
            return current
    int.min_size = RuleSize(1, 1)

    def STRUCT(self, parent=None):
        with UnlexerRuleContext(self, 'STRUCT', parent) as current:
            current.src += 'STRUCT'
            return current
    STRUCT.min_size = RuleSize(0, 0)

    def PRIMITIVE(self, parent=None):
        with UnlexerRuleContext(self, 'PRIMITIVE', parent) as current:
            current.src += 'PRIMITIVE'
            return current
    PRIMITIVE.min_size = RuleSize(0, 0)

    def IDENTIFICATION(self, parent=None):
        with UnlexerRuleContext(self, 'IDENTIFICATION', parent) as current:
            current.src += 'IDENTIFICATION'
            return current
    IDENTIFICATION.min_size = RuleSize(0, 0)

    def DIVISION(self, parent=None):
        with UnlexerRuleContext(self, 'DIVISION', parent) as current:
            current.src += 'DIVISION'
            return current
    DIVISION.min_size = RuleSize(0, 0)

    def PROCEDURE(self, parent=None):
        with UnlexerRuleContext(self, 'PROCEDURE', parent) as current:
            current.src += 'PROCEDURE'
            return current
    PROCEDURE.min_size = RuleSize(0, 0)

    def DATA(self, parent=None):
        with UnlexerRuleContext(self, 'DATA', parent) as current:
            current.src += 'DATA'
            return current
    DATA.min_size = RuleSize(0, 0)

    def DISPLAY(self, parent=None):
        with UnlexerRuleContext(self, 'DISPLAY', parent) as current:
            current.src += 'DISPLAY'
            return current
    DISPLAY.min_size = RuleSize(0, 0)

    def WITH(self, parent=None):
        with UnlexerRuleContext(self, 'WITH', parent) as current:
            current.src += 'WITH'
            return current
    WITH.min_size = RuleSize(0, 0)

    def NO(self, parent=None):
        with UnlexerRuleContext(self, 'NO', parent) as current:
            current.src += 'NO'
            return current
    NO.min_size = RuleSize(0, 0)

    def ADVANCING(self, parent=None):
        with UnlexerRuleContext(self, 'ADVANCING', parent) as current:
            current.src += 'ADVANCING'
            return current
    ADVANCING.min_size = RuleSize(0, 0)

    def STOP(self, parent=None):
        with UnlexerRuleContext(self, 'STOP', parent) as current:
            current.src += 'STOP'
            return current
    STOP.min_size = RuleSize(0, 0)

    def MOVE(self, parent=None):
        with UnlexerRuleContext(self, 'MOVE', parent) as current:
            current.src += 'MOVE'
            return current
    MOVE.min_size = RuleSize(0, 0)

    def TO(self, parent=None):
        with UnlexerRuleContext(self, 'TO', parent) as current:
            current.src += 'TO'
            return current
    TO.min_size = RuleSize(0, 0)

    def SUBTRACT(self, parent=None):
        with UnlexerRuleContext(self, 'SUBTRACT', parent) as current:
            current.src += 'SUBTRACT'
            return current
    SUBTRACT.min_size = RuleSize(0, 0)

    def FROM(self, parent=None):
        with UnlexerRuleContext(self, 'FROM', parent) as current:
            current.src += 'FROM'
            return current
    FROM.min_size = RuleSize(0, 0)

    def GIVING(self, parent=None):
        with UnlexerRuleContext(self, 'GIVING', parent) as current:
            current.src += 'GIVING'
            return current
    GIVING.min_size = RuleSize(0, 0)

    def MULTIPLY(self, parent=None):
        with UnlexerRuleContext(self, 'MULTIPLY', parent) as current:
            current.src += 'MULTIPLY'
            return current
    MULTIPLY.min_size = RuleSize(0, 0)

    def BY(self, parent=None):
        with UnlexerRuleContext(self, 'BY', parent) as current:
            current.src += 'BY'
            return current
    BY.min_size = RuleSize(0, 0)

    def PERFORM(self, parent=None):
        with UnlexerRuleContext(self, 'PERFORM', parent) as current:
            current.src += 'PERFORM'
            return current
    PERFORM.min_size = RuleSize(0, 0)

    def TIMES(self, parent=None):
        with UnlexerRuleContext(self, 'TIMES', parent) as current:
            current.src += 'TIMES'
            return current
    TIMES.min_size = RuleSize(0, 0)

    def IF(self, parent=None):
        with UnlexerRuleContext(self, 'IF', parent) as current:
            current.src += 'IF'
            return current
    IF.min_size = RuleSize(0, 0)

    def THEN(self, parent=None):
        with UnlexerRuleContext(self, 'THEN', parent) as current:
            current.src += 'THEN'
            return current
    THEN.min_size = RuleSize(0, 0)

    def ELSE(self, parent=None):
        with UnlexerRuleContext(self, 'ELSE', parent) as current:
            current.src += 'ELSE'
            return current
    ELSE.min_size = RuleSize(0, 0)

    def END(self, parent=None):
        with UnlexerRuleContext(self, 'END', parent) as current:
            current.src += 'END'
            return current
    END.min_size = RuleSize(0, 0)

    def ACCEPT(self, parent=None):
        with UnlexerRuleContext(self, 'ACCEPT', parent) as current:
            current.src += 'ACCEPT'
            return current
    ACCEPT.min_size = RuleSize(0, 0)

    def ADD(self, parent=None):
        with UnlexerRuleContext(self, 'ADD', parent) as current:
            current.src += 'ADD'
            return current
    ADD.min_size = RuleSize(0, 0)

    def DIVIDE(self, parent=None):
        with UnlexerRuleContext(self, 'DIVIDE', parent) as current:
            current.src += 'DIVIDE'
            return current
    DIVIDE.min_size = RuleSize(0, 0)

    def INTO(self, parent=None):
        with UnlexerRuleContext(self, 'INTO', parent) as current:
            current.src += 'INTO'
            return current
    INTO.min_size = RuleSize(0, 0)

    def EVALUATE(self, parent=None):
        with UnlexerRuleContext(self, 'EVALUATE', parent) as current:
            current.src += 'EVALUATE'
            return current
    EVALUATE.min_size = RuleSize(0, 0)

    def WHEN(self, parent=None):
        with UnlexerRuleContext(self, 'WHEN', parent) as current:
            current.src += 'WHEN'
            return current
    WHEN.min_size = RuleSize(0, 0)

    def OTHER(self, parent=None):
        with UnlexerRuleContext(self, 'OTHER', parent) as current:
            current.src += 'OTHER'
            return current
    OTHER.min_size = RuleSize(0, 0)

    def TRUE(self, parent=None):
        with UnlexerRuleContext(self, 'TRUE', parent) as current:
            current.src += 'TRUE'
            return current
    TRUE.min_size = RuleSize(0, 0)

    def FALSE(self, parent=None):
        with UnlexerRuleContext(self, 'FALSE', parent) as current:
            current.src += 'FALSE'
            return current
    FALSE.min_size = RuleSize(0, 0)

    def NOT(self, parent=None):
        with UnlexerRuleContext(self, 'NOT', parent) as current:
            current.src += 'NOT'
            return current
    NOT.min_size = RuleSize(0, 0)

    def OR(self, parent=None):
        with UnlexerRuleContext(self, 'OR', parent) as current:
            current.src += 'OR'
            return current
    OR.min_size = RuleSize(0, 0)

    def AND(self, parent=None):
        with UnlexerRuleContext(self, 'AND', parent) as current:
            current.src += 'AND'
            return current
    AND.min_size = RuleSize(0, 0)

    def XOR(self, parent=None):
        with UnlexerRuleContext(self, 'XOR', parent) as current:
            current.src += 'XOR'
            return current
    XOR.min_size = RuleSize(0, 0)

    def NEXT(self, parent=None):
        with UnlexerRuleContext(self, 'NEXT', parent) as current:
            current.src += 'NEXT'
            return current
    NEXT.min_size = RuleSize(0, 0)

    def SENTENCE(self, parent=None):
        with UnlexerRuleContext(self, 'SENTENCE', parent) as current:
            current.src += 'SENTENCE'
            return current
    SENTENCE.min_size = RuleSize(0, 0)

    def REMAINDER(self, parent=None):
        with UnlexerRuleContext(self, 'REMAINDER', parent) as current:
            current.src += 'REMAINDER'
            return current
    REMAINDER.min_size = RuleSize(0, 0)

    def LOOP(self, parent=None):
        with UnlexerRuleContext(self, 'LOOP', parent) as current:
            current.src += 'LOOP'
            return current
    LOOP.min_size = RuleSize(0, 0)

    def VARYING(self, parent=None):
        with UnlexerRuleContext(self, 'VARYING', parent) as current:
            current.src += 'VARYING'
            return current
    VARYING.min_size = RuleSize(0, 0)

    def WHILE(self, parent=None):
        with UnlexerRuleContext(self, 'WHILE', parent) as current:
            current.src += 'WHILE'
            return current
    WHILE.min_size = RuleSize(0, 0)

    def UNTIL(self, parent=None):
        with UnlexerRuleContext(self, 'UNTIL', parent) as current:
            current.src += 'UNTIL'
            return current
    UNTIL.min_size = RuleSize(0, 0)

    def OF(self, parent=None):
        with UnlexerRuleContext(self, 'OF', parent) as current:
            current.src += 'OF'
            return current
    OF.min_size = RuleSize(0, 0)

    def THROUGH(self, parent=None):
        with UnlexerRuleContext(self, 'THROUGH', parent) as current:
            current.src += 'THROUGH'
            return current
    THROUGH.min_size = RuleSize(0, 0)

    def PICTURE(self, parent=None):
        with UnlexerRuleContext(self, 'PICTURE', parent) as current:
            current.src += 'PICTURE'
            return current
    PICTURE.min_size = RuleSize(0, 0)

    def IS(self, parent=None):
        with UnlexerRuleContext(self, 'IS', parent) as current:
            current.src += 'IS'
            return current
    IS.min_size = RuleSize(0, 0)

    def LIKE(self, parent=None):
        with UnlexerRuleContext(self, 'LIKE', parent) as current:
            current.src += 'LIKE'
            return current
    LIKE.min_size = RuleSize(0, 0)

    def OCCURS(self, parent=None):
        with UnlexerRuleContext(self, 'OCCURS', parent) as current:
            current.src += 'OCCURS'
            return current
    OCCURS.min_size = RuleSize(0, 0)

    def GO(self, parent=None):
        with UnlexerRuleContext(self, 'GO', parent) as current:
            current.src += 'GO'
            return current
    GO.min_size = RuleSize(0, 0)

    def SPACES(self, parent=None):
        with UnlexerRuleContext(self, 'SPACES', parent) as current:
            current.src += 'SPACES'
            return current
    SPACES.min_size = RuleSize(0, 0)

    def HIGH(self, parent=None):
        with UnlexerRuleContext(self, 'HIGH', parent) as current:
            current.src += 'HIGH-VALUES'
            return current
    HIGH.min_size = RuleSize(0, 0)

    def LOW(self, parent=None):
        with UnlexerRuleContext(self, 'LOW', parent) as current:
            current.src += 'LOW-VALUES'
            return current
    LOW.min_size = RuleSize(0, 0)

    def SIGNAL(self, parent=None):
        with UnlexerRuleContext(self, 'SIGNAL', parent) as current:
            current.src += 'SIGNAL'
            return current
    SIGNAL.min_size = RuleSize(0, 0)

    def ONERROR(self, parent=None):
        with UnlexerRuleContext(self, 'ONERROR', parent) as current:
            current.src += 'ON ERROR'
            return current
    ONERROR.min_size = RuleSize(0, 0)

    def OFF(self, parent=None):
        with UnlexerRuleContext(self, 'OFF', parent) as current:
            current.src += 'OFF'
            return current
    OFF.min_size = RuleSize(0, 0)

    def ALTER(self, parent=None):
        with UnlexerRuleContext(self, 'ALTER', parent) as current:
            current.src += 'ALTER'
            return current
    ALTER.min_size = RuleSize(0, 0)

    def PROCEED(self, parent=None):
        with UnlexerRuleContext(self, 'PROCEED', parent) as current:
            current.src += 'PROCEED'
            return current
    PROCEED.min_size = RuleSize(0, 0)

    def CALL(self, parent=None):
        with UnlexerRuleContext(self, 'CALL', parent) as current:
            current.src += 'CALL'
            return current
    CALL.min_size = RuleSize(0, 0)

    def RETURNING(self, parent=None):
        with UnlexerRuleContext(self, 'RETURNING', parent) as current:
            current.src += 'RETURNING'
            return current
    RETURNING.min_size = RuleSize(0, 0)

    def BYVALUE(self, parent=None):
        with UnlexerRuleContext(self, 'BYVALUE', parent) as current:
            current.src += 'BY VALUE'
            return current
    BYVALUE.min_size = RuleSize(0, 0)

    def BYREFERENCE(self, parent=None):
        with UnlexerRuleContext(self, 'BYREFERENCE', parent) as current:
            current.src += 'BY REFERENCE'
            return current
    BYREFERENCE.min_size = RuleSize(0, 0)

    def RETURNINGBYREFERENCE(self, parent=None):
        with UnlexerRuleContext(self, 'RETURNINGBYREFERENCE', parent) as current:
            self._reserve(1, self.RETURNING, parent=current)
            self.BYREFERENCE(parent=current)
            return current
    RETURNINGBYREFERENCE.min_size = RuleSize(1, 2)

    def USING(self, parent=None):
        with UnlexerRuleContext(self, 'USING', parent) as current:
            current.src += 'USING'
            return current
    USING.min_size = RuleSize(0, 0)

    def AS(self, parent=None):
        with UnlexerRuleContext(self, 'AS', parent) as current:
            current.src += 'AS'
            return current
    AS.min_size = RuleSize(0, 0)

    def NEQ(self, parent=None):
        with UnlexerRuleContext(self, 'NEQ', parent) as current:
            current.src += '!='
            return current
    NEQ.min_size = RuleSize(0, 0)

    def LTE(self, parent=None):
        with UnlexerRuleContext(self, 'LTE', parent) as current:
            current.src += '<='
            return current
    LTE.min_size = RuleSize(0, 0)

    def LT(self, parent=None):
        with UnlexerRuleContext(self, 'LT', parent) as current:
            current.src += '<'
            return current
    LT.min_size = RuleSize(0, 0)

    def EQ(self, parent=None):
        with UnlexerRuleContext(self, 'EQ', parent) as current:
            current.src += '='
            return current
    EQ.min_size = RuleSize(0, 0)

    def GT(self, parent=None):
        with UnlexerRuleContext(self, 'GT', parent) as current:
            current.src += '>'
            return current
    GT.min_size = RuleSize(0, 0)

    def GTE(self, parent=None):
        with UnlexerRuleContext(self, 'GTE', parent) as current:
            current.src += '>='
            return current
    GTE.min_size = RuleSize(0, 0)

    def SYMBOL_PLUS(self, parent=None):
        with UnlexerRuleContext(self, 'SYMBOL_PLUS', parent) as current:
            current.src += '+'
            return current
    SYMBOL_PLUS.min_size = RuleSize(0, 0)

    def SYMBOL_MINUS(self, parent=None):
        with UnlexerRuleContext(self, 'SYMBOL_MINUS', parent) as current:
            current.src += '-'
            return current
    SYMBOL_MINUS.min_size = RuleSize(0, 0)

    def SYMBOL_MULT(self, parent=None):
        with UnlexerRuleContext(self, 'SYMBOL_MULT', parent) as current:
            current.src += '*'
            return current
    SYMBOL_MULT.min_size = RuleSize(0, 0)

    def SYMBOL_DIV(self, parent=None):
        with UnlexerRuleContext(self, 'SYMBOL_DIV', parent) as current:
            current.src += '/'
            return current
    SYMBOL_DIV.min_size = RuleSize(0, 0)

    def SYMBOL_EXP(self, parent=None):
        with UnlexerRuleContext(self, 'SYMBOL_EXP', parent) as current:
            current.src += '**'
            return current
    SYMBOL_EXP.min_size = RuleSize(0, 0)

    def WS(self, parent=None):
        with UnlexerRuleContext(self, 'WS', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[1])
            return current
    WS.min_size = RuleSize(0, 0)

    def FUNCTIONNAME(self, parent=None):
        with UnlexerRuleContext(self, 'FUNCTIONNAME', parent) as current:
            current.src += '\''
            self.IDENTIFIER(parent=current)
            current.src += '\''
            return current
    FUNCTIONNAME.min_size = RuleSize(1, 1)

    def MASK(self, parent=None):
        with UnlexerRuleContext(self, 'MASK', parent) as current:
            with QuantifierContext(self, 0, 0, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[2])
            return current
    MASK.min_size = RuleSize(0, 0)

    def LEVEL(self, parent=None):
        with UnlexerRuleContext(self, 'LEVEL', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[3])
            current.src += self._model.charset(current, 1, self._charsets[3])
            return current
    LEVEL.min_size = RuleSize(0, 0)

    def INT(self, parent=None):
        with UnlexerRuleContext(self, 'INT', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[3])
            return current
    INT.min_size = RuleSize(0, 0)

    def DOUBLE(self, parent=None):
        with UnlexerRuleContext(self, 'DOUBLE', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(0, 0), 2) as quant0:
                while quant0(current):
                    with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                        current.src += ['-', '+'][alt0(current)]
            self._reserve(1, self.INT, parent=current)
            current.src += ','
            self.INT(parent=current)
            return current
    DOUBLE.min_size = RuleSize(1, 2)

    def LITERAL(self, parent=None):
        with UnlexerRuleContext(self, 'LITERAL', parent) as current:
            current.src += '"'
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[4])
            current.src += '"'
            return current
    LITERAL.min_size = RuleSize(0, 0)

    def DOT(self, parent=None):
        with UnlexerRuleContext(self, 'DOT', parent) as current:
            current.src += '.'
            return current
    DOT.min_size = RuleSize(0, 0)

    def IDENTIFIER(self, parent=None):
        with UnlexerRuleContext(self, 'IDENTIFIER', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[5])
            with QuantifierContext(self, 1, 0, inf, RuleSize(0, 0), 0) as quant1:
                while quant1(current):
                    with QuantifierContext(self, 2, 1, inf, RuleSize(0, 0), 0) as quant2:
                        while quant2(current):
                            current.src += self._model.charset(current, 1, self._charsets[6])
                    with QuantifierContext(self, 3, 1, inf, RuleSize(0, 0), 0) as quant3:
                        while quant3(current):
                            current.src += self._model.charset(current, 2, self._charsets[5])
            return current
    IDENTIFIER.min_size = RuleSize(0, 0)

    def COMMENTLINE(self, parent=None):
        with UnlexerRuleContext(self, 'COMMENTLINE', parent) as current:
            current.src += '*'
            with QuantifierContext(self, 0, 0, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[0])
            return current
    COMMENTLINE.min_size = RuleSize(0, 0)

    def arithmeticExpression_atomicArithmeticExp(self, parent=None):
        with UnparserRuleContext(self, 'arithmeticExpression_atomicArithmeticExp', parent) as current:
            self.atomic(parent=current)
            return current
    arithmeticExpression_atomicArithmeticExp.min_size = RuleSize(3, 1)

    def arithmeticExpression_arithOpArithmeticExp(self, parent=None):
        local_ctx = dict(left=None, right=None)
        with UnparserRuleContext(self, 'arithmeticExpression_arithOpArithmeticExp', parent) as current:
            self._reserve(2, self.arithmeticExpression, parent=current)
            local_ctx['left'] = current.last_child
            self._reserve(1, self.arithmeticOp, parent=current)
            self.arithmeticExpression(parent=current)
            local_ctx['right'] = current.last_child
            return current
    arithmeticExpression_arithOpArithmeticExp.min_size = RuleSize(5, 3)

    def stringExpression_atomicStringExp(self, parent=None):
        with UnparserRuleContext(self, 'stringExpression_atomicStringExp', parent) as current:
            self.atomic(parent=current)
            return current
    stringExpression_atomicStringExp.min_size = RuleSize(3, 1)

    def stringExpression_additionStringExp(self, parent=None):
        local_ctx = dict(left=None, right=None)
        with UnparserRuleContext(self, 'stringExpression_additionStringExp', parent) as current:
            self._reserve(2, self.stringExpression, parent=current)
            local_ctx['left'] = current.last_child
            self._reserve(1, self.SYMBOL_PLUS, parent=current)
            self.stringExpression(parent=current)
            local_ctx['right'] = current.last_child
            return current
    stringExpression_additionStringExp.min_size = RuleSize(5, 3)

    def booleanExpression_trueBooleanExp(self, parent=None):
        with UnparserRuleContext(self, 'booleanExpression_trueBooleanExp', parent) as current:
            self.TRUE(parent=current)
            return current
    booleanExpression_trueBooleanExp.min_size = RuleSize(1, 1)

    def booleanExpression_falseBooleanExp(self, parent=None):
        with UnparserRuleContext(self, 'booleanExpression_falseBooleanExp', parent) as current:
            self.FALSE(parent=current)
            return current
    booleanExpression_falseBooleanExp.min_size = RuleSize(1, 1)

    def booleanExpression_contractedBooleanExp(self, parent=None):
        local_ctx = dict(left=None, right=None, contract=[])
        with UnparserRuleContext(self, 'booleanExpression_contractedBooleanExp', parent) as current:
            self._reserve(4, self.atomic, parent=current)
            local_ctx['left'] = current.last_child
            self._reserve(3, self.comparisonOp, parent=current)
            self._reserve(2, self.arithmeticExpression, parent=current)
            local_ctx['right'] = current.last_child
            with QuantifierContext(self, 0, 1, inf, RuleSize(6, 2), 0) as quant0:
                while quant0(current):
                    self.contractedBooleanPart(parent=current)
                    local_ctx['contract'].append(current.last_child)
            return current
    booleanExpression_contractedBooleanExp.min_size = RuleSize(6, 5)

    def booleanExpression_compareOpBooleanExp(self, parent=None):
        local_ctx = dict(left=None, right=None)
        with UnparserRuleContext(self, 'booleanExpression_compareOpBooleanExp', parent) as current:
            self._reserve(2, self.arithmeticExpression, parent=current)
            local_ctx['left'] = current.last_child
            self._reserve(1, self.comparisonOp, parent=current)
            self.arithmeticExpression(parent=current)
            local_ctx['right'] = current.last_child
            return current
    booleanExpression_compareOpBooleanExp.min_size = RuleSize(5, 3)

    def booleanExpression_notBooleanExp(self, parent=None):
        with UnparserRuleContext(self, 'booleanExpression_notBooleanExp', parent) as current:
            self._reserve(1, self.NOT, parent=current)
            self.booleanExpression(parent=current)
            return current
    booleanExpression_notBooleanExp.min_size = RuleSize(3, 2)

    def booleanExpression_boolOpBooleanExp(self, parent=None):
        local_ctx = dict(left=None, right=None)
        with UnparserRuleContext(self, 'booleanExpression_boolOpBooleanExp', parent) as current:
            self._reserve(2, self.booleanExpression, parent=current)
            local_ctx['left'] = current.last_child
            self._reserve(1, self.booleanOp, parent=current)
            self.booleanExpression(parent=current)
            local_ctx['right'] = current.last_child
            return current
    booleanExpression_boolOpBooleanExp.min_size = RuleSize(3, 3)

    def loopExpression_varyingLoopExp(self, parent=None):
        local_ctx = dict(id=None, frm=None, to=None, by=None)
        with UnparserRuleContext(self, 'loopExpression_varyingLoopExp', parent) as current:
            self.VARYING(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 1), 0) as quant0:
                while quant0(current):
                    self.identifiers(parent=current)
                    local_ctx['id'] = current.last_child
            with QuantifierContext(self, 1, 0, 1, RuleSize(3, 2), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.FROM, parent=current)
                    self.atomic(parent=current)
                    local_ctx['frm'] = current.last_child
            with QuantifierContext(self, 2, 0, 1, RuleSize(3, 2), 0) as quant2:
                while quant2(current):
                    self._reserve(1, self.TO, parent=current)
                    self.atomic(parent=current)
                    local_ctx['to'] = current.last_child
            with QuantifierContext(self, 3, 0, 1, RuleSize(3, 2), 0) as quant3:
                while quant3(current):
                    self._reserve(1, self.BY, parent=current)
                    self.atomic(parent=current)
                    local_ctx['by'] = current.last_child
            return current
    loopExpression_varyingLoopExp.min_size = RuleSize(1, 1)

    def loopExpression_whileLoopExp(self, parent=None):
        with UnparserRuleContext(self, 'loopExpression_whileLoopExp', parent) as current:
            self._reserve(1, self.WHILE, parent=current)
            self.booleanExpression(parent=current)
            return current
    loopExpression_whileLoopExp.min_size = RuleSize(3, 2)

    def loopExpression_untilLoopExp(self, parent=None):
        with UnparserRuleContext(self, 'loopExpression_untilLoopExp', parent) as current:
            self._reserve(1, self.UNTIL, parent=current)
            self.booleanExpression(parent=current)
            return current
    loopExpression_untilLoopExp.min_size = RuleSize(3, 2)

    def whenBlock_whenAnyExpression(self, parent=None):
        with UnparserRuleContext(self, 'whenBlock_whenAnyExpression', parent) as current:
            self._reserve(2, self.WHEN, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(4, 1), 1) as quant0:
                while quant0(current):
                    self.anyExpression(parent=current)
            with QuantifierContext(self, 1, 1, inf, RuleSize(3, 1), 0) as quant1:
                while quant1(current):
                    self.statement(parent=current)
            return current
    whenBlock_whenAnyExpression.min_size = RuleSize(4, 3)

    def whenBlock_whenOther(self, parent=None):
        with UnparserRuleContext(self, 'whenBlock_whenOther', parent) as current:
            self._reserve(2, self.WHEN, parent=current)
            self._reserve(1, self.OTHER, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.statement(parent=current)
            return current
    whenBlock_whenOther.min_size = RuleSize(3, 3)

    def atomic_intLiteral(self, parent=None):
        with UnparserRuleContext(self, 'atomic_intLiteral', parent) as current:
            self.int(parent=current)
            return current
    atomic_intLiteral.min_size = RuleSize(2, 1)

    def atomic_doubleLiteral(self, parent=None):
        with UnparserRuleContext(self, 'atomic_doubleLiteral', parent) as current:
            self.DOUBLE(parent=current)
            return current
    atomic_doubleLiteral.min_size = RuleSize(2, 3)

    def atomic_stringLiteral(self, parent=None):
        with UnparserRuleContext(self, 'atomic_stringLiteral', parent) as current:
            self.LITERAL(parent=current)
            return current
    atomic_stringLiteral.min_size = RuleSize(1, 1)

    def atomic_identifier(self, parent=None):
        with UnparserRuleContext(self, 'atomic_identifier', parent) as current:
            self.identifiers(parent=current)
            return current
    atomic_identifier.min_size = RuleSize(2, 1)

    def T__0(self, parent=None):
        with UnlexerRuleContext(self, 'T__0', parent) as current:
            current.src += '('
            return current
    T__0.min_size = RuleSize(0, 0)

    def T__1(self, parent=None):
        with UnlexerRuleContext(self, 'T__1', parent) as current:
            current.src += ')'
            return current
    T__1.min_size = RuleSize(0, 0)

    _default_rule = program

    _charsets = {
        0: list(itertools.chain.from_iterable([range(0x20, 0x7f)])),
        1: list(itertools.chain.from_iterable([range(0x9, 0xa), range(0xa, 0xb), range(0xc, 0xd), range(0xd, 0xe), range(0x20, 0x21)])),
        2: list(itertools.chain.from_iterable([range(0x39, 0x3a), range(0x41, 0x42), range(0x53, 0x54), range(0x56, 0x57), range(0x58, 0x59)])),
        3: list(itertools.chain.from_iterable([range(0x30, 0x3a)])),
        4: list(itertools.chain.from_iterable([range(0x20, 0x22), range(0x23, 0x7f)])),
        5: list(itertools.chain.from_iterable([range(0x30, 0x3a), range(0x41, 0x5b), range(0x61, 0x7b)])),
        6: list(itertools.chain.from_iterable([range(0x2d, 0x2e), range(0x5f, 0x60)])),
    }
