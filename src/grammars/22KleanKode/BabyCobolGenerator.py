# Generated by Grammarinator 23.7.post31+g3f15e2c.d20231108

import itertools

from math import inf
from grammarinator.runtime import *

class BabyCobolGenerator(Generator):


    def EOF(self, parent=None):
        pass
    EOF.min_size = RuleSize(0, 0)

    def program(self, parent=None):
        with UnparserRuleContext(self, 'program', parent) as current:
            self._reserve(6, self.identification_division, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 3), 6) as quant0:
                while quant0(current):
                    self.data_division(parent=current)
            self._reserve(1, self.procedure_division, parent=current)
            self.EOF(parent=current)
            return current
    program.min_size = RuleSize(5, 9)

    def identification_division(self, parent=None):
        with UnparserRuleContext(self, 'identification_division', parent) as current:
            self._reserve(2, self.IDENTIFICATION, parent=current)
            self._reserve(1, self.DIVISION, parent=current)
            self.DOT(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(2, 5), 0) as quant0:
                while quant0(current):
                    self._reserve(3, self.IDENTIFIER, parent=current)
                    self._reserve(2, self.DOT, parent=current)
                    self._reserve(1, self.LITERAL, parent=current)
                    self.DOT(parent=current)
            return current
    identification_division.min_size = RuleSize(1, 3)

    def data_division(self, parent=None):
        with UnparserRuleContext(self, 'data_division', parent) as current:
            self._reserve(2, self.DATA, parent=current)
            self._reserve(1, self.DIVISION, parent=current)
            self.DOT(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(4, 5), 0) as quant0:
                while quant0(current):
                    self.variable(parent=current)
            return current
    data_division.min_size = RuleSize(1, 3)

    def variable(self, parent=None):
        with UnparserRuleContext(self, 'variable', parent) as current:
            self._reserve(3, self.level, parent=current)
            self._reserve(1, self.IDENTIFIER, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(3, 3), 1) as quant0:
                while quant0(current):
                    with AlternationContext(self, 0, (RuleSize(3, 4), RuleSize(4, 3)), 0, (1, 1)) as alt0:
                        [self.picture, self.like][alt0(current)](parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(3, 4), 1) as quant1:
                while quant1(current):
                    self.occurs(parent=current)
            self.DOT(parent=current)
            return current
    variable.min_size = RuleSize(3, 5)

    def level(self, parent=None):
        with UnparserRuleContext(self, 'level', parent) as current:
            self.INT(parent=current)
            return current
    level.min_size = RuleSize(2, 2)

    def picture(self, parent=None):
        with UnparserRuleContext(self, 'picture', parent) as current:
            self._reserve(3, self.PICTURE, parent=current)
            self._reserve(2, self.IS, parent=current)
            self.REPRESENTATION(parent=current)
            return current
    picture.min_size = RuleSize(2, 4)

    def like(self, parent=None):
        with UnparserRuleContext(self, 'like', parent) as current:
            self._reserve(2, self.LIKE, parent=current)
            self.identifiers(parent=current)
            return current
    like.min_size = RuleSize(3, 3)

    def occurs(self, parent=None):
        with UnparserRuleContext(self, 'occurs', parent) as current:
            self._reserve(3, self.OCCURS, parent=current)
            self._reserve(1, self.INT, parent=current)
            self.TIMES(parent=current)
            return current
    occurs.min_size = RuleSize(2, 4)

    def procedure_division(self, parent=None):
        with UnparserRuleContext(self, 'procedure_division', parent) as current:
            self._reserve(4, self.PROCEDURE, parent=current)
            self._reserve(3, self.DIVISION, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(4, 4), 3) as quant0:
                while quant0(current):
                    self.using(parent=current)
            self._reserve(2, self.DOT, parent=current)
            with QuantifierContext(self, 1, 1, inf, RuleSize(4, 2), 0) as quant1:
                while quant1(current):
                    self.sentence(parent=current)
            return current
    procedure_division.min_size = RuleSize(4, 5)

    def using(self, parent=None):
        with UnparserRuleContext(self, 'using', parent) as current:
            self._reserve(3, self.USING, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 3), 0) as quant0:
                while quant0(current):
                    self.using_expression(parent=current)
            return current
    using.min_size = RuleSize(3, 4)

    def using_expression(self, parent=None):
        with UnparserRuleContext(self, 'using_expression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 4), RuleSize(2, 3), RuleSize(2, 3)), 0, (1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self._reserve(3, self.BY, parent=current)
                    self._reserve(2, self.REFERENCE, parent=current)
                    self.identifiers(parent=current)
                elif choice0 == 1:
                    self._reserve(2, self.BY, parent=current)
                    self._reserve(1, self.CONTENT, parent=current)
                    self.atomic(parent=current)
                elif choice0 == 2:
                    self._reserve(2, self.BY, parent=current)
                    self._reserve(1, self.VALUE, parent=current)
                    self.atomic(parent=current)
            return current
    using_expression.min_size = RuleSize(2, 3)

    def sentence(self, parent=None):
        with UnparserRuleContext(self, 'sentence', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(3, 3), 2) as quant0:
                while quant0(current):
                    self._reserve(1, self.procname, parent=current)
                    self.DOT(parent=current)
            with QuantifierContext(self, 1, 1, inf, RuleSize(3, 1), 1) as quant1:
                while quant1(current):
                    self.statement(parent=current)
            self.DOT(parent=current)
            return current
    sentence.min_size = RuleSize(3, 2)

    def procname(self, parent=None):
        with UnparserRuleContext(self, 'procname', parent) as current:
            self.IDENTIFIER(parent=current)
            return current
    procname.min_size = RuleSize(2, 2)

    def filename(self, parent=None):
        with UnparserRuleContext(self, 'filename', parent) as current:
            self.IDENTIFIER(parent=current)
            return current
    filename.min_size = RuleSize(2, 2)

    def statement(self, parent=None):
        with UnparserRuleContext(self, 'statement', parent) as current:
            with AlternationContext(self, 0, (RuleSize(4, 3), RuleSize(4, 6), RuleSize(4, 6), RuleSize(4, 6), RuleSize(4, 6), RuleSize(4, 3), RuleSize(3, 4), RuleSize(3, 2), RuleSize(2, 1), RuleSize(4, 5), RuleSize(4, 3), RuleSize(2, 2), RuleSize(5, 5), RuleSize(2, 2), RuleSize(3, 4), RuleSize(4, 6), RuleSize(2, 2), RuleSize(4, 4)), 0, (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)) as alt0:
                [self.accept, self.add, self.subtract, self.divide, self.multiply, self.perform, self.signal, self.display, self.stop, self.if_statement, self.evaluate, self.next_sentence, self.move, self.loop, self.goto, self.alter, self.copy, self.call][alt0(current)](parent=current)
            return current
    statement.min_size = RuleSize(2, 1)

    def accept(self, parent=None):
        with UnparserRuleContext(self, 'accept', parent) as current:
            self._reserve(2, self.ACCEPT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 2), 0) as quant0:
                while quant0(current):
                    self.identifiers(parent=current)
            return current
    accept.min_size = RuleSize(3, 3)

    def add(self, parent=None):
        local_ctx = dict(additions=[], base=None)
        with UnparserRuleContext(self, 'add', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 6), RuleSize(4, 9)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self._reserve(5, self.ADD, parent=current)
                    with QuantifierContext(self, 0, 1, inf, RuleSize(2, 2), 3) as quant0:
                        while quant0(current):
                            self.INT(parent=current)
                            local_ctx['additions'].append(current.last_child)
                    self._reserve(2, self.TO, parent=current)
                    self.identifiers(parent=current)
                elif choice0 == 1:
                    self._reserve(8, self.ADD, parent=current)
                    with QuantifierContext(self, 1, 1, inf, RuleSize(2, 2), 6) as quant1:
                        while quant1(current):
                            self.INT(parent=current)
                            local_ctx['additions'].append(current.last_child)
                    self._reserve(5, self.TO, parent=current)
                    self._reserve(3, self.INT, parent=current)
                    local_ctx['base'] = current.last_child
                    self.giving(parent=current)
            return current
    add.min_size = RuleSize(3, 6)

    def subtract(self, parent=None):
        local_ctx = dict(subtractors=[], base=None)
        with UnparserRuleContext(self, 'subtract', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 6), RuleSize(4, 9)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self._reserve(5, self.SUBTRACT, parent=current)
                    with QuantifierContext(self, 0, 1, inf, RuleSize(2, 2), 3) as quant0:
                        while quant0(current):
                            self.INT(parent=current)
                            local_ctx['subtractors'].append(current.last_child)
                    self._reserve(2, self.FROM, parent=current)
                    self.identifiers(parent=current)
                elif choice0 == 1:
                    self._reserve(8, self.SUBTRACT, parent=current)
                    with QuantifierContext(self, 1, 1, inf, RuleSize(2, 2), 6) as quant1:
                        while quant1(current):
                            self.INT(parent=current)
                            local_ctx['subtractors'].append(current.last_child)
                    self._reserve(5, self.FROM, parent=current)
                    self._reserve(3, self.INT, parent=current)
                    local_ctx['base'] = current.last_child
                    self.giving(parent=current)
            return current
    subtract.min_size = RuleSize(3, 6)

    def divide(self, parent=None):
        local_ctx = dict(divisor=None, base=None)
        with UnparserRuleContext(self, 'divide', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 6), RuleSize(4, 9), RuleSize(4, 12)), 0, (1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self._reserve(5, self.DIVIDE, parent=current)
                    self._reserve(3, self.INT, parent=current)
                    local_ctx['divisor'] = current.last_child
                    self._reserve(2, self.INTO, parent=current)
                    with QuantifierContext(self, 0, 1, inf, RuleSize(3, 2), 0) as quant0:
                        while quant0(current):
                            self.identifiers(parent=current)
                elif choice0 == 1:
                    self._reserve(8, self.DIVIDE, parent=current)
                    self._reserve(6, self.INT, parent=current)
                    local_ctx['divisor'] = current.last_child
                    self._reserve(5, self.INTO, parent=current)
                    self._reserve(3, self.INT, parent=current)
                    local_ctx['base'] = current.last_child
                    self.giving(parent=current)
                elif choice0 == 2:
                    self._reserve(11, self.DIVIDE, parent=current)
                    self._reserve(9, self.INT, parent=current)
                    local_ctx['divisor'] = current.last_child
                    self._reserve(8, self.INTO, parent=current)
                    self._reserve(6, self.INT, parent=current)
                    local_ctx['base'] = current.last_child
                    self._reserve(3, self.giving, parent=current)
                    self.remainder(parent=current)
            return current
    divide.min_size = RuleSize(3, 6)

    def multiply(self, parent=None):
        local_ctx = dict(multiplier=None, base=None)
        with UnparserRuleContext(self, 'multiply', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 6), RuleSize(4, 9)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self._reserve(5, self.MULTIPLY, parent=current)
                    self._reserve(3, self.INT, parent=current)
                    local_ctx['multiplier'] = current.last_child
                    self._reserve(2, self.BY, parent=current)
                    with QuantifierContext(self, 0, 1, inf, RuleSize(3, 2), 0) as quant0:
                        while quant0(current):
                            self.identifiers(parent=current)
                elif choice0 == 1:
                    self._reserve(8, self.MULTIPLY, parent=current)
                    self._reserve(6, self.INT, parent=current)
                    local_ctx['multiplier'] = current.last_child
                    self._reserve(5, self.BY, parent=current)
                    self._reserve(3, self.INT, parent=current)
                    local_ctx['base'] = current.last_child
                    self.giving(parent=current)
            return current
    multiply.min_size = RuleSize(3, 6)

    def perform(self, parent=None):
        with UnparserRuleContext(self, 'perform', parent) as current:
            self._reserve(2, self.PERFORM, parent=current)
            self.procname(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(4, 3), 0) as quant0:
                while quant0(current):
                    self.through(parent=current)
            return current
    perform.min_size = RuleSize(3, 3)

    def through(self, parent=None):
        with UnparserRuleContext(self, 'through', parent) as current:
            self._reserve(2, self.THROUGH, parent=current)
            self.procname(parent=current)
            return current
    through.min_size = RuleSize(3, 3)

    def signal(self, parent=None):
        with UnparserRuleContext(self, 'signal', parent) as current:
            self._reserve(3, self.SIGNAL, parent=current)
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(3, 2)), 2, (1, 1)) as alt0:
                [self.off, self.procname][alt0(current)](parent=current)
            self._reserve(1, self.ON, parent=current)
            self.ERROR(parent=current)
            return current
    signal.min_size = RuleSize(2, 4)

    def off(self, parent=None):
        with UnparserRuleContext(self, 'off', parent) as current:
            self.OFF(parent=current)
            return current
    off.min_size = RuleSize(1, 1)

    def display(self, parent=None):
        with UnparserRuleContext(self, 'display', parent) as current:
            self._reserve(1, self.DISPLAY, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(2, 1), 0) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 3), 0) as quant1:
                while quant1(current):
                    self.withnoadvancing(parent=current)
            return current
    display.min_size = RuleSize(2, 2)

    def stop(self, parent=None):
        with UnparserRuleContext(self, 'stop', parent) as current:
            self.STOP(parent=current)
            return current
    stop.min_size = RuleSize(1, 1)

    def if_statement(self, parent=None):
        local_ctx = dict(i=[], e=[])
        with UnparserRuleContext(self, 'if_statement', parent) as current:
            self._reserve(4, self.IF, parent=current)
            self._reserve(3, self.boolean_expression, parent=current)
            self._reserve(2, self.THEN, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 1) as quant0:
                while quant0(current):
                    self.statement(parent=current)
                    local_ctx['i'].append(current.last_child)
            with QuantifierContext(self, 1, 0, 1, RuleSize(3, 2), 1) as quant1:
                while quant1(current):
                    self._reserve(1, self.ELSE, parent=current)
                    with QuantifierContext(self, 2, 1, inf, RuleSize(3, 1), 0) as quant2:
                        while quant2(current):
                            self.statement(parent=current)
                            local_ctx['e'].append(current.last_child)
            self.END(parent=current)
            return current
    if_statement.min_size = RuleSize(3, 5)

    def evaluate(self, parent=None):
        with UnparserRuleContext(self, 'evaluate', parent) as current:
            self._reserve(2, self.EVALUATE, parent=current)
            self._reserve(1, self.any_expression, parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(4, 3), 1) as quant0:
                while quant0(current):
                    self.when_block(parent=current)
            self.END(parent=current)
            return current
    evaluate.min_size = RuleSize(3, 3)

    def next_sentence(self, parent=None):
        with UnparserRuleContext(self, 'next_sentence', parent) as current:
            self._reserve(1, self.NEXT, parent=current)
            self.SENTENCE(parent=current)
            return current
    next_sentence.min_size = RuleSize(1, 2)

    def loop(self, parent=None):
        with UnparserRuleContext(self, 'loop', parent) as current:
            self._reserve(1, self.LOOP, parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(3, 1), 1) as quant0:
                while quant0(current):
                    self.loop_expression(parent=current)
            self.END(parent=current)
            return current
    loop.min_size = RuleSize(1, 2)

    def goto(self, parent=None):
        with UnparserRuleContext(self, 'goto', parent) as current:
            self._reserve(3, self.GO, parent=current)
            self._reserve(2, self.TO, parent=current)
            self.IDENTIFIER(parent=current)
            return current
    goto.min_size = RuleSize(2, 4)

    def alter(self, parent=None):
        with UnparserRuleContext(self, 'alter', parent) as current:
            self._reserve(5, self.T__0, parent=current)
            self._reserve(3, self.procname, parent=current)
            self._reserve(2, self.T__1, parent=current)
            self.procname(parent=current)
            return current
    alter.min_size = RuleSize(3, 6)

    def copy(self, parent=None):
        with UnparserRuleContext(self, 'copy', parent) as current:
            self._reserve(1, self.T__2, parent=current)
            self.LITERAL(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(3, 4), 0) as quant0:
                while quant0(current):
                    self.replacing(parent=current)
            return current
    copy.min_size = RuleSize(1, 2)

    def call(self, parent=None):
        with UnparserRuleContext(self, 'call', parent) as current:
            self._reserve(3, self.CALL, parent=current)
            self._reserve(1, self.filename, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(4, 4), 1) as quant0:
                while quant0(current):
                    self.using(parent=current)
            self.DOT(parent=current)
            return current
    call.min_size = RuleSize(3, 4)

    def replacing(self, parent=None):
        with UnparserRuleContext(self, 'replacing', parent) as current:
            self._reserve(3, self.T__3, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(2, 3), 0) as quant0:
                while quant0(current):
                    self.replacements(parent=current)
            return current
    replacing.min_size = RuleSize(2, 4)

    def replacements(self, parent=None):
        with UnparserRuleContext(self, 'replacements', parent) as current:
            self._reserve(2, self.COPY_LITERAL, parent=current)
            self._reserve(1, self.T__4, parent=current)
            self.COPY_LITERAL(parent=current)
            return current
    replacements.min_size = RuleSize(1, 3)

    def move(self, parent=None):
        with UnparserRuleContext(self, 'move', parent) as current:
            self._reserve(4, self.MOVE, parent=current)
            with AlternationContext(self, 0, (RuleSize(2, 2), RuleSize(4, 2), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 3, (1, 1, 1, 1, 1)) as alt0:
                [self.INT, self.singlevar, self.SPACES, self.HIGH_VALUES, self.LOW_VALUES][alt0(current)](parent=current)
            self._reserve(2, self.TO, parent=current)
            self.multivar(parent=current)
            return current
    move.min_size = RuleSize(4, 5)

    def multivar(self, parent=None):
        with UnparserRuleContext(self, 'multivar', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 2), 0) as quant0:
                while quant0(current):
                    self.identifiers(parent=current)
            return current
    multivar.min_size = RuleSize(3, 2)

    def singlevar(self, parent=None):
        with UnparserRuleContext(self, 'singlevar', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 2), 0) as quant0:
                while quant0(current):
                    self.identifiers(parent=current)
            return current
    singlevar.min_size = RuleSize(3, 2)

    def remainder(self, parent=None):
        with UnparserRuleContext(self, 'remainder', parent) as current:
            self._reserve(2, self.REMAINDER, parent=current)
            self.identifiers(parent=current)
            return current
    remainder.min_size = RuleSize(3, 3)

    def giving(self, parent=None):
        with UnparserRuleContext(self, 'giving', parent) as current:
            self._reserve(2, self.GIVING, parent=current)
            self.identifiers(parent=current)
            return current
    giving.min_size = RuleSize(3, 3)

    def withnoadvancing(self, parent=None):
        with UnparserRuleContext(self, 'withnoadvancing', parent) as current:
            self._reserve(2, self.WITH, parent=current)
            self._reserve(1, self.NO, parent=current)
            self.ADVANCING(parent=current)
            return current
    withnoadvancing.min_size = RuleSize(1, 3)

    def loop_expression(self, parent=None):
        with UnparserRuleContext(self, 'loop_expression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(3, 2), RuleSize(3, 2), RuleSize(4, 1)), 0, (1, 1, 1, 1)) as alt0:
                [self.loop_expression_loop_varying_expression, self.loop_expression_loop_while_expression, self.loop_expression_loop_until_expression, self.loop_expression_loop_statement_expession][alt0(current)](parent=current)
            return current
    loop_expression.min_size = RuleSize(2, 1)

    def any_expression(self, parent=None):
        with UnparserRuleContext(self, 'any_expression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 1), RuleSize(3, 1), RuleSize(2, 1)), 0, (1, 1, 1)) as alt0:
                [self.arithmetic_expression, self.string_expression, self.boolean_expression][alt0(current)](parent=current)
            return current
    any_expression.min_size = RuleSize(2, 1)

    def arithmetic_expression(self, parent=None):
        with UnparserRuleContext(self, 'arithmetic_expression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(3, 3)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.atomic(parent=current)
                elif choice0 == 1:
                    self._reserve(2, self.arithmetic_expression, parent=current)
                    self._reserve(1, self.ARITHMETIC_OPERATOR, parent=current)
                    self.arithmetic_expression(parent=current)
            return current
    arithmetic_expression.min_size = RuleSize(2, 1)

    def string_expression(self, parent=None):
        with UnparserRuleContext(self, 'string_expression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(3, 3)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.atomic(parent=current)
                elif choice0 == 1:
                    self._reserve(2, self.string_expression, parent=current)
                    self._reserve(1, self.T__5, parent=current)
                    self.string_expression(parent=current)
            return current
    string_expression.min_size = RuleSize(2, 1)

    def boolean_expression(self, parent=None):
        with UnparserRuleContext(self, 'boolean_expression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(3, 3), RuleSize(2, 2), RuleSize(2, 3)), 0, (1, 1, 1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.TRUE(parent=current)
                elif choice0 == 1:
                    self.FALSE(parent=current)
                elif choice0 == 2:
                    self._reserve(2, self.arithmetic_expression, parent=current)
                    self._reserve(1, self.COMPARISON_OPERATOR, parent=current)
                    self.arithmetic_expression(parent=current)
                elif choice0 == 3:
                    self._reserve(1, self.NOT, parent=current)
                    self.boolean_expression(parent=current)
                elif choice0 == 4:
                    self._reserve(2, self.boolean_expression, parent=current)
                    self._reserve(1, self.BOOLEAN_OPERATOR, parent=current)
                    self.boolean_expression(parent=current)
            return current
    boolean_expression.min_size = RuleSize(1, 1)

    def when_block(self, parent=None):
        with UnparserRuleContext(self, 'when_block', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 3), RuleSize(3, 3)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self._reserve(2, self.WHEN, parent=current)
                    self._reserve(1, self.atomic, parent=current)
                    with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                        while quant0(current):
                            self.statement(parent=current)
                elif choice0 == 1:
                    self._reserve(2, self.WHEN, parent=current)
                    self._reserve(1, self.OTHER, parent=current)
                    with QuantifierContext(self, 1, 1, inf, RuleSize(3, 1), 0) as quant1:
                        while quant1(current):
                            self.statement(parent=current)
            return current
    when_block.min_size = RuleSize(3, 3)

    def atomic(self, parent=None):
        with UnparserRuleContext(self, 'atomic', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 2), RuleSize(2, 2), RuleSize(1, 1)), 0, (1, 1, 1)) as alt0:
                [self.identifiers, self.INT, self.LITERAL][alt0(current)](parent=current)
            return current
    atomic.min_size = RuleSize(1, 1)

    def identifiers(self, parent=None):
        with UnparserRuleContext(self, 'identifiers', parent) as current:
            self.IDENTIFIER(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(2, 3), 0) as quant0:
                while quant0(current):
                    self._reserve(2, self.OF, parent=current)
                    self.IDENTIFIER(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 4), 0) as quant1:
                while quant1(current):
                    self._reserve(3, self.T__6, parent=current)
                    self._reserve(1, self.INT, parent=current)
                    self.T__7(parent=current)
            return current
    identifiers.min_size = RuleSize(2, 2)

    def REPRESENTATION(self, parent=None):
        with UnlexerRuleContext(self, 'REPRESENTATION', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.REPR(parent=current)
            return current
    REPRESENTATION.min_size = RuleSize(1, 1)

    def COMPARISON_OPERATOR(self, parent=None):
        with UnlexerRuleContext(self, 'COMPARISON_OPERATOR', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1, 1, 1, 1)) as alt0:
                current.src += ['=', '>', '<', '>=', '<='][alt0(current)]
            return current
    COMPARISON_OPERATOR.min_size = RuleSize(0, 0)

    def BOOLEAN_OPERATOR(self, parent=None):
        with UnlexerRuleContext(self, 'BOOLEAN_OPERATOR', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1, 1)) as alt0:
                current.src += ['OR', 'AND', 'XOR'][alt0(current)]
            return current
    BOOLEAN_OPERATOR.min_size = RuleSize(0, 0)

    def ARITHMETIC_OPERATOR(self, parent=None):
        with UnlexerRuleContext(self, 'ARITHMETIC_OPERATOR', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1, 1, 1, 1)) as alt0:
                current.src += ['+', '-', '*', '/', '**'][alt0(current)]
            return current
    ARITHMETIC_OPERATOR.min_size = RuleSize(0, 0)

    def ADD(self, parent=None):
        with UnlexerRuleContext(self, 'ADD', parent) as current:
            current.src += 'A'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'D'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'D'
            return current
    ADD.min_size = RuleSize(0, 0)

    def MOVE(self, parent=None):
        with UnlexerRuleContext(self, 'MOVE', parent) as current:
            current.src += 'M'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'O'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'V'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            return current
    MOVE.min_size = RuleSize(0, 0)

    def ACCEPT(self, parent=None):
        with UnlexerRuleContext(self, 'ACCEPT', parent) as current:
            current.src += 'A'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'C'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'C'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'P'
            with QuantifierContext(self, 4, 0, inf, RuleSize(1, 1), 0) as quant4:
                while quant4(current):
                    self.SPACE(parent=current)
            current.src += 'T'
            return current
    ACCEPT.min_size = RuleSize(0, 0)

    def DISPLAY(self, parent=None):
        with UnlexerRuleContext(self, 'DISPLAY', parent) as current:
            current.src += 'D'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'I'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'S'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'P'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'L'
            with QuantifierContext(self, 4, 0, inf, RuleSize(1, 1), 0) as quant4:
                while quant4(current):
                    self.SPACE(parent=current)
            current.src += 'A'
            with QuantifierContext(self, 5, 0, inf, RuleSize(1, 1), 0) as quant5:
                while quant5(current):
                    self.SPACE(parent=current)
            current.src += 'Y'
            return current
    DISPLAY.min_size = RuleSize(0, 0)

    def PERFORM(self, parent=None):
        with UnlexerRuleContext(self, 'PERFORM', parent) as current:
            current.src += 'P'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'R'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'F'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'O'
            with QuantifierContext(self, 4, 0, inf, RuleSize(1, 1), 0) as quant4:
                while quant4(current):
                    self.SPACE(parent=current)
            current.src += 'R'
            with QuantifierContext(self, 5, 0, inf, RuleSize(1, 1), 0) as quant5:
                while quant5(current):
                    self.SPACE(parent=current)
            current.src += 'M'
            return current
    PERFORM.min_size = RuleSize(0, 0)

    def STOP(self, parent=None):
        with UnlexerRuleContext(self, 'STOP', parent) as current:
            current.src += 'S'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'T'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'O'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'P'
            return current
    STOP.min_size = RuleSize(0, 0)

    def SUBTRACT(self, parent=None):
        with UnlexerRuleContext(self, 'SUBTRACT', parent) as current:
            current.src += 'S'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'U'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'B'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'T'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'R'
            with QuantifierContext(self, 4, 0, inf, RuleSize(1, 1), 0) as quant4:
                while quant4(current):
                    self.SPACE(parent=current)
            current.src += 'A'
            with QuantifierContext(self, 5, 0, inf, RuleSize(1, 1), 0) as quant5:
                while quant5(current):
                    self.SPACE(parent=current)
            current.src += 'C'
            with QuantifierContext(self, 6, 0, inf, RuleSize(1, 1), 0) as quant6:
                while quant6(current):
                    self.SPACE(parent=current)
            current.src += 'T'
            return current
    SUBTRACT.min_size = RuleSize(0, 0)

    def DIVIDE(self, parent=None):
        with UnlexerRuleContext(self, 'DIVIDE', parent) as current:
            current.src += 'D'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'I'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'V'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'I'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'D'
            with QuantifierContext(self, 4, 0, inf, RuleSize(1, 1), 0) as quant4:
                while quant4(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            return current
    DIVIDE.min_size = RuleSize(0, 0)

    def MULTIPLY(self, parent=None):
        with UnlexerRuleContext(self, 'MULTIPLY', parent) as current:
            current.src += 'M'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'U'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'L'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'T'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'I'
            with QuantifierContext(self, 4, 0, inf, RuleSize(1, 1), 0) as quant4:
                while quant4(current):
                    self.SPACE(parent=current)
            current.src += 'P'
            with QuantifierContext(self, 5, 0, inf, RuleSize(1, 1), 0) as quant5:
                while quant5(current):
                    self.SPACE(parent=current)
            current.src += 'L'
            with QuantifierContext(self, 6, 0, inf, RuleSize(1, 1), 0) as quant6:
                while quant6(current):
                    self.SPACE(parent=current)
            current.src += 'Y'
            return current
    MULTIPLY.min_size = RuleSize(0, 0)

    def IF(self, parent=None):
        with UnlexerRuleContext(self, 'IF', parent) as current:
            current.src += 'I'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'F'
            return current
    IF.min_size = RuleSize(0, 0)

    def EVALUATE(self, parent=None):
        with UnlexerRuleContext(self, 'EVALUATE', parent) as current:
            current.src += 'E'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'V'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'A'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'L'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'U'
            with QuantifierContext(self, 4, 0, inf, RuleSize(1, 1), 0) as quant4:
                while quant4(current):
                    self.SPACE(parent=current)
            current.src += 'A'
            with QuantifierContext(self, 5, 0, inf, RuleSize(1, 1), 0) as quant5:
                while quant5(current):
                    self.SPACE(parent=current)
            current.src += 'T'
            with QuantifierContext(self, 6, 0, inf, RuleSize(1, 1), 0) as quant6:
                while quant6(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            return current
    EVALUATE.min_size = RuleSize(0, 0)

    def LOOP(self, parent=None):
        with UnlexerRuleContext(self, 'LOOP', parent) as current:
            current.src += 'L'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'O'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'O'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'P'
            return current
    LOOP.min_size = RuleSize(0, 0)

    def PICTURE(self, parent=None):
        with UnlexerRuleContext(self, 'PICTURE', parent) as current:
            current.src += 'P'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'I'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'C'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'T'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'U'
            with QuantifierContext(self, 4, 0, inf, RuleSize(1, 1), 0) as quant4:
                while quant4(current):
                    self.SPACE(parent=current)
            current.src += 'R'
            with QuantifierContext(self, 5, 0, inf, RuleSize(1, 1), 0) as quant5:
                while quant5(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            return current
    PICTURE.min_size = RuleSize(0, 0)

    def IS(self, parent=None):
        with UnlexerRuleContext(self, 'IS', parent) as current:
            current.src += 'I'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'S'
            return current
    IS.min_size = RuleSize(0, 0)

    def LIKE(self, parent=None):
        with UnlexerRuleContext(self, 'LIKE', parent) as current:
            current.src += 'L'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'I'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'K'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            return current
    LIKE.min_size = RuleSize(0, 0)

    def OCCURS(self, parent=None):
        with UnlexerRuleContext(self, 'OCCURS', parent) as current:
            current.src += 'O'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'C'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'C'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'U'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'R'
            with QuantifierContext(self, 4, 0, inf, RuleSize(1, 1), 0) as quant4:
                while quant4(current):
                    self.SPACE(parent=current)
            current.src += 'S'
            return current
    OCCURS.min_size = RuleSize(0, 0)

    def TIMES(self, parent=None):
        with UnlexerRuleContext(self, 'TIMES', parent) as current:
            current.src += 'T'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'I'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'M'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'S'
            return current
    TIMES.min_size = RuleSize(0, 0)

    def USING(self, parent=None):
        with UnlexerRuleContext(self, 'USING', parent) as current:
            current.src += 'U'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'S'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'I'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'N'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'G'
            return current
    USING.min_size = RuleSize(0, 0)

    def BY(self, parent=None):
        with UnlexerRuleContext(self, 'BY', parent) as current:
            current.src += 'B'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'Y'
            return current
    BY.min_size = RuleSize(0, 0)

    def REFERENCE(self, parent=None):
        with UnlexerRuleContext(self, 'REFERENCE', parent) as current:
            current.src += 'R'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'F'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'R'
            with QuantifierContext(self, 4, 0, inf, RuleSize(1, 1), 0) as quant4:
                while quant4(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            with QuantifierContext(self, 5, 0, inf, RuleSize(1, 1), 0) as quant5:
                while quant5(current):
                    self.SPACE(parent=current)
            current.src += 'N'
            with QuantifierContext(self, 6, 0, inf, RuleSize(1, 1), 0) as quant6:
                while quant6(current):
                    self.SPACE(parent=current)
            current.src += 'C'
            with QuantifierContext(self, 7, 0, inf, RuleSize(1, 1), 0) as quant7:
                while quant7(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            return current
    REFERENCE.min_size = RuleSize(0, 0)

    def CONTENT(self, parent=None):
        with UnlexerRuleContext(self, 'CONTENT', parent) as current:
            current.src += 'C'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'O'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'N'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'T'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            with QuantifierContext(self, 4, 0, inf, RuleSize(1, 1), 0) as quant4:
                while quant4(current):
                    self.SPACE(parent=current)
            current.src += 'N'
            with QuantifierContext(self, 5, 0, inf, RuleSize(1, 1), 0) as quant5:
                while quant5(current):
                    self.SPACE(parent=current)
            current.src += 'T'
            return current
    CONTENT.min_size = RuleSize(0, 0)

    def VALUE(self, parent=None):
        with UnlexerRuleContext(self, 'VALUE', parent) as current:
            current.src += 'V'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'A'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'L'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'U'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            return current
    VALUE.min_size = RuleSize(0, 0)

    def PROCEDURE(self, parent=None):
        with UnlexerRuleContext(self, 'PROCEDURE', parent) as current:
            current.src += 'P'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'R'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'O'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'C'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            with QuantifierContext(self, 4, 0, inf, RuleSize(1, 1), 0) as quant4:
                while quant4(current):
                    self.SPACE(parent=current)
            current.src += 'D'
            with QuantifierContext(self, 5, 0, inf, RuleSize(1, 1), 0) as quant5:
                while quant5(current):
                    self.SPACE(parent=current)
            current.src += 'U'
            with QuantifierContext(self, 6, 0, inf, RuleSize(1, 1), 0) as quant6:
                while quant6(current):
                    self.SPACE(parent=current)
            current.src += 'R'
            with QuantifierContext(self, 7, 0, inf, RuleSize(1, 1), 0) as quant7:
                while quant7(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            return current
    PROCEDURE.min_size = RuleSize(0, 0)

    def DIVISION(self, parent=None):
        with UnlexerRuleContext(self, 'DIVISION', parent) as current:
            current.src += 'D'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'I'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'V'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'I'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'S'
            with QuantifierContext(self, 4, 0, inf, RuleSize(1, 1), 0) as quant4:
                while quant4(current):
                    self.SPACE(parent=current)
            current.src += 'I'
            with QuantifierContext(self, 5, 0, inf, RuleSize(1, 1), 0) as quant5:
                while quant5(current):
                    self.SPACE(parent=current)
            current.src += 'O'
            with QuantifierContext(self, 6, 0, inf, RuleSize(1, 1), 0) as quant6:
                while quant6(current):
                    self.SPACE(parent=current)
            current.src += 'N'
            return current
    DIVISION.min_size = RuleSize(0, 0)

    def TO(self, parent=None):
        with UnlexerRuleContext(self, 'TO', parent) as current:
            current.src += 'T'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'O'
            return current
    TO.min_size = RuleSize(0, 0)

    def FROM(self, parent=None):
        with UnlexerRuleContext(self, 'FROM', parent) as current:
            current.src += 'F'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'R'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'O'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'M'
            return current
    FROM.min_size = RuleSize(0, 0)

    def INTO(self, parent=None):
        with UnlexerRuleContext(self, 'INTO', parent) as current:
            current.src += 'I'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'N'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'T'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'O'
            return current
    INTO.min_size = RuleSize(0, 0)

    def THROUGH(self, parent=None):
        with UnlexerRuleContext(self, 'THROUGH', parent) as current:
            current.src += 'T'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'H'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'R'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'O'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'U'
            with QuantifierContext(self, 4, 0, inf, RuleSize(1, 1), 0) as quant4:
                while quant4(current):
                    self.SPACE(parent=current)
            current.src += 'G'
            with QuantifierContext(self, 5, 0, inf, RuleSize(1, 1), 0) as quant5:
                while quant5(current):
                    self.SPACE(parent=current)
            current.src += 'H'
            return current
    THROUGH.min_size = RuleSize(0, 0)

    def SENTENCE(self, parent=None):
        with UnlexerRuleContext(self, 'SENTENCE', parent) as current:
            current.src += 'S'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'N'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'T'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            with QuantifierContext(self, 4, 0, inf, RuleSize(1, 1), 0) as quant4:
                while quant4(current):
                    self.SPACE(parent=current)
            current.src += 'N'
            with QuantifierContext(self, 5, 0, inf, RuleSize(1, 1), 0) as quant5:
                while quant5(current):
                    self.SPACE(parent=current)
            current.src += 'C'
            with QuantifierContext(self, 6, 0, inf, RuleSize(1, 1), 0) as quant6:
                while quant6(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            return current
    SENTENCE.min_size = RuleSize(0, 0)

    def NEXT(self, parent=None):
        with UnlexerRuleContext(self, 'NEXT', parent) as current:
            current.src += 'N'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'X'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'T'
            return current
    NEXT.min_size = RuleSize(0, 0)

    def THEN(self, parent=None):
        with UnlexerRuleContext(self, 'THEN', parent) as current:
            current.src += 'T'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'H'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'N'
            return current
    THEN.min_size = RuleSize(0, 0)

    def ELSE(self, parent=None):
        with UnlexerRuleContext(self, 'ELSE', parent) as current:
            current.src += 'E'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'L'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'S'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            return current
    ELSE.min_size = RuleSize(0, 0)

    def END(self, parent=None):
        with UnlexerRuleContext(self, 'END', parent) as current:
            current.src += 'E'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'N'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'D'
            return current
    END.min_size = RuleSize(0, 0)

    def GO(self, parent=None):
        with UnlexerRuleContext(self, 'GO', parent) as current:
            current.src += 'G'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'O'
            return current
    GO.min_size = RuleSize(0, 0)

    def WITH(self, parent=None):
        with UnlexerRuleContext(self, 'WITH', parent) as current:
            current.src += 'W'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'I'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'T'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'H'
            return current
    WITH.min_size = RuleSize(0, 0)

    def NO(self, parent=None):
        with UnlexerRuleContext(self, 'NO', parent) as current:
            current.src += 'N'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'O'
            return current
    NO.min_size = RuleSize(0, 0)

    def ADVANCING(self, parent=None):
        with UnlexerRuleContext(self, 'ADVANCING', parent) as current:
            current.src += 'A'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'D'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'V'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'A'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'N'
            with QuantifierContext(self, 4, 0, inf, RuleSize(1, 1), 0) as quant4:
                while quant4(current):
                    self.SPACE(parent=current)
            current.src += 'C'
            with QuantifierContext(self, 5, 0, inf, RuleSize(1, 1), 0) as quant5:
                while quant5(current):
                    self.SPACE(parent=current)
            current.src += 'I'
            with QuantifierContext(self, 6, 0, inf, RuleSize(1, 1), 0) as quant6:
                while quant6(current):
                    self.SPACE(parent=current)
            current.src += 'N'
            with QuantifierContext(self, 7, 0, inf, RuleSize(1, 1), 0) as quant7:
                while quant7(current):
                    self.SPACE(parent=current)
            current.src += 'G'
            return current
    ADVANCING.min_size = RuleSize(0, 0)

    def GIVING(self, parent=None):
        with UnlexerRuleContext(self, 'GIVING', parent) as current:
            current.src += 'G'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'I'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'V'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'I'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'N'
            with QuantifierContext(self, 4, 0, inf, RuleSize(1, 1), 0) as quant4:
                while quant4(current):
                    self.SPACE(parent=current)
            current.src += 'G'
            return current
    GIVING.min_size = RuleSize(0, 0)

    def REMAINDER(self, parent=None):
        with UnlexerRuleContext(self, 'REMAINDER', parent) as current:
            current.src += 'R'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'M'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'A'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'I'
            with QuantifierContext(self, 4, 0, inf, RuleSize(1, 1), 0) as quant4:
                while quant4(current):
                    self.SPACE(parent=current)
            current.src += 'N'
            with QuantifierContext(self, 5, 0, inf, RuleSize(1, 1), 0) as quant5:
                while quant5(current):
                    self.SPACE(parent=current)
            current.src += 'D'
            with QuantifierContext(self, 6, 0, inf, RuleSize(1, 1), 0) as quant6:
                while quant6(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            with QuantifierContext(self, 7, 0, inf, RuleSize(1, 1), 0) as quant7:
                while quant7(current):
                    self.SPACE(parent=current)
            current.src += 'R'
            return current
    REMAINDER.min_size = RuleSize(0, 0)

    def OF(self, parent=None):
        with UnlexerRuleContext(self, 'OF', parent) as current:
            current.src += 'O'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'F'
            return current
    OF.min_size = RuleSize(0, 0)

    def WHEN(self, parent=None):
        with UnlexerRuleContext(self, 'WHEN', parent) as current:
            current.src += 'W'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'H'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'N'
            return current
    WHEN.min_size = RuleSize(0, 0)

    def OTHER(self, parent=None):
        with UnlexerRuleContext(self, 'OTHER', parent) as current:
            current.src += 'O'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'T'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'H'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'R'
            return current
    OTHER.min_size = RuleSize(0, 0)

    def TRUE(self, parent=None):
        with UnlexerRuleContext(self, 'TRUE', parent) as current:
            current.src += 'T'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'R'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'U'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            return current
    TRUE.min_size = RuleSize(0, 0)

    def FALSE(self, parent=None):
        with UnlexerRuleContext(self, 'FALSE', parent) as current:
            current.src += 'F'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'A'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'L'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'S'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            return current
    FALSE.min_size = RuleSize(0, 0)

    def NOT(self, parent=None):
        with UnlexerRuleContext(self, 'NOT', parent) as current:
            current.src += 'N'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'O'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'T'
            return current
    NOT.min_size = RuleSize(0, 0)

    def VARYING(self, parent=None):
        with UnlexerRuleContext(self, 'VARYING', parent) as current:
            current.src += 'V'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'A'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'R'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'Y'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'I'
            with QuantifierContext(self, 4, 0, inf, RuleSize(1, 1), 0) as quant4:
                while quant4(current):
                    self.SPACE(parent=current)
            current.src += 'N'
            with QuantifierContext(self, 5, 0, inf, RuleSize(1, 1), 0) as quant5:
                while quant5(current):
                    self.SPACE(parent=current)
            current.src += 'G'
            return current
    VARYING.min_size = RuleSize(0, 0)

    def UNTIL(self, parent=None):
        with UnlexerRuleContext(self, 'UNTIL', parent) as current:
            current.src += 'U'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'N'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'T'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'I'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'L'
            return current
    UNTIL.min_size = RuleSize(0, 0)

    def WHILE(self, parent=None):
        with UnlexerRuleContext(self, 'WHILE', parent) as current:
            current.src += 'W'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'H'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'I'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'L'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            return current
    WHILE.min_size = RuleSize(0, 0)

    def IDENTIFICATION(self, parent=None):
        with UnlexerRuleContext(self, 'IDENTIFICATION', parent) as current:
            current.src += 'I'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'D'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'N'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'T'
            with QuantifierContext(self, 4, 0, inf, RuleSize(1, 1), 0) as quant4:
                while quant4(current):
                    self.SPACE(parent=current)
            current.src += 'I'
            with QuantifierContext(self, 5, 0, inf, RuleSize(1, 1), 0) as quant5:
                while quant5(current):
                    self.SPACE(parent=current)
            current.src += 'F'
            with QuantifierContext(self, 6, 0, inf, RuleSize(1, 1), 0) as quant6:
                while quant6(current):
                    self.SPACE(parent=current)
            current.src += 'I'
            with QuantifierContext(self, 7, 0, inf, RuleSize(1, 1), 0) as quant7:
                while quant7(current):
                    self.SPACE(parent=current)
            current.src += 'C'
            with QuantifierContext(self, 8, 0, inf, RuleSize(1, 1), 0) as quant8:
                while quant8(current):
                    self.SPACE(parent=current)
            current.src += 'A'
            with QuantifierContext(self, 9, 0, inf, RuleSize(1, 1), 0) as quant9:
                while quant9(current):
                    self.SPACE(parent=current)
            current.src += 'T'
            with QuantifierContext(self, 10, 0, inf, RuleSize(1, 1), 0) as quant10:
                while quant10(current):
                    self.SPACE(parent=current)
            current.src += 'I'
            with QuantifierContext(self, 11, 0, inf, RuleSize(1, 1), 0) as quant11:
                while quant11(current):
                    self.SPACE(parent=current)
            current.src += 'O'
            with QuantifierContext(self, 12, 0, inf, RuleSize(1, 1), 0) as quant12:
                while quant12(current):
                    self.SPACE(parent=current)
            current.src += 'N'
            return current
    IDENTIFICATION.min_size = RuleSize(0, 0)

    def DATA(self, parent=None):
        with UnlexerRuleContext(self, 'DATA', parent) as current:
            current.src += 'D'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'A'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'T'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'A'
            return current
    DATA.min_size = RuleSize(0, 0)

    def SIGNAL(self, parent=None):
        with UnlexerRuleContext(self, 'SIGNAL', parent) as current:
            current.src += 'S'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'I'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'G'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'N'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'A'
            with QuantifierContext(self, 4, 0, inf, RuleSize(1, 1), 0) as quant4:
                while quant4(current):
                    self.SPACE(parent=current)
            current.src += 'L'
            return current
    SIGNAL.min_size = RuleSize(0, 0)

    def ON(self, parent=None):
        with UnlexerRuleContext(self, 'ON', parent) as current:
            current.src += 'O'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'N'
            return current
    ON.min_size = RuleSize(0, 0)

    def ERROR(self, parent=None):
        with UnlexerRuleContext(self, 'ERROR', parent) as current:
            current.src += 'E'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'R'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'R'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'O'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'R'
            return current
    ERROR.min_size = RuleSize(0, 0)

    def OFF(self, parent=None):
        with UnlexerRuleContext(self, 'OFF', parent) as current:
            current.src += 'O'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'F'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'F'
            return current
    OFF.min_size = RuleSize(0, 0)

    def CALL(self, parent=None):
        with UnlexerRuleContext(self, 'CALL', parent) as current:
            current.src += 'C'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'A'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'L'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'L'
            return current
    CALL.min_size = RuleSize(0, 0)

    def SPACES(self, parent=None):
        with UnlexerRuleContext(self, 'SPACES', parent) as current:
            current.src += 'S'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'P'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'A'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'C'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            with QuantifierContext(self, 4, 0, inf, RuleSize(1, 1), 0) as quant4:
                while quant4(current):
                    self.SPACE(parent=current)
            current.src += 'S'
            return current
    SPACES.min_size = RuleSize(0, 0)

    def HIGH_VALUES(self, parent=None):
        with UnlexerRuleContext(self, 'HIGH_VALUES', parent) as current:
            current.src += 'H'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'I'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'G'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += 'H'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += '-'
            with QuantifierContext(self, 4, 0, inf, RuleSize(1, 1), 0) as quant4:
                while quant4(current):
                    self.SPACE(parent=current)
            current.src += 'V'
            with QuantifierContext(self, 5, 0, inf, RuleSize(1, 1), 0) as quant5:
                while quant5(current):
                    self.SPACE(parent=current)
            current.src += 'A'
            with QuantifierContext(self, 6, 0, inf, RuleSize(1, 1), 0) as quant6:
                while quant6(current):
                    self.SPACE(parent=current)
            current.src += 'L'
            with QuantifierContext(self, 7, 0, inf, RuleSize(1, 1), 0) as quant7:
                while quant7(current):
                    self.SPACE(parent=current)
            current.src += 'U'
            with QuantifierContext(self, 8, 0, inf, RuleSize(1, 1), 0) as quant8:
                while quant8(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            with QuantifierContext(self, 9, 0, inf, RuleSize(1, 1), 0) as quant9:
                while quant9(current):
                    self.SPACE(parent=current)
            current.src += 'S'
            return current
    HIGH_VALUES.min_size = RuleSize(0, 0)

    def LOW_VALUES(self, parent=None):
        with UnlexerRuleContext(self, 'LOW_VALUES', parent) as current:
            current.src += 'L'
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.SPACE(parent=current)
            current.src += 'O'
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.SPACE(parent=current)
            current.src += 'W'
            with QuantifierContext(self, 2, 0, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.SPACE(parent=current)
            current.src += '-'
            with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.SPACE(parent=current)
            current.src += 'V'
            with QuantifierContext(self, 4, 0, inf, RuleSize(1, 1), 0) as quant4:
                while quant4(current):
                    self.SPACE(parent=current)
            current.src += 'A'
            with QuantifierContext(self, 5, 0, inf, RuleSize(1, 1), 0) as quant5:
                while quant5(current):
                    self.SPACE(parent=current)
            current.src += 'L'
            with QuantifierContext(self, 6, 0, inf, RuleSize(1, 1), 0) as quant6:
                while quant6(current):
                    self.SPACE(parent=current)
            current.src += 'U'
            with QuantifierContext(self, 7, 0, inf, RuleSize(1, 1), 0) as quant7:
                while quant7(current):
                    self.SPACE(parent=current)
            current.src += 'E'
            with QuantifierContext(self, 8, 0, inf, RuleSize(1, 1), 0) as quant8:
                while quant8(current):
                    self.SPACE(parent=current)
            current.src += 'S'
            return current
    LOW_VALUES.min_size = RuleSize(0, 0)

    def LITERAL(self, parent=None):
        with UnlexerRuleContext(self, 'LITERAL', parent) as current:
            current.src += '"'
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[1])
            current.src += '"'
            return current
    LITERAL.min_size = RuleSize(0, 0)

    def COPY_LITERAL(self, parent=None):
        with UnlexerRuleContext(self, 'COPY_LITERAL', parent) as current:
            current.src += '==='
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[2])
            current.src += '==='
            return current
    COPY_LITERAL.min_size = RuleSize(0, 0)

    def IDENTIFIER(self, parent=None):
        with UnlexerRuleContext(self, 'IDENTIFIER', parent) as current:
            self.LETTER(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(0, 0)), 0, (1, 1, 1)) as alt0:
                        choice0 = alt0(current)
                        src = [None, None, '-'][choice0]
                        rule = [self.LETTER, self.DIGIT, None][choice0]
                        if src is not None:
                            current.src += src
                        else:
                            rule(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    current.src += '('
                    self.DIGIT(parent=current)
                    current.src += ')'
            return current
    IDENTIFIER.min_size = RuleSize(1, 1)

    def INT(self, parent=None):
        with UnlexerRuleContext(self, 'INT', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.DIGIT(parent=current)
            return current
    INT.min_size = RuleSize(1, 1)

    def SPACE(self, parent=None):
        with UnlexerRuleContext(self, 'SPACE', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[3])
            return current
    SPACE.min_size = RuleSize(0, 0)

    def DOT(self, parent=None):
        with UnlexerRuleContext(self, 'DOT', parent) as current:
            current.src += '.'
            return current
    DOT.min_size = RuleSize(0, 0)

    def LETTER(self, parent=None):
        with UnlexerRuleContext(self, 'LETTER', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[4])
            return current
    LETTER.min_size = RuleSize(0, 0)

    def DIGIT(self, parent=None):
        with UnlexerRuleContext(self, 'DIGIT', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[5])
            return current
    DIGIT.min_size = RuleSize(0, 0)

    def REPR(self, parent=None):
        with UnlexerRuleContext(self, 'REPR', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1, 1, 1, 1, 1)) as alt0:
                current.src += ['9', 'A', 'X', 'Z', 'S', 'V'][alt0(current)]
            return current
    REPR.min_size = RuleSize(0, 0)

    def T__0(self, parent=None):
        with UnlexerRuleContext(self, 'T__0', parent) as current:
            current.src += 'ALTER'
            return current
    T__0.min_size = RuleSize(0, 0)

    def T__1(self, parent=None):
        with UnlexerRuleContext(self, 'T__1', parent) as current:
            current.src += 'TO PROCEED TO'
            return current
    T__1.min_size = RuleSize(0, 0)

    def T__2(self, parent=None):
        with UnlexerRuleContext(self, 'T__2', parent) as current:
            current.src += 'COPY'
            return current
    T__2.min_size = RuleSize(0, 0)

    def T__3(self, parent=None):
        with UnlexerRuleContext(self, 'T__3', parent) as current:
            current.src += 'REPLACING'
            return current
    T__3.min_size = RuleSize(0, 0)

    def T__4(self, parent=None):
        with UnlexerRuleContext(self, 'T__4', parent) as current:
            current.src += 'BY'
            return current
    T__4.min_size = RuleSize(0, 0)

    def loop_expression_loop_varying_expression(self, parent=None):
        local_ctx = dict(fr=None, to=None, by=None)
        with UnparserRuleContext(self, 'loop_expression_loop_varying_expression', parent) as current:
            self.VARYING(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(3, 2), 0) as quant0:
                while quant0(current):
                    self.identifiers(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 2), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.FROM, parent=current)
                    self.atomic(parent=current)
                    local_ctx['fr'] = current.last_child
            with QuantifierContext(self, 2, 0, 1, RuleSize(2, 2), 0) as quant2:
                while quant2(current):
                    self._reserve(1, self.TO, parent=current)
                    self.atomic(parent=current)
                    local_ctx['to'] = current.last_child
            with QuantifierContext(self, 3, 0, 1, RuleSize(2, 2), 0) as quant3:
                while quant3(current):
                    self._reserve(1, self.BY, parent=current)
                    self.atomic(parent=current)
                    local_ctx['by'] = current.last_child
            return current
    loop_expression_loop_varying_expression.min_size = RuleSize(1, 1)

    def loop_expression_loop_while_expression(self, parent=None):
        with UnparserRuleContext(self, 'loop_expression_loop_while_expression', parent) as current:
            self._reserve(1, self.WHILE, parent=current)
            self.boolean_expression(parent=current)
            return current
    loop_expression_loop_while_expression.min_size = RuleSize(2, 2)

    def loop_expression_loop_until_expression(self, parent=None):
        with UnparserRuleContext(self, 'loop_expression_loop_until_expression', parent) as current:
            self._reserve(1, self.UNTIL, parent=current)
            self.boolean_expression(parent=current)
            return current
    loop_expression_loop_until_expression.min_size = RuleSize(2, 2)

    def loop_expression_loop_statement_expession(self, parent=None):
        with UnparserRuleContext(self, 'loop_expression_loop_statement_expession', parent) as current:
            self.statement(parent=current)
            return current
    loop_expression_loop_statement_expession.min_size = RuleSize(3, 1)

    def T__5(self, parent=None):
        with UnlexerRuleContext(self, 'T__5', parent) as current:
            current.src += '+'
            return current
    T__5.min_size = RuleSize(0, 0)

    def T__6(self, parent=None):
        with UnlexerRuleContext(self, 'T__6', parent) as current:
            current.src += '('
            return current
    T__6.min_size = RuleSize(0, 0)

    def T__7(self, parent=None):
        with UnlexerRuleContext(self, 'T__7', parent) as current:
            current.src += ')'
            return current
    T__7.min_size = RuleSize(0, 0)

    _default_rule = program

    _charsets = {
        0: list(itertools.chain.from_iterable([range(0x20, 0x7f)])),
        1: list(itertools.chain.from_iterable([range(0x20, 0x22), range(0x23, 0x7f)])),
        2: list(itertools.chain.from_iterable([range(0x20, 0x3d), range(0x3e, 0x7f)])),
        3: list(itertools.chain.from_iterable([range(0x9, 0xa), range(0xa, 0xb), range(0xd, 0xe), range(0x20, 0x21)])),
        4: list(itertools.chain.from_iterable([range(0x41, 0x5b), range(0x61, 0x7b)])),
        5: list(itertools.chain.from_iterable([range(0x30, 0x3a)])),
    }
