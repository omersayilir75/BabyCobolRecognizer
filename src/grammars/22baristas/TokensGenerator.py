# Generated by Grammarinator 23.7.post31+g3f15e2c.d20231108

import itertools

from math import inf
from grammarinator.runtime import *

class TokensGenerator(Generator):


    def EOF(self, parent=None):
        pass
    EOF.min_size = RuleSize(0, 0)

    def PARAGRAPH(self, parent=None):
        with UnlexerRuleContext(self, 'PARAGRAPH', parent) as current:
            current.src += '~'
            return current
    PARAGRAPH.min_size = RuleSize(0, 0)

    def DATA_DIVISION_(self, parent=None):
        with UnlexerRuleContext(self, 'DATA_DIVISION_', parent) as current:
            self._reserve(12, self.D, parent=current)
            self._reserve(11, self.A, parent=current)
            self._reserve(10, self.T, parent=current)
            self._reserve(9, self.A, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 9) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[1])
            self._reserve(8, self.D, parent=current)
            self._reserve(7, self.I, parent=current)
            self._reserve(6, self.V, parent=current)
            self._reserve(5, self.I, parent=current)
            self._reserve(4, self.S, parent=current)
            self._reserve(3, self.I, parent=current)
            self._reserve(2, self.O, parent=current)
            self._reserve(1, self.N, parent=current)
            self.DOT(parent=current)
            return current
    DATA_DIVISION_.min_size = RuleSize(1, 13)

    def PROCEDURE_DIVISION_(self, parent=None):
        with UnlexerRuleContext(self, 'PROCEDURE_DIVISION_', parent) as current:
            self._reserve(1, self.PROCEDURE_DIVISION, parent=current)
            self.DOT(parent=current)
            return current
    PROCEDURE_DIVISION_.min_size = RuleSize(2, 19)

    def KEYWORD(self, parent=None):
        with UnlexerRuleContext(self, 'KEYWORD', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 7), RuleSize(2, 4), RuleSize(2, 10), RuleSize(2, 5), RuleSize(2, 6), RuleSize(2, 7), RuleSize(2, 3), RuleSize(2, 5), RuleSize(2, 8), RuleSize(2, 5), RuleSize(2, 15), RuleSize(2, 13), RuleSize(2, 10), RuleSize(2, 8), RuleSize(2, 7), RuleSize(2, 5), RuleSize(2, 4), RuleSize(2, 6), RuleSize(2, 9), RuleSize(2, 6), RuleSize(2, 5), RuleSize(2, 7), RuleSize(2, 3), RuleSize(2, 15), RuleSize(2, 3), RuleSize(2, 13), RuleSize(2, 5), RuleSize(2, 3), RuleSize(2, 5), RuleSize(2, 5), RuleSize(2, 5), RuleSize(2, 9), RuleSize(2, 5), RuleSize(2, 3), RuleSize(2, 4), RuleSize(2, 4), RuleSize(2, 3), RuleSize(2, 6), RuleSize(2, 8), RuleSize(2, 8), RuleSize(2, 18), RuleSize(2, 8), RuleSize(2, 11), RuleSize(2, 10), RuleSize(2, 10), RuleSize(2, 10), RuleSize(2, 10), RuleSize(2, 9), RuleSize(2, 7), RuleSize(2, 5), RuleSize(2, 6), RuleSize(2, 7), RuleSize(2, 5), RuleSize(2, 9), RuleSize(2, 5), RuleSize(2, 8), RuleSize(2, 6), RuleSize(2, 3), RuleSize(2, 5), RuleSize(2, 6), RuleSize(2, 6), RuleSize(2, 8), RuleSize(2, 5), RuleSize(2, 5), RuleSize(2, 4), RuleSize(2, 3), RuleSize(2, 4), RuleSize(2, 12), RuleSize(2, 11)), 0, (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)) as alt0:
                [self.ACCEPT, self.ADD, self.ADVANCING, self.ALSO, self.ALTER, self.AUTHOR, self.BY, self.CALL, self.CONTENT, self.COPY, self.DATECOMPILED, self.DATEWRITTEN, self.DELIMITED, self.DISPLAY, self.DIVIDE, self.ELSE, self.END, self.ERROR, self.EVALUATE, self.FALSE, self.FROM, self.GIVING, self.GO, self.IDENTIFICATION, self.IF, self.INSTALLATION, self.INTO, self.IS, self.LIKE, self.LOOP, self.MOVE, self.MULTIPLY, self.NEXT, self.NO, self.NOT, self.OFF, self.ON, self.OTHER, self.PERFORM, self.PICTURE, self.PROCEDURE_DIVISION, self.PROCEED, self.PROGRAMID, self.REFERENCE, self.REMAINDER, self.REPLACING, self.SECURITY, self.SENTENCE, self.SIGNAL, self.SIZE, self.SPACE, self.SPACES, self.STOP, self.SUBTRACT, self.THEN, self.THROUGH, self.TIMES, self.TO, self.TRUE, self.USING, self.VALUE, self.VARYING, self.WHEN, self.WITH, self.AND, self.OR, self.XOR, self.HIGHVALUES, self.LOWVALUES][alt0(current)](parent=current)
            return current
    KEYWORD.min_size = RuleSize(2, 3)

    def ARRAY_N(self, parent=None):
        with UnlexerRuleContext(self, 'ARRAY_N', parent) as current:
            self._reserve(3, self.LBRACE, parent=current)
            self._reserve(1, self.INT, parent=current)
            self.RBRACE(parent=current)
            return current
    ARRAY_N.min_size = RuleSize(2, 4)

    def ACCEPT(self, parent=None):
        with UnlexerRuleContext(self, 'ACCEPT', parent) as current:
            self._reserve(5, self.A, parent=current)
            self._reserve(4, self.C, parent=current)
            self._reserve(3, self.C, parent=current)
            self._reserve(2, self.E, parent=current)
            self._reserve(1, self.P, parent=current)
            self.T(parent=current)
            return current
    ACCEPT.min_size = RuleSize(1, 6)

    def ADD(self, parent=None):
        with UnlexerRuleContext(self, 'ADD', parent) as current:
            self._reserve(2, self.A, parent=current)
            self._reserve(1, self.D, parent=current)
            self.D(parent=current)
            return current
    ADD.min_size = RuleSize(1, 3)

    def ADVANCING(self, parent=None):
        with UnlexerRuleContext(self, 'ADVANCING', parent) as current:
            self._reserve(8, self.A, parent=current)
            self._reserve(7, self.D, parent=current)
            self._reserve(6, self.V, parent=current)
            self._reserve(5, self.A, parent=current)
            self._reserve(4, self.N, parent=current)
            self._reserve(3, self.C, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.N, parent=current)
            self.G(parent=current)
            return current
    ADVANCING.min_size = RuleSize(1, 9)

    def ALSO(self, parent=None):
        with UnlexerRuleContext(self, 'ALSO', parent) as current:
            self._reserve(3, self.A, parent=current)
            self._reserve(2, self.L, parent=current)
            self._reserve(1, self.S, parent=current)
            self.O(parent=current)
            return current
    ALSO.min_size = RuleSize(1, 4)

    def ALTER(self, parent=None):
        with UnlexerRuleContext(self, 'ALTER', parent) as current:
            self._reserve(4, self.A, parent=current)
            self._reserve(3, self.L, parent=current)
            self._reserve(2, self.T, parent=current)
            self._reserve(1, self.E, parent=current)
            self.R(parent=current)
            return current
    ALTER.min_size = RuleSize(1, 5)

    def AUTHOR(self, parent=None):
        with UnlexerRuleContext(self, 'AUTHOR', parent) as current:
            self._reserve(5, self.A, parent=current)
            self._reserve(4, self.U, parent=current)
            self._reserve(3, self.T, parent=current)
            self._reserve(2, self.H, parent=current)
            self._reserve(1, self.O, parent=current)
            self.R(parent=current)
            return current
    AUTHOR.min_size = RuleSize(1, 6)

    def BY(self, parent=None):
        with UnlexerRuleContext(self, 'BY', parent) as current:
            self._reserve(1, self.B, parent=current)
            self.Y(parent=current)
            return current
    BY.min_size = RuleSize(1, 2)

    def CALL(self, parent=None):
        with UnlexerRuleContext(self, 'CALL', parent) as current:
            self._reserve(3, self.C, parent=current)
            self._reserve(2, self.A, parent=current)
            self._reserve(1, self.L, parent=current)
            self.L(parent=current)
            return current
    CALL.min_size = RuleSize(1, 4)

    def CONTENT(self, parent=None):
        with UnlexerRuleContext(self, 'CONTENT', parent) as current:
            self._reserve(6, self.C, parent=current)
            self._reserve(5, self.O, parent=current)
            self._reserve(4, self.N, parent=current)
            self._reserve(3, self.T, parent=current)
            self._reserve(2, self.E, parent=current)
            self._reserve(1, self.N, parent=current)
            self.T(parent=current)
            return current
    CONTENT.min_size = RuleSize(1, 7)

    def COPY(self, parent=None):
        with UnlexerRuleContext(self, 'COPY', parent) as current:
            self._reserve(3, self.C, parent=current)
            self._reserve(2, self.O, parent=current)
            self._reserve(1, self.P, parent=current)
            self.Y(parent=current)
            return current
    COPY.min_size = RuleSize(1, 4)

    def DATECOMPILED(self, parent=None):
        with UnlexerRuleContext(self, 'DATECOMPILED', parent) as current:
            self._reserve(13, self.D, parent=current)
            self._reserve(12, self.A, parent=current)
            self._reserve(11, self.T, parent=current)
            self._reserve(10, self.E, parent=current)
            self._reserve(9, self.DASH, parent=current)
            self._reserve(8, self.C, parent=current)
            self._reserve(7, self.O, parent=current)
            self._reserve(6, self.M, parent=current)
            self._reserve(5, self.P, parent=current)
            self._reserve(4, self.I, parent=current)
            self._reserve(3, self.L, parent=current)
            self._reserve(2, self.L, parent=current)
            self._reserve(1, self.E, parent=current)
            self.D(parent=current)
            return current
    DATECOMPILED.min_size = RuleSize(1, 14)

    def DATEWRITTEN(self, parent=None):
        with UnlexerRuleContext(self, 'DATEWRITTEN', parent) as current:
            self._reserve(11, self.D, parent=current)
            self._reserve(10, self.A, parent=current)
            self._reserve(9, self.T, parent=current)
            self._reserve(8, self.E, parent=current)
            self._reserve(7, self.DASH, parent=current)
            self._reserve(6, self.W, parent=current)
            self._reserve(5, self.R, parent=current)
            self._reserve(4, self.I, parent=current)
            self._reserve(3, self.T, parent=current)
            self._reserve(2, self.T, parent=current)
            self._reserve(1, self.E, parent=current)
            self.N(parent=current)
            return current
    DATEWRITTEN.min_size = RuleSize(1, 12)

    def DELIMITED(self, parent=None):
        with UnlexerRuleContext(self, 'DELIMITED', parent) as current:
            self._reserve(8, self.D, parent=current)
            self._reserve(7, self.E, parent=current)
            self._reserve(6, self.L, parent=current)
            self._reserve(5, self.I, parent=current)
            self._reserve(4, self.M, parent=current)
            self._reserve(3, self.I, parent=current)
            self._reserve(2, self.T, parent=current)
            self._reserve(1, self.E, parent=current)
            self.D(parent=current)
            return current
    DELIMITED.min_size = RuleSize(1, 9)

    def DISPLAY(self, parent=None):
        with UnlexerRuleContext(self, 'DISPLAY', parent) as current:
            self._reserve(6, self.D, parent=current)
            self._reserve(5, self.I, parent=current)
            self._reserve(4, self.S, parent=current)
            self._reserve(3, self.P, parent=current)
            self._reserve(2, self.L, parent=current)
            self._reserve(1, self.A, parent=current)
            self.Y(parent=current)
            return current
    DISPLAY.min_size = RuleSize(1, 7)

    def DIVIDE(self, parent=None):
        with UnlexerRuleContext(self, 'DIVIDE', parent) as current:
            self._reserve(5, self.D, parent=current)
            self._reserve(4, self.I, parent=current)
            self._reserve(3, self.V, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.D, parent=current)
            self.E(parent=current)
            return current
    DIVIDE.min_size = RuleSize(1, 6)

    def DOT(self, parent=None):
        with UnlexerRuleContext(self, 'DOT', parent) as current:
            current.src += '.'
            return current
    DOT.min_size = RuleSize(0, 0)

    def ELSE(self, parent=None):
        with UnlexerRuleContext(self, 'ELSE', parent) as current:
            self._reserve(3, self.E, parent=current)
            self._reserve(2, self.L, parent=current)
            self._reserve(1, self.S, parent=current)
            self.E(parent=current)
            return current
    ELSE.min_size = RuleSize(1, 4)

    def END(self, parent=None):
        with UnlexerRuleContext(self, 'END', parent) as current:
            self._reserve(2, self.E, parent=current)
            self._reserve(1, self.N, parent=current)
            self.D(parent=current)
            return current
    END.min_size = RuleSize(1, 3)

    def ERROR(self, parent=None):
        with UnlexerRuleContext(self, 'ERROR', parent) as current:
            self._reserve(4, self.E, parent=current)
            self._reserve(3, self.R, parent=current)
            self._reserve(2, self.R, parent=current)
            self._reserve(1, self.O, parent=current)
            self.R(parent=current)
            return current
    ERROR.min_size = RuleSize(1, 5)

    def EVALUATE(self, parent=None):
        with UnlexerRuleContext(self, 'EVALUATE', parent) as current:
            self._reserve(7, self.E, parent=current)
            self._reserve(6, self.V, parent=current)
            self._reserve(5, self.A, parent=current)
            self._reserve(4, self.L, parent=current)
            self._reserve(3, self.U, parent=current)
            self._reserve(2, self.A, parent=current)
            self._reserve(1, self.T, parent=current)
            self.E(parent=current)
            return current
    EVALUATE.min_size = RuleSize(1, 8)

    def FALSE(self, parent=None):
        with UnlexerRuleContext(self, 'FALSE', parent) as current:
            self._reserve(4, self.F, parent=current)
            self._reserve(3, self.A, parent=current)
            self._reserve(2, self.L, parent=current)
            self._reserve(1, self.S, parent=current)
            self.E(parent=current)
            return current
    FALSE.min_size = RuleSize(1, 5)

    def FROM(self, parent=None):
        with UnlexerRuleContext(self, 'FROM', parent) as current:
            self._reserve(3, self.F, parent=current)
            self._reserve(2, self.R, parent=current)
            self._reserve(1, self.O, parent=current)
            self.M(parent=current)
            return current
    FROM.min_size = RuleSize(1, 4)

    def GIVING(self, parent=None):
        with UnlexerRuleContext(self, 'GIVING', parent) as current:
            self._reserve(5, self.G, parent=current)
            self._reserve(4, self.I, parent=current)
            self._reserve(3, self.V, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.N, parent=current)
            self.G(parent=current)
            return current
    GIVING.min_size = RuleSize(1, 6)

    def GO(self, parent=None):
        with UnlexerRuleContext(self, 'GO', parent) as current:
            self._reserve(1, self.G, parent=current)
            self.O(parent=current)
            return current
    GO.min_size = RuleSize(1, 2)

    def IDENTIFICATION(self, parent=None):
        with UnlexerRuleContext(self, 'IDENTIFICATION', parent) as current:
            self._reserve(13, self.I, parent=current)
            self._reserve(12, self.D, parent=current)
            self._reserve(11, self.E, parent=current)
            self._reserve(10, self.N, parent=current)
            self._reserve(9, self.T, parent=current)
            self._reserve(8, self.I, parent=current)
            self._reserve(7, self.F, parent=current)
            self._reserve(6, self.I, parent=current)
            self._reserve(5, self.C, parent=current)
            self._reserve(4, self.A, parent=current)
            self._reserve(3, self.T, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.O, parent=current)
            self.N(parent=current)
            return current
    IDENTIFICATION.min_size = RuleSize(1, 14)

    def IF(self, parent=None):
        with UnlexerRuleContext(self, 'IF', parent) as current:
            self._reserve(1, self.I, parent=current)
            self.F(parent=current)
            return current
    IF.min_size = RuleSize(1, 2)

    def INSTALLATION(self, parent=None):
        with UnlexerRuleContext(self, 'INSTALLATION', parent) as current:
            self._reserve(11, self.I, parent=current)
            self._reserve(10, self.N, parent=current)
            self._reserve(9, self.S, parent=current)
            self._reserve(8, self.T, parent=current)
            self._reserve(7, self.A, parent=current)
            self._reserve(6, self.L, parent=current)
            self._reserve(5, self.L, parent=current)
            self._reserve(4, self.A, parent=current)
            self._reserve(3, self.T, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.O, parent=current)
            self.N(parent=current)
            return current
    INSTALLATION.min_size = RuleSize(1, 12)

    def INTO(self, parent=None):
        with UnlexerRuleContext(self, 'INTO', parent) as current:
            self._reserve(3, self.I, parent=current)
            self._reserve(2, self.N, parent=current)
            self._reserve(1, self.T, parent=current)
            self.O(parent=current)
            return current
    INTO.min_size = RuleSize(1, 4)

    def LOOP(self, parent=None):
        with UnlexerRuleContext(self, 'LOOP', parent) as current:
            self._reserve(3, self.L, parent=current)
            self._reserve(2, self.O, parent=current)
            self._reserve(1, self.O, parent=current)
            self.P(parent=current)
            return current
    LOOP.min_size = RuleSize(1, 4)

    def MOVE(self, parent=None):
        with UnlexerRuleContext(self, 'MOVE', parent) as current:
            self._reserve(3, self.M, parent=current)
            self._reserve(2, self.O, parent=current)
            self._reserve(1, self.V, parent=current)
            self.E(parent=current)
            return current
    MOVE.min_size = RuleSize(1, 4)

    def MULTIPLY(self, parent=None):
        with UnlexerRuleContext(self, 'MULTIPLY', parent) as current:
            self._reserve(7, self.M, parent=current)
            self._reserve(6, self.U, parent=current)
            self._reserve(5, self.L, parent=current)
            self._reserve(4, self.T, parent=current)
            self._reserve(3, self.I, parent=current)
            self._reserve(2, self.P, parent=current)
            self._reserve(1, self.L, parent=current)
            self.Y(parent=current)
            return current
    MULTIPLY.min_size = RuleSize(1, 8)

    def NEXT(self, parent=None):
        with UnlexerRuleContext(self, 'NEXT', parent) as current:
            self._reserve(3, self.N, parent=current)
            self._reserve(2, self.E, parent=current)
            self._reserve(1, self.X, parent=current)
            self.T(parent=current)
            return current
    NEXT.min_size = RuleSize(1, 4)

    def NO(self, parent=None):
        with UnlexerRuleContext(self, 'NO', parent) as current:
            self._reserve(1, self.N, parent=current)
            self.O(parent=current)
            return current
    NO.min_size = RuleSize(1, 2)

    def NOT(self, parent=None):
        with UnlexerRuleContext(self, 'NOT', parent) as current:
            self._reserve(2, self.N, parent=current)
            self._reserve(1, self.O, parent=current)
            self.T(parent=current)
            return current
    NOT.min_size = RuleSize(1, 3)

    def OF(self, parent=None):
        with UnlexerRuleContext(self, 'OF', parent) as current:
            self._reserve(1, self.O, parent=current)
            self.F(parent=current)
            return current
    OF.min_size = RuleSize(1, 2)

    def OFF(self, parent=None):
        with UnlexerRuleContext(self, 'OFF', parent) as current:
            self._reserve(2, self.O, parent=current)
            self._reserve(1, self.F, parent=current)
            self.F(parent=current)
            return current
    OFF.min_size = RuleSize(1, 3)

    def ON(self, parent=None):
        with UnlexerRuleContext(self, 'ON', parent) as current:
            self._reserve(1, self.O, parent=current)
            self.N(parent=current)
            return current
    ON.min_size = RuleSize(1, 2)

    def OTHER(self, parent=None):
        with UnlexerRuleContext(self, 'OTHER', parent) as current:
            self._reserve(4, self.O, parent=current)
            self._reserve(3, self.T, parent=current)
            self._reserve(2, self.H, parent=current)
            self._reserve(1, self.E, parent=current)
            self.R(parent=current)
            return current
    OTHER.min_size = RuleSize(1, 5)

    def PERFORM(self, parent=None):
        with UnlexerRuleContext(self, 'PERFORM', parent) as current:
            self._reserve(6, self.P, parent=current)
            self._reserve(5, self.E, parent=current)
            self._reserve(4, self.R, parent=current)
            self._reserve(3, self.F, parent=current)
            self._reserve(2, self.O, parent=current)
            self._reserve(1, self.R, parent=current)
            self.M(parent=current)
            return current
    PERFORM.min_size = RuleSize(1, 7)

    def PROCEED(self, parent=None):
        with UnlexerRuleContext(self, 'PROCEED', parent) as current:
            self._reserve(6, self.P, parent=current)
            self._reserve(5, self.R, parent=current)
            self._reserve(4, self.O, parent=current)
            self._reserve(3, self.C, parent=current)
            self._reserve(2, self.E, parent=current)
            self._reserve(1, self.E, parent=current)
            self.D(parent=current)
            return current
    PROCEED.min_size = RuleSize(1, 7)

    def PROCEDURE_DIVISION(self, parent=None):
        with UnlexerRuleContext(self, 'PROCEDURE_DIVISION', parent) as current:
            self._reserve(16, self.P, parent=current)
            self._reserve(15, self.R, parent=current)
            self._reserve(14, self.O, parent=current)
            self._reserve(13, self.C, parent=current)
            self._reserve(12, self.E, parent=current)
            self._reserve(11, self.D, parent=current)
            self._reserve(10, self.U, parent=current)
            self._reserve(9, self.R, parent=current)
            self._reserve(8, self.E, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 8) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[1])
            self._reserve(7, self.D, parent=current)
            self._reserve(6, self.I, parent=current)
            self._reserve(5, self.V, parent=current)
            self._reserve(4, self.I, parent=current)
            self._reserve(3, self.S, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.O, parent=current)
            self.N(parent=current)
            return current
    PROCEDURE_DIVISION.min_size = RuleSize(1, 17)

    def PROGRAMID(self, parent=None):
        with UnlexerRuleContext(self, 'PROGRAMID', parent) as current:
            self._reserve(9, self.P, parent=current)
            self._reserve(8, self.R, parent=current)
            self._reserve(7, self.O, parent=current)
            self._reserve(6, self.G, parent=current)
            self._reserve(5, self.R, parent=current)
            self._reserve(4, self.A, parent=current)
            self._reserve(3, self.M, parent=current)
            self._reserve(2, self.DASH, parent=current)
            self._reserve(1, self.I, parent=current)
            self.D(parent=current)
            return current
    PROGRAMID.min_size = RuleSize(1, 10)

    def REFERENCE(self, parent=None):
        with UnlexerRuleContext(self, 'REFERENCE', parent) as current:
            self._reserve(8, self.R, parent=current)
            self._reserve(7, self.E, parent=current)
            self._reserve(6, self.F, parent=current)
            self._reserve(5, self.E, parent=current)
            self._reserve(4, self.R, parent=current)
            self._reserve(3, self.E, parent=current)
            self._reserve(2, self.N, parent=current)
            self._reserve(1, self.C, parent=current)
            self.E(parent=current)
            return current
    REFERENCE.min_size = RuleSize(1, 9)

    def REMAINDER(self, parent=None):
        with UnlexerRuleContext(self, 'REMAINDER', parent) as current:
            self._reserve(8, self.R, parent=current)
            self._reserve(7, self.E, parent=current)
            self._reserve(6, self.M, parent=current)
            self._reserve(5, self.A, parent=current)
            self._reserve(4, self.I, parent=current)
            self._reserve(3, self.N, parent=current)
            self._reserve(2, self.D, parent=current)
            self._reserve(1, self.E, parent=current)
            self.R(parent=current)
            return current
    REMAINDER.min_size = RuleSize(1, 9)

    def REPLACING(self, parent=None):
        with UnlexerRuleContext(self, 'REPLACING', parent) as current:
            self._reserve(8, self.R, parent=current)
            self._reserve(7, self.E, parent=current)
            self._reserve(6, self.P, parent=current)
            self._reserve(5, self.L, parent=current)
            self._reserve(4, self.A, parent=current)
            self._reserve(3, self.C, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.N, parent=current)
            self.G(parent=current)
            return current
    REPLACING.min_size = RuleSize(1, 9)

    def SECURITY(self, parent=None):
        with UnlexerRuleContext(self, 'SECURITY', parent) as current:
            self._reserve(8, self.S, parent=current)
            self._reserve(7, self.E, parent=current)
            self._reserve(6, self.C, parent=current)
            self._reserve(5, self.U, parent=current)
            self._reserve(4, self.T, parent=current)
            self._reserve(3, self.R, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.T, parent=current)
            self.Y(parent=current)
            return current
    SECURITY.min_size = RuleSize(1, 9)

    def SENTENCE(self, parent=None):
        with UnlexerRuleContext(self, 'SENTENCE', parent) as current:
            self._reserve(7, self.S, parent=current)
            self._reserve(6, self.E, parent=current)
            self._reserve(5, self.N, parent=current)
            self._reserve(4, self.T, parent=current)
            self._reserve(3, self.E, parent=current)
            self._reserve(2, self.N, parent=current)
            self._reserve(1, self.C, parent=current)
            self.E(parent=current)
            return current
    SENTENCE.min_size = RuleSize(1, 8)

    def SIGNAL(self, parent=None):
        with UnlexerRuleContext(self, 'SIGNAL', parent) as current:
            self._reserve(5, self.S, parent=current)
            self._reserve(4, self.I, parent=current)
            self._reserve(3, self.G, parent=current)
            self._reserve(2, self.N, parent=current)
            self._reserve(1, self.A, parent=current)
            self.L(parent=current)
            return current
    SIGNAL.min_size = RuleSize(1, 6)

    def SIZE(self, parent=None):
        with UnlexerRuleContext(self, 'SIZE', parent) as current:
            self._reserve(3, self.S, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.Z, parent=current)
            self.E(parent=current)
            return current
    SIZE.min_size = RuleSize(1, 4)

    def SPACE(self, parent=None):
        with UnlexerRuleContext(self, 'SPACE', parent) as current:
            self._reserve(4, self.S, parent=current)
            self._reserve(3, self.P, parent=current)
            self._reserve(2, self.A, parent=current)
            self._reserve(1, self.C, parent=current)
            self.E(parent=current)
            return current
    SPACE.min_size = RuleSize(1, 5)

    def SPACES(self, parent=None):
        with UnlexerRuleContext(self, 'SPACES', parent) as current:
            self._reserve(5, self.S, parent=current)
            self._reserve(4, self.P, parent=current)
            self._reserve(3, self.A, parent=current)
            self._reserve(2, self.C, parent=current)
            self._reserve(1, self.E, parent=current)
            self.S(parent=current)
            return current
    SPACES.min_size = RuleSize(1, 6)

    def STOP(self, parent=None):
        with UnlexerRuleContext(self, 'STOP', parent) as current:
            self._reserve(3, self.S, parent=current)
            self._reserve(2, self.T, parent=current)
            self._reserve(1, self.O, parent=current)
            self.P(parent=current)
            return current
    STOP.min_size = RuleSize(1, 4)

    def SUBTRACT(self, parent=None):
        with UnlexerRuleContext(self, 'SUBTRACT', parent) as current:
            self._reserve(7, self.S, parent=current)
            self._reserve(6, self.U, parent=current)
            self._reserve(5, self.B, parent=current)
            self._reserve(4, self.T, parent=current)
            self._reserve(3, self.R, parent=current)
            self._reserve(2, self.A, parent=current)
            self._reserve(1, self.C, parent=current)
            self.T(parent=current)
            return current
    SUBTRACT.min_size = RuleSize(1, 8)

    def THEN(self, parent=None):
        with UnlexerRuleContext(self, 'THEN', parent) as current:
            self._reserve(3, self.T, parent=current)
            self._reserve(2, self.H, parent=current)
            self._reserve(1, self.E, parent=current)
            self.N(parent=current)
            return current
    THEN.min_size = RuleSize(1, 4)

    def THROUGH(self, parent=None):
        with UnlexerRuleContext(self, 'THROUGH', parent) as current:
            self._reserve(6, self.T, parent=current)
            self._reserve(5, self.H, parent=current)
            self._reserve(4, self.R, parent=current)
            self._reserve(3, self.O, parent=current)
            self._reserve(2, self.U, parent=current)
            self._reserve(1, self.G, parent=current)
            self.H(parent=current)
            return current
    THROUGH.min_size = RuleSize(1, 7)

    def TIMES(self, parent=None):
        with UnlexerRuleContext(self, 'TIMES', parent) as current:
            self._reserve(4, self.T, parent=current)
            self._reserve(3, self.I, parent=current)
            self._reserve(2, self.M, parent=current)
            self._reserve(1, self.E, parent=current)
            self.S(parent=current)
            return current
    TIMES.min_size = RuleSize(1, 5)

    def TO(self, parent=None):
        with UnlexerRuleContext(self, 'TO', parent) as current:
            self._reserve(1, self.T, parent=current)
            self.O(parent=current)
            return current
    TO.min_size = RuleSize(1, 2)

    def TRUE(self, parent=None):
        with UnlexerRuleContext(self, 'TRUE', parent) as current:
            self._reserve(3, self.T, parent=current)
            self._reserve(2, self.R, parent=current)
            self._reserve(1, self.U, parent=current)
            self.E(parent=current)
            return current
    TRUE.min_size = RuleSize(1, 4)

    def USING(self, parent=None):
        with UnlexerRuleContext(self, 'USING', parent) as current:
            self._reserve(4, self.U, parent=current)
            self._reserve(3, self.S, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.N, parent=current)
            self.G(parent=current)
            return current
    USING.min_size = RuleSize(1, 5)

    def VALUE(self, parent=None):
        with UnlexerRuleContext(self, 'VALUE', parent) as current:
            self._reserve(4, self.V, parent=current)
            self._reserve(3, self.A, parent=current)
            self._reserve(2, self.L, parent=current)
            self._reserve(1, self.U, parent=current)
            self.E(parent=current)
            return current
    VALUE.min_size = RuleSize(1, 5)

    def VARYING(self, parent=None):
        with UnlexerRuleContext(self, 'VARYING', parent) as current:
            self._reserve(6, self.V, parent=current)
            self._reserve(5, self.A, parent=current)
            self._reserve(4, self.R, parent=current)
            self._reserve(3, self.Y, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.N, parent=current)
            self.G(parent=current)
            return current
    VARYING.min_size = RuleSize(1, 7)

    def WHEN(self, parent=None):
        with UnlexerRuleContext(self, 'WHEN', parent) as current:
            self._reserve(3, self.W, parent=current)
            self._reserve(2, self.H, parent=current)
            self._reserve(1, self.E, parent=current)
            self.N(parent=current)
            return current
    WHEN.min_size = RuleSize(1, 4)

    def WHILE(self, parent=None):
        with UnlexerRuleContext(self, 'WHILE', parent) as current:
            self._reserve(4, self.W, parent=current)
            self._reserve(3, self.H, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.L, parent=current)
            self.E(parent=current)
            return current
    WHILE.min_size = RuleSize(1, 5)

    def WITH(self, parent=None):
        with UnlexerRuleContext(self, 'WITH', parent) as current:
            self._reserve(3, self.W, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.T, parent=current)
            self.H(parent=current)
            return current
    WITH.min_size = RuleSize(1, 4)

    def UNTIL(self, parent=None):
        with UnlexerRuleContext(self, 'UNTIL', parent) as current:
            self._reserve(4, self.U, parent=current)
            self._reserve(3, self.N, parent=current)
            self._reserve(2, self.T, parent=current)
            self._reserve(1, self.I, parent=current)
            self.L(parent=current)
            return current
    UNTIL.min_size = RuleSize(1, 5)

    def AND(self, parent=None):
        with UnlexerRuleContext(self, 'AND', parent) as current:
            self._reserve(2, self.A, parent=current)
            self._reserve(1, self.N, parent=current)
            self.D(parent=current)
            return current
    AND.min_size = RuleSize(1, 3)

    def OR(self, parent=None):
        with UnlexerRuleContext(self, 'OR', parent) as current:
            self._reserve(1, self.O, parent=current)
            self.R(parent=current)
            return current
    OR.min_size = RuleSize(1, 2)

    def XOR(self, parent=None):
        with UnlexerRuleContext(self, 'XOR', parent) as current:
            self._reserve(2, self.X, parent=current)
            self._reserve(1, self.O, parent=current)
            self.R(parent=current)
            return current
    XOR.min_size = RuleSize(1, 3)

    def PLUS(self, parent=None):
        with UnlexerRuleContext(self, 'PLUS', parent) as current:
            current.src += '+'
            return current
    PLUS.min_size = RuleSize(0, 0)

    def MINUS(self, parent=None):
        with UnlexerRuleContext(self, 'MINUS', parent) as current:
            current.src += ' - '
            return current
    MINUS.min_size = RuleSize(0, 0)

    def DASH(self, parent=None):
        with UnlexerRuleContext(self, 'DASH', parent) as current:
            current.src += '-'
            return current
    DASH.min_size = RuleSize(0, 0)

    def MULT(self, parent=None):
        with UnlexerRuleContext(self, 'MULT', parent) as current:
            current.src += '*'
            return current
    MULT.min_size = RuleSize(0, 0)

    def DIV(self, parent=None):
        with UnlexerRuleContext(self, 'DIV', parent) as current:
            current.src += '/'
            return current
    DIV.min_size = RuleSize(0, 0)

    def EXP(self, parent=None):
        with UnlexerRuleContext(self, 'EXP', parent) as current:
            current.src += '**'
            return current
    EXP.min_size = RuleSize(0, 0)

    def EQ(self, parent=None):
        with UnlexerRuleContext(self, 'EQ', parent) as current:
            current.src += '='
            return current
    EQ.min_size = RuleSize(0, 0)

    def GT(self, parent=None):
        with UnlexerRuleContext(self, 'GT', parent) as current:
            current.src += '>'
            return current
    GT.min_size = RuleSize(0, 0)

    def ST(self, parent=None):
        with UnlexerRuleContext(self, 'ST', parent) as current:
            current.src += '<'
            return current
    ST.min_size = RuleSize(0, 0)

    def GE(self, parent=None):
        with UnlexerRuleContext(self, 'GE', parent) as current:
            current.src += '>='
            return current
    GE.min_size = RuleSize(0, 0)

    def SE(self, parent=None):
        with UnlexerRuleContext(self, 'SE', parent) as current:
            current.src += '<='
            return current
    SE.min_size = RuleSize(0, 0)

    def NUMERIC(self, parent=None):
        with UnlexerRuleContext(self, 'NUMERIC', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 2) as quant0:
                while quant0(current):
                    self.SIGN(parent=current)
            self.INT(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 3), 0) as quant1:
                while quant1(current):
                    self._reserve(2, self.SEPARATOR, parent=current)
                    self.INT(parent=current)
            return current
    NUMERIC.min_size = RuleSize(2, 2)

    def NONNUMERIC(self, parent=None):
        with UnlexerRuleContext(self, 'NONNUMERIC', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    current.src += '\''
                    with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                        while quant0(current):
                            with AlternationContext(self, 1, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 2), RuleSize(0, 0)), 0, (1, 1, 1, 1, 1, 1)) as alt1:
                                choice1 = alt1(current)
                                if choice1 == 0:
                                    self.SPECIAL(parent=current)
                                elif choice1 == 1:
                                    self.LETTER(parent=current)
                                elif choice1 == 2:
                                    self.DIGIT(parent=current)
                                elif choice1 == 3:
                                    self.QUOTE(parent=current)
                                elif choice1 == 4:
                                    self._reserve(1, self.APOST, parent=current)
                                    self.APOST(parent=current)
                                elif choice1 == 5:
                                    current.src += ' '
                    current.src += '\''
                elif choice0 == 1:
                    current.src += '"'
                    with QuantifierContext(self, 1, 1, inf, RuleSize(0, 0), 0) as quant1:
                        while quant1(current):
                            with AlternationContext(self, 2, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 2), RuleSize(0, 0)), 0, (1, 1, 1, 1, 1, 1)) as alt2:
                                choice2 = alt2(current)
                                if choice2 == 0:
                                    self.SPECIAL(parent=current)
                                elif choice2 == 1:
                                    self.LETTER(parent=current)
                                elif choice2 == 2:
                                    self.DIGIT(parent=current)
                                elif choice2 == 3:
                                    self.APOST(parent=current)
                                elif choice2 == 4:
                                    self._reserve(1, self.QUOTE, parent=current)
                                    self.QUOTE(parent=current)
                                elif choice2 == 5:
                                    current.src += ' '
                    current.src += '"'
            return current
    NONNUMERIC.min_size = RuleSize(0, 0)

    def IDENTIFIER(self, parent=None):
        with UnlexerRuleContext(self, 'IDENTIFIER', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 1) as quant0:
                while quant0(current):
                    self.DIGIT(parent=current)
                    with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                                [self.DIGIT, self.DASH][alt0(current)](parent=current)
            self.LETTER(parent=current)
            with QuantifierContext(self, 2, 0, inf, RuleSize(2, 2), 0) as quant2:
                while quant2(current):
                    with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 2) as quant3:
                        while quant3(current):
                            self.DASH(parent=current)
                    self.ALPHANUMERIC(parent=current)
            return current
    IDENTIFIER.min_size = RuleSize(1, 1)

    def FILENAME(self, parent=None):
        with UnlexerRuleContext(self, 'FILENAME', parent) as current:
            self.DATA_DIVISION_ID(parent=current)
            current.src += '.coffee'
            return current
    FILENAME.min_size = RuleSize(2, 2)

    def HIGHVALUES(self, parent=None):
        with UnlexerRuleContext(self, 'HIGHVALUES', parent) as current:
            self._reserve(10, self.H, parent=current)
            self._reserve(9, self.I, parent=current)
            self._reserve(8, self.G, parent=current)
            self._reserve(7, self.H, parent=current)
            self._reserve(6, self.DASH, parent=current)
            self._reserve(5, self.V, parent=current)
            self._reserve(4, self.A, parent=current)
            self._reserve(3, self.L, parent=current)
            self._reserve(2, self.U, parent=current)
            self._reserve(1, self.E, parent=current)
            self.S(parent=current)
            return current
    HIGHVALUES.min_size = RuleSize(1, 11)

    def LOWVALUES(self, parent=None):
        with UnlexerRuleContext(self, 'LOWVALUES', parent) as current:
            self._reserve(9, self.L, parent=current)
            self._reserve(8, self.O, parent=current)
            self._reserve(7, self.W, parent=current)
            self._reserve(6, self.DASH, parent=current)
            self._reserve(5, self.V, parent=current)
            self._reserve(4, self.A, parent=current)
            self._reserve(3, self.L, parent=current)
            self._reserve(2, self.U, parent=current)
            self._reserve(1, self.E, parent=current)
            self.S(parent=current)
            return current
    LOWVALUES.min_size = RuleSize(1, 10)

    def INT(self, parent=None):
        with UnlexerRuleContext(self, 'INT', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    self.DIGIT(parent=current)
            return current
    INT.min_size = RuleSize(1, 1)

    def ALPHANUMERIC(self, parent=None):
        with UnlexerRuleContext(self, 'ALPHANUMERIC', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                [self.LETTER, self.DIGIT][alt0(current)](parent=current)
            return current
    ALPHANUMERIC.min_size = RuleSize(1, 1)

    def LETTER(self, parent=None):
        with UnlexerRuleContext(self, 'LETTER', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[2])
            return current
    LETTER.min_size = RuleSize(0, 0)

    def DIGIT(self, parent=None):
        with UnlexerRuleContext(self, 'DIGIT', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[3])
            return current
    DIGIT.min_size = RuleSize(0, 0)

    def LBRACE(self, parent=None):
        with UnlexerRuleContext(self, 'LBRACE', parent) as current:
            current.src += '('
            return current
    LBRACE.min_size = RuleSize(0, 0)

    def RBRACE(self, parent=None):
        with UnlexerRuleContext(self, 'RBRACE', parent) as current:
            current.src += ')'
            return current
    RBRACE.min_size = RuleSize(0, 0)

    def WS(self, parent=None):
        with UnlexerRuleContext(self, 'WS', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[4])
            return current
    WS.min_size = RuleSize(0, 0)

    def SPECIAL(self, parent=None):
        with UnlexerRuleContext(self, 'SPECIAL', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[5])
            return current
    SPECIAL.min_size = RuleSize(0, 0)

    def APOST(self, parent=None):
        with UnlexerRuleContext(self, 'APOST', parent) as current:
            current.src += '\''
            return current
    APOST.min_size = RuleSize(0, 0)

    def QUOTE(self, parent=None):
        with UnlexerRuleContext(self, 'QUOTE', parent) as current:
            current.src += '"'
            return current
    QUOTE.min_size = RuleSize(0, 0)

    def SIGN(self, parent=None):
        with UnlexerRuleContext(self, 'SIGN', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[6])
            return current
    SIGN.min_size = RuleSize(0, 0)

    def SEPARATOR(self, parent=None):
        with UnlexerRuleContext(self, 'SEPARATOR', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[7])
            return current
    SEPARATOR.min_size = RuleSize(0, 0)

    def ID_DIV_CHAR(self, parent=None):
        with UnlexerRuleContext(self, 'ID_DIV_CHAR', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(0, 0)), 0, (1, 1, 1, 1, 1, 1, 1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.SPECIAL(parent=current)
                elif choice0 == 1:
                    self.LETTER(parent=current)
                elif choice0 == 2:
                    self.DIGIT(parent=current)
                elif choice0 == 3:
                    self.APOST(parent=current)
                elif choice0 == 4:
                    self.QUOTE(parent=current)
                elif choice0 == 5:
                    self.LBRACE(parent=current)
                elif choice0 == 6:
                    self.RBRACE(parent=current)
                elif choice0 == 7:
                    self.DASH(parent=current)
                elif choice0 == 8:
                    current.src += self._model.charset(current, 0, self._charsets[1])
            return current
    ID_DIV_CHAR.min_size = RuleSize(0, 0)

    def PATTERN_CHAR(self, parent=None):
        with UnlexerRuleContext(self, 'PATTERN_CHAR', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(0, 0)), 0, (1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.LETTER(parent=current)
                elif choice0 == 1:
                    self.DIGIT(parent=current)
                elif choice0 == 2:
                    current.src += self._model.charset(current, 0, self._charsets[8])
            return current
    PATTERN_CHAR.min_size = RuleSize(0, 0)

    def A(self, parent=None):
        with UnlexerRuleContext(self, 'A', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[9])
            return current
    A.min_size = RuleSize(0, 0)

    def B(self, parent=None):
        with UnlexerRuleContext(self, 'B', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[10])
            return current
    B.min_size = RuleSize(0, 0)

    def C(self, parent=None):
        with UnlexerRuleContext(self, 'C', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[11])
            return current
    C.min_size = RuleSize(0, 0)

    def D(self, parent=None):
        with UnlexerRuleContext(self, 'D', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[12])
            return current
    D.min_size = RuleSize(0, 0)

    def E(self, parent=None):
        with UnlexerRuleContext(self, 'E', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[13])
            return current
    E.min_size = RuleSize(0, 0)

    def F(self, parent=None):
        with UnlexerRuleContext(self, 'F', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[14])
            return current
    F.min_size = RuleSize(0, 0)

    def G(self, parent=None):
        with UnlexerRuleContext(self, 'G', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[15])
            return current
    G.min_size = RuleSize(0, 0)

    def H(self, parent=None):
        with UnlexerRuleContext(self, 'H', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[16])
            return current
    H.min_size = RuleSize(0, 0)

    def I(self, parent=None):
        with UnlexerRuleContext(self, 'I', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[17])
            return current
    I.min_size = RuleSize(0, 0)

    def J(self, parent=None):
        with UnlexerRuleContext(self, 'J', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[18])
            return current
    J.min_size = RuleSize(0, 0)

    def K(self, parent=None):
        with UnlexerRuleContext(self, 'K', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[19])
            return current
    K.min_size = RuleSize(0, 0)

    def L(self, parent=None):
        with UnlexerRuleContext(self, 'L', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[20])
            return current
    L.min_size = RuleSize(0, 0)

    def M(self, parent=None):
        with UnlexerRuleContext(self, 'M', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[21])
            return current
    M.min_size = RuleSize(0, 0)

    def N(self, parent=None):
        with UnlexerRuleContext(self, 'N', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[22])
            return current
    N.min_size = RuleSize(0, 0)

    def O(self, parent=None):
        with UnlexerRuleContext(self, 'O', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[23])
            return current
    O.min_size = RuleSize(0, 0)

    def P(self, parent=None):
        with UnlexerRuleContext(self, 'P', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[24])
            return current
    P.min_size = RuleSize(0, 0)

    def Q(self, parent=None):
        with UnlexerRuleContext(self, 'Q', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[25])
            return current
    Q.min_size = RuleSize(0, 0)

    def R(self, parent=None):
        with UnlexerRuleContext(self, 'R', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[26])
            return current
    R.min_size = RuleSize(0, 0)

    def S(self, parent=None):
        with UnlexerRuleContext(self, 'S', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[27])
            return current
    S.min_size = RuleSize(0, 0)

    def T(self, parent=None):
        with UnlexerRuleContext(self, 'T', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[28])
            return current
    T.min_size = RuleSize(0, 0)

    def U(self, parent=None):
        with UnlexerRuleContext(self, 'U', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[29])
            return current
    U.min_size = RuleSize(0, 0)

    def V(self, parent=None):
        with UnlexerRuleContext(self, 'V', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[30])
            return current
    V.min_size = RuleSize(0, 0)

    def W(self, parent=None):
        with UnlexerRuleContext(self, 'W', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[31])
            return current
    W.min_size = RuleSize(0, 0)

    def X(self, parent=None):
        with UnlexerRuleContext(self, 'X', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[32])
            return current
    X.min_size = RuleSize(0, 0)

    def Y(self, parent=None):
        with UnlexerRuleContext(self, 'Y', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[33])
            return current
    Y.min_size = RuleSize(0, 0)

    def Z(self, parent=None):
        with UnlexerRuleContext(self, 'Z', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[34])
            return current
    Z.min_size = RuleSize(0, 0)

    def TYPE_WS(self, parent=None):
        with UnlexerRuleContext(self, 'TYPE_WS', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[1])
            return current
    TYPE_WS.min_size = RuleSize(0, 0)

    def PICTURE(self, parent=None):
        with UnlexerRuleContext(self, 'PICTURE', parent) as current:
            self._reserve(6, self.P, parent=current)
            self._reserve(5, self.I, parent=current)
            self._reserve(4, self.C, parent=current)
            self._reserve(3, self.T, parent=current)
            self._reserve(2, self.U, parent=current)
            self._reserve(1, self.R, parent=current)
            self.E(parent=current)
            return current
    PICTURE.min_size = RuleSize(1, 7)

    def IS(self, parent=None):
        with UnlexerRuleContext(self, 'IS', parent) as current:
            self._reserve(1, self.I, parent=current)
            self.S(parent=current)
            return current
    IS.min_size = RuleSize(1, 2)

    def LIKE(self, parent=None):
        with UnlexerRuleContext(self, 'LIKE', parent) as current:
            self._reserve(3, self.L, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.K, parent=current)
            self.E(parent=current)
            return current
    LIKE.min_size = RuleSize(1, 4)

    def Q_OF(self, parent=None):
        with UnlexerRuleContext(self, 'Q_OF', parent) as current:
            self._reserve(1, self.O, parent=current)
            self.F(parent=current)
            return current
    Q_OF.min_size = RuleSize(1, 2)

    def OCCURS_CLAUSE(self, parent=None):
        with UnlexerRuleContext(self, 'OCCURS_CLAUSE', parent) as current:
            self._reserve(5, self.O, parent=current)
            self._reserve(4, self.C, parent=current)
            self._reserve(3, self.C, parent=current)
            self._reserve(2, self.U, parent=current)
            self._reserve(1, self.R, parent=current)
            self.S(parent=current)
            return current
    OCCURS_CLAUSE.min_size = RuleSize(1, 6)

    def REPRESENTATION(self, parent=None):
        with UnlexerRuleContext(self, 'REPRESENTATION', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                        while quant0(current):
                            current.src += self._model.charset(current, 0, self._charsets[35])
                            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 4), 0) as quant1:
                                while quant1(current):
                                    self._reserve(3, self.LBRACE, parent=current)
                                    self._reserve(1, self.INT, parent=current)
                                    self.RBRACE(parent=current)
                elif choice0 == 1:
                    with QuantifierContext(self, 2, 0, inf, RuleSize(0, 0), 0) as quant2:
                        while quant2(current):
                            current.src += self._model.charset(current, 1, self._charsets[35])
                            with QuantifierContext(self, 3, 0, 1, RuleSize(2, 4), 0) as quant3:
                                while quant3(current):
                                    self._reserve(3, self.LBRACE, parent=current)
                                    self._reserve(1, self.INT, parent=current)
                                    self.RBRACE(parent=current)
                    current.src += 'S'
                    with QuantifierContext(self, 4, 0, inf, RuleSize(0, 0), 0) as quant4:
                        while quant4(current):
                            current.src += self._model.charset(current, 2, self._charsets[35])
                            with QuantifierContext(self, 5, 0, 1, RuleSize(2, 4), 0) as quant5:
                                while quant5(current):
                                    self._reserve(3, self.LBRACE, parent=current)
                                    self._reserve(1, self.INT, parent=current)
                                    self.RBRACE(parent=current)
                    with QuantifierContext(self, 6, 0, 1, RuleSize(0, 0), 0) as quant6:
                        while quant6(current):
                            current.src += 'V'
                            with QuantifierContext(self, 7, 0, inf, RuleSize(0, 0), 0) as quant7:
                                while quant7(current):
                                    current.src += self._model.charset(current, 3, self._charsets[35])
                                    with QuantifierContext(self, 8, 0, 1, RuleSize(2, 4), 0) as quant8:
                                        while quant8(current):
                                            self._reserve(3, self.LBRACE, parent=current)
                                            self._reserve(1, self.INT, parent=current)
                                            self.RBRACE(parent=current)
                elif choice0 == 2:
                    with QuantifierContext(self, 9, 0, inf, RuleSize(0, 0), 0) as quant9:
                        while quant9(current):
                            current.src += self._model.charset(current, 4, self._charsets[35])
                            with QuantifierContext(self, 10, 0, 1, RuleSize(2, 4), 0) as quant10:
                                while quant10(current):
                                    self._reserve(3, self.LBRACE, parent=current)
                                    self._reserve(1, self.INT, parent=current)
                                    self.RBRACE(parent=current)
                    current.src += 'V'
                    with QuantifierContext(self, 11, 0, inf, RuleSize(0, 0), 0) as quant11:
                        while quant11(current):
                            current.src += self._model.charset(current, 5, self._charsets[35])
                            with QuantifierContext(self, 12, 0, 1, RuleSize(2, 4), 0) as quant12:
                                while quant12(current):
                                    self._reserve(3, self.LBRACE, parent=current)
                                    self._reserve(1, self.INT, parent=current)
                                    self.RBRACE(parent=current)
                    with QuantifierContext(self, 13, 0, 1, RuleSize(0, 0), 0) as quant13:
                        while quant13(current):
                            current.src += 'S'
                            with QuantifierContext(self, 14, 0, inf, RuleSize(0, 0), 0) as quant14:
                                while quant14(current):
                                    current.src += self._model.charset(current, 6, self._charsets[35])
                                    with QuantifierContext(self, 15, 0, 1, RuleSize(2, 4), 0) as quant15:
                                        while quant15(current):
                                            self._reserve(3, self.LBRACE, parent=current)
                                            self._reserve(1, self.INT, parent=current)
                                            self.RBRACE(parent=current)
            return current
    REPRESENTATION.min_size = RuleSize(0, 0)

    def TYPE_END(self, parent=None):
        with UnlexerRuleContext(self, 'TYPE_END', parent) as current:
            current.src += '.'
            return current
    TYPE_END.min_size = RuleSize(0, 0)

    def OCCURANCES_WS(self, parent=None):
        with UnlexerRuleContext(self, 'OCCURANCES_WS', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[1])
            return current
    OCCURANCES_WS.min_size = RuleSize(0, 0)

    def N_TIMES(self, parent=None):
        with UnlexerRuleContext(self, 'N_TIMES', parent) as current:
            self.INT(parent=current)
            return current
    N_TIMES.min_size = RuleSize(2, 2)

    def QID_WS(self, parent=None):
        with UnlexerRuleContext(self, 'QID_WS', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[1])
            return current
    QID_WS.min_size = RuleSize(0, 0)

    def ID_WS(self, parent=None):
        with UnlexerRuleContext(self, 'ID_WS', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[1])
            return current
    ID_WS.min_size = RuleSize(0, 0)

    def DATA_DIVISION_ID(self, parent=None):
        with UnlexerRuleContext(self, 'DATA_DIVISION_ID', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 1) as quant0:
                while quant0(current):
                    self.DIGIT(parent=current)
                    with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 0) as quant1:
                        while quant1(current):
                            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                                [self.DIGIT, self.DASH][alt0(current)](parent=current)
            self.LETTER(parent=current)
            with QuantifierContext(self, 2, 0, inf, RuleSize(2, 2), 0) as quant2:
                while quant2(current):
                    with QuantifierContext(self, 3, 0, inf, RuleSize(1, 1), 2) as quant3:
                        while quant3(current):
                            self.DASH(parent=current)
                    self.ALPHANUMERIC(parent=current)
            return current
    DATA_DIVISION_ID.min_size = RuleSize(1, 1)

    def LEVEL(self, parent=None):
        with UnlexerRuleContext(self, 'LEVEL', parent) as current:
            self._reserve(1, self.DIGIT, parent=current)
            self.DIGIT(parent=current)
            return current
    LEVEL.min_size = RuleSize(1, 2)

    def DATA_DIVISION_WS(self, parent=None):
        with UnlexerRuleContext(self, 'DATA_DIVISION_WS', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[4])
            return current
    DATA_DIVISION_WS.min_size = RuleSize(0, 0)

    def DATA_DIVISION_END(self, parent=None):
        with UnlexerRuleContext(self, 'DATA_DIVISION_END', parent) as current:
            current.src += '~'
            return current
    DATA_DIVISION_END.min_size = RuleSize(0, 0)

    def DATA_PARAGRAPH(self, parent=None):
        with UnlexerRuleContext(self, 'DATA_PARAGRAPH', parent) as current:
            self.PARAGRAPH(parent=current)
            return current
    DATA_PARAGRAPH.min_size = RuleSize(1, 1)

    def program(self, parent=None):
        with UnparserRuleContext(self, 'program', parent) as current:
            self._reserve(27, self.PARAGRAPH, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(3, 21), 27) as quant0:
                while quant0(current):
                    self._reserve(7, self.DATA_DIVISION_, parent=current)
                    with QuantifierContext(self, 1, 1, inf, RuleSize(3, 6), 1) as quant1:
                        while quant1(current):
                            self.data(parent=current)
                    self.DATA_DIVISION_END(parent=current)
            self._reserve(7, self.PROCEDURE_DIVISION_, parent=current)
            with QuantifierContext(self, 2, 0, 1, RuleSize(4, 21), 7) as quant2:
                while quant2(current):
                    self.using(parent=current)
            with QuantifierContext(self, 3, 1, inf, RuleSize(6, 6), 1) as quant3:
                while quant3(current):
                    self.paragraph(parent=current)
            self.EOF(parent=current)
            return current
    program.min_size = RuleSize(6, 28)

    def using(self, parent=None):
        with UnparserRuleContext(self, 'using', parent) as current:
            self._reserve(15, self.USING, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 15), 0) as quant0:
                while quant0(current):
                    self._reserve(12, self.BY, parent=current)
                    self._reserve(2, self.REFERENCE, parent=current)
                    self.identifier(parent=current)
                    with QuantifierContext(self, 1, 0, 1, RuleSize(2, 12), 0) as quant1:
                        while quant1(current):
                            self._reserve(9, self.BY, parent=current)
                            self._reserve(1, self.CONTENT, parent=current)
                            self.atomic(parent=current)
                    with QuantifierContext(self, 2, 0, 1, RuleSize(2, 10), 0) as quant2:
                        while quant2(current):
                            self._reserve(7, self.BY, parent=current)
                            self._reserve(1, self.VALUE, parent=current)
                            self.atomic(parent=current)
            return current
    using.min_size = RuleSize(3, 21)

    def data(self, parent=None):
        with UnparserRuleContext(self, 'data', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 2), 6) as quant0:
                while quant0(current):
                    self.DATA_PARAGRAPH(parent=current)
            self._reserve(3, self.LEVEL, parent=current)
            self._reserve(1, self.DATA_DIVISION_ID, parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(4, 7), 1) as quant1:
                while quant1(current):
                    self.type(parent=current)
            with QuantifierContext(self, 2, 0, 1, RuleSize(3, 10), 1) as quant2:
                while quant2(current):
                    self._reserve(3, self.OCCURS_CLAUSE, parent=current)
                    self.N_TIMES(parent=current)
            self.TYPE_END(parent=current)
            return current
    data.min_size = RuleSize(2, 6)

    def paragraph(self, parent=None):
        with UnparserRuleContext(self, 'paragraph', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 4), 6) as quant0:
                while quant0(current):
                    self._reserve(3, self.PARAGRAPH, parent=current)
                    self._reserve(1, self.IDENTIFIER, parent=current)
                    self.DOT(parent=current)
            with QuantifierContext(self, 1, 1, inf, RuleSize(5, 6), 0) as quant1:
                while quant1(current):
                    self.sentence(parent=current)
            return current
    paragraph.min_size = RuleSize(5, 6)

    def sentence(self, parent=None):
        with UnparserRuleContext(self, 'sentence', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(4, 5), 1) as quant0:
                while quant0(current):
                    self.statement(parent=current)
            self.DOT(parent=current)
            return current
    sentence.min_size = RuleSize(4, 6)

    def statement(self, parent=None):
        with UnparserRuleContext(self, 'statement', parent) as current:
            with AlternationContext(self, 0, (RuleSize(4, 9), RuleSize(3, 9), RuleSize(4, 24), RuleSize(4, 8), RuleSize(4, 9), RuleSize(3, 14), RuleSize(5, 20), RuleSize(4, 8), RuleSize(5, 16), RuleSize(3, 9), RuleSize(4, 11), RuleSize(3, 14), RuleSize(3, 14), RuleSize(4, 10), RuleSize(3, 18), RuleSize(3, 5), RuleSize(3, 16)), 0, (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)) as alt0:
                [self.statement_acceptST, self.statement_addST, self.statement_alterST, self.statement_callST, self.statement_displayST, self.statement_divideST, self.statement_evaluateST, self.statement_gotoST, self.statement_ifST, self.statement_loopST, self.statement_moveST, self.statement_multiplyST, self.statement_nextST, self.statement_performST, self.statement_signalST, self.statement_stopST, self.statement_subtractST][alt0(current)](parent=current)
            return current
    statement.min_size = RuleSize(3, 5)

    def paragraphname(self, parent=None):
        with UnparserRuleContext(self, 'paragraphname', parent) as current:
            self.IDENTIFIER(parent=current)
            return current
    paragraphname.min_size = RuleSize(2, 2)

    def displayExpression(self, parent=None):
        with UnparserRuleContext(self, 'displayExpression', parent) as current:
            self.atomic(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 14), 0) as quant0:
                while quant0(current):
                    self._reserve(4, self.DELIMITED, parent=current)
                    self._reserve(1, self.BY, parent=current)
                    with AlternationContext(self, 0, (RuleSize(2, 6), RuleSize(2, 5), RuleSize(2, 3), RuleSize(1, 1)), 0, (1, 1, 1, 1)) as alt0:
                        choice0 = alt0(current)
                        if choice0 == 0:
                            self.SPACE(parent=current)
                        elif choice0 == 1:
                            self.SIZE(parent=current)
                        elif choice0 == 2:
                            with AlternationContext(self, 1, (RuleSize(3, 3), RuleSize(2, 3)), 0, (1, 1)) as alt1:
                                [self.NUMERIC, self.LEVEL][alt1(current)](parent=current)
                        elif choice0 == 3:
                            self.NONNUMERIC(parent=current)
            return current
    displayExpression.min_size = RuleSize(2, 1)

    def moveExpression(self, parent=None):
        with UnparserRuleContext(self, 'moveExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 12), RuleSize(2, 11), RuleSize(2, 7), RuleSize(2, 1)), 0, (1, 1, 1, 1)) as alt0:
                [self.HIGHVALUES, self.LOWVALUES, self.SPACES, self.atomic][alt0(current)](parent=current)
            return current
    moveExpression.min_size = RuleSize(2, 1)

    def whenBlock(self, parent=None):
        with UnparserRuleContext(self, 'whenBlock', parent) as current:
            self._reserve(1, self.WHEN, parent=current)
            with AlternationContext(self, 0, (RuleSize(2, 6), RuleSize(3, 1)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.OTHER(parent=current)
                elif choice0 == 1:
                    with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                        while quant0(current):
                            self.whenStatement(parent=current)
                    with QuantifierContext(self, 1, 0, inf, RuleSize(4, 6), 0) as quant1:
                        while quant1(current):
                            self.alsoWhen(parent=current)
            return current
    whenBlock.min_size = RuleSize(2, 6)

    def alsoWhen(self, parent=None):
        with UnparserRuleContext(self, 'alsoWhen', parent) as current:
            self._reserve(1, self.ALSO, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.whenStatement(parent=current)
            return current
    alsoWhen.min_size = RuleSize(3, 6)

    def whenStatement(self, parent=None):
        with UnparserRuleContext(self, 'whenStatement', parent) as current:
            self.atomic(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 9), 0) as quant0:
                while quant0(current):
                    self._reserve(1, self.THROUGH, parent=current)
                    self.atomic(parent=current)
            return current
    whenStatement.min_size = RuleSize(2, 1)

    def anyExpression(self, parent=None):
        with UnparserRuleContext(self, 'anyExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(4, 1), RuleSize(3, 1), RuleSize(4, 3)), 0, (1, 1, 1)) as alt0:
                [self.arithmeticExpression, self.stringExpression, self.booleanExpression][alt0(current)](parent=current)
            return current
    anyExpression.min_size = RuleSize(3, 1)

    def arithmeticExpression(self, parent=None):
        with UnparserRuleContext(self, 'arithmeticExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 1), RuleSize(5, 3)), 0, (1, 1)) as alt0:
                [self.arithmeticExpression_singleArithmeticExpression, self.arithmeticExpression_multArithmeticExpression][alt0(current)](parent=current)
            return current
    arithmeticExpression.min_size = RuleSize(3, 1)

    def stringExpression(self, parent=None):
        with UnparserRuleContext(self, 'stringExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(3, 3)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.atomic(parent=current)
                elif choice0 == 1:
                    self._reserve(2, self.stringExpression, parent=current)
                    self._reserve(1, self.PLUS, parent=current)
                    self.stringExpression(parent=current)
            return current
    stringExpression.min_size = RuleSize(2, 1)

    def booleanExpression(self, parent=None):
        with UnparserRuleContext(self, 'booleanExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 5), RuleSize(3, 6), RuleSize(5, 3), RuleSize(5, 5), RuleSize(5, 9)), 0, (1, 1, 1, 1, 1)) as alt0:
                [self.booleanExpression_trueExpr, self.booleanExpression_falseExpr, self.booleanExpression_arithmeticBoolean, self.booleanExpression_notBoolean, self.booleanExpression_booleanExpr][alt0(current)](parent=current)
            return current
    booleanExpression.min_size = RuleSize(3, 3)

    def contractedBoolean(self, parent=None):
        with UnparserRuleContext(self, 'contractedBoolean', parent) as current:
            with AlternationContext(self, 0, (RuleSize(5, 1), RuleSize(5, 2)), 0, (1, 1)) as alt0:
                [self.contractedBoolean_contractedArithmetic, self.contractedBoolean_contractedComparison][alt0(current)](parent=current)
            return current
    contractedBoolean.min_size = RuleSize(5, 1)

    def loopStatement(self, parent=None):
        with UnparserRuleContext(self, 'loopStatement', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 8), RuleSize(5, 9), RuleSize(5, 9), RuleSize(5, 5)), 0, (1, 1, 1, 1)) as alt0:
                [self.loopStatement_varyingLoop, self.loopStatement_whileLoop, self.loopStatement_untilLoop, self.loopStatement_statementLoop][alt0(current)](parent=current)
            return current
    loopStatement.min_size = RuleSize(3, 5)

    def comparisonOp(self, parent=None):
        with UnparserRuleContext(self, 'comparisonOp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1, 1, 1, 1)) as alt0:
                [self.EQ, self.GT, self.ST, self.GE, self.SE][alt0(current)](parent=current)
            return current
    comparisonOp.min_size = RuleSize(1, 1)

    def booleanOp(self, parent=None):
        with UnparserRuleContext(self, 'booleanOp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 3), RuleSize(2, 4), RuleSize(2, 4)), 0, (1, 1, 1)) as alt0:
                [self.OR, self.AND, self.XOR][alt0(current)](parent=current)
            return current
    booleanOp.min_size = RuleSize(2, 3)

    def arithmeticOp(self, parent=None):
        with UnparserRuleContext(self, 'arithmeticOp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1, 1, 1, 1)) as alt0:
                [self.PLUS, self.MINUS, self.MULT, self.DIV, self.EXP][alt0(current)](parent=current)
            return current
    arithmeticOp.min_size = RuleSize(1, 1)

    def atomic(self, parent=None):
        with UnparserRuleContext(self, 'atomic', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 3), RuleSize(1, 1), RuleSize(3, 2)), 0, (1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    with AlternationContext(self, 1, (RuleSize(3, 3), RuleSize(2, 3)), 0, (1, 1)) as alt1:
                        [self.NUMERIC, self.LEVEL][alt1(current)](parent=current)
                elif choice0 == 1:
                    self.NONNUMERIC(parent=current)
                elif choice0 == 2:
                    self.identifier(parent=current)
            return current
    atomic.min_size = RuleSize(1, 1)

    def identifier(self, parent=None):
        with UnparserRuleContext(self, 'identifier', parent) as current:
            self.IDENTIFIER(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(4, 4), 0) as quant0:
                while quant0(current):
                    self.array_id(parent=current)
            with QuantifierContext(self, 1, 0, inf, RuleSize(3, 5), 0) as quant1:
                while quant1(current):
                    self.tailId(parent=current)
            return current
    identifier.min_size = RuleSize(2, 2)

    def tailId(self, parent=None):
        with UnparserRuleContext(self, 'tailId', parent) as current:
            self._reserve(2, self.OF, parent=current)
            self.IDENTIFIER(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(4, 4), 0) as quant0:
                while quant0(current):
                    self.array_id(parent=current)
            return current
    tailId.min_size = RuleSize(2, 5)

    def array_id(self, parent=None):
        with UnparserRuleContext(self, 'array_id', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 5), RuleSize(3, 4)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.ARRAY_N(parent=current)
                elif choice0 == 1:
                    self._reserve(3, self.LBRACE, parent=current)
                    self._reserve(1, self.identifier, parent=current)
                    self.RBRACE(parent=current)
            return current
    array_id.min_size = RuleSize(3, 4)

    def type(self, parent=None):
        with UnparserRuleContext(self, 'type', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 12), RuleSize(3, 7)), 0, (1, 1)) as alt0:
                [self.type_picture, self.type_likeId][alt0(current)](parent=current)
            return current
    type.min_size = RuleSize(3, 7)

    def statement_acceptST(self, parent=None):
        with UnparserRuleContext(self, 'statement_acceptST', parent) as current:
            self._reserve(2, self.ACCEPT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 2), 0) as quant0:
                while quant0(current):
                    self.identifier(parent=current)
            return current
    statement_acceptST.min_size = RuleSize(3, 9)

    def statement_addST(self, parent=None):
        local_ctx = dict(FIRST=[], SECOND=[])
        with UnparserRuleContext(self, 'statement_addST', parent) as current:
            self._reserve(5, self.ADD, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(2, 1), 4) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
                    local_ctx['FIRST'].append(current.last_child)
            self._reserve(1, self.TO, parent=current)
            self.atomic(parent=current)
            local_ctx['SECOND'].append(current.last_child)
            with QuantifierContext(self, 1, 0, inf, RuleSize(3, 9), 0) as quant1:
                while quant1(current):
                    self._reserve(2, self.GIVING, parent=current)
                    self.identifier(parent=current)
            return current
    statement_addST.min_size = RuleSize(2, 9)

    def statement_alterST(self, parent=None):
        with UnparserRuleContext(self, 'statement_alterST', parent) as current:
            self._reserve(18, self.ALTER, parent=current)
            self._reserve(16, self.identifier, parent=current)
            self._reserve(13, self.TO, parent=current)
            self._reserve(5, self.PROCEED, parent=current)
            self._reserve(2, self.TO, parent=current)
            self.identifier(parent=current)
            return current
    statement_alterST.min_size = RuleSize(3, 24)

    def statement_callST(self, parent=None):
        with UnparserRuleContext(self, 'statement_callST', parent) as current:
            self._reserve(3, self.CALL, parent=current)
            self.FILENAME(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(4, 21), 0) as quant0:
                while quant0(current):
                    self.using(parent=current)
            return current
    statement_callST.min_size = RuleSize(3, 8)

    def statement_displayST(self, parent=None):
        with UnparserRuleContext(self, 'statement_displayST', parent) as current:
            self._reserve(1, self.DISPLAY, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.displayExpression(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 18), 0) as quant1:
                while quant1(current):
                    self._reserve(13, self.WITH, parent=current)
                    self._reserve(10, self.NO, parent=current)
                    self.ADVANCING(parent=current)
            return current
    statement_displayST.min_size = RuleSize(3, 9)

    def statement_divideST(self, parent=None):
        local_ctx = dict(FIRST=None, SECOND=[], THIRD=[], REM=None)
        with UnparserRuleContext(self, 'statement_divideST', parent) as current:
            self._reserve(7, self.DIVIDE, parent=current)
            self._reserve(6, self.atomic, parent=current)
            local_ctx['FIRST'] = current.last_child
            self._reserve(1, self.INTO, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(2, 1), 0) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
                    local_ctx['SECOND'].append(current.last_child)
            with QuantifierContext(self, 1, 0, 1, RuleSize(3, 9), 0) as quant1:
                while quant1(current):
                    self._reserve(2, self.GIVING, parent=current)
                    with QuantifierContext(self, 2, 1, inf, RuleSize(3, 2), 0) as quant2:
                        while quant2(current):
                            self.identifier(parent=current)
                            local_ctx['THIRD'].append(current.last_child)
            with QuantifierContext(self, 3, 0, 1, RuleSize(3, 12), 0) as quant3:
                while quant3(current):
                    self._reserve(2, self.REMAINDER, parent=current)
                    self.identifier(parent=current)
                    local_ctx['REM'] = current.last_child
            return current
    statement_divideST.min_size = RuleSize(2, 14)

    def statement_evaluateST(self, parent=None):
        local_ctx = dict(EXECUTE=[])
        with UnparserRuleContext(self, 'statement_evaluateST', parent) as current:
            self._reserve(11, self.EVALUATE, parent=current)
            self._reserve(10, self.anyExpression, parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(4, 6), 10) as quant0:
                while quant0(current):
                    self._reserve(1, self.ALSO, parent=current)
                    self.anyExpression(parent=current)
            with QuantifierContext(self, 1, 1, inf, RuleSize(3, 6), 4) as quant1:
                while quant1(current):
                    self.whenBlock(parent=current)
                    with QuantifierContext(self, 2, 0, inf, RuleSize(4, 5), 0) as quant2:
                        while quant2(current):
                            self.statement(parent=current)
                            local_ctx['EXECUTE'].append(current.last_child)
            self.END(parent=current)
            return current
    statement_evaluateST.min_size = RuleSize(4, 20)

    def statement_gotoST(self, parent=None):
        with UnparserRuleContext(self, 'statement_gotoST', parent) as current:
            self._reserve(5, self.GO, parent=current)
            self._reserve(2, self.TO, parent=current)
            self.paragraphname(parent=current)
            return current
    statement_gotoST.min_size = RuleSize(3, 8)

    def statement_ifST(self, parent=None):
        local_ctx = dict(TS=[], ES=[])
        with UnparserRuleContext(self, 'statement_ifST', parent) as current:
            self._reserve(13, self.IF, parent=current)
            self._reserve(10, self.booleanExpression, parent=current)
            self._reserve(5, self.THEN, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(4, 5), 0) as quant0:
                while quant0(current):
                    self.statement(parent=current)
                    local_ctx['TS'].append(current.last_child)
            with QuantifierContext(self, 1, 0, 1, RuleSize(4, 10), 0) as quant1:
                while quant1(current):
                    self._reserve(5, self.ELSE, parent=current)
                    with QuantifierContext(self, 2, 1, inf, RuleSize(4, 5), 0) as quant2:
                        while quant2(current):
                            self.statement(parent=current)
                            local_ctx['ES'].append(current.last_child)
                    with QuantifierContext(self, 3, 0, 1, RuleSize(1, 1), 0) as quant3:
                        while quant3(current):
                            self.DOT(parent=current)
            with QuantifierContext(self, 4, 0, 1, RuleSize(2, 4), 0) as quant4:
                while quant4(current):
                    self.END(parent=current)
            return current
    statement_ifST.min_size = RuleSize(4, 16)

    def statement_loopST(self, parent=None):
        with UnparserRuleContext(self, 'statement_loopST', parent) as current:
            self._reserve(4, self.LOOP, parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(4, 5), 4) as quant0:
                while quant0(current):
                    self.loopStatement(parent=current)
            self.END(parent=current)
            return current
    statement_loopST.min_size = RuleSize(2, 9)

    def statement_moveST(self, parent=None):
        with UnparserRuleContext(self, 'statement_moveST', parent) as current:
            self._reserve(6, self.MOVE, parent=current)
            self._reserve(5, self.moveExpression, parent=current)
            self._reserve(2, self.TO, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 2), 0) as quant0:
                while quant0(current):
                    self.identifier(parent=current)
            return current
    statement_moveST.min_size = RuleSize(3, 11)

    def statement_multiplyST(self, parent=None):
        local_ctx = dict(FIRST=None, SECOND=[])
        with UnparserRuleContext(self, 'statement_multiplyST', parent) as current:
            self._reserve(5, self.MULTIPLY, parent=current)
            self._reserve(4, self.atomic, parent=current)
            local_ctx['FIRST'] = current.last_child
            self._reserve(1, self.BY, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(2, 1), 0) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
                    local_ctx['SECOND'].append(current.last_child)
            with QuantifierContext(self, 1, 0, 1, RuleSize(3, 9), 0) as quant1:
                while quant1(current):
                    self._reserve(2, self.GIVING, parent=current)
                    self.identifier(parent=current)
            return current
    statement_multiplyST.min_size = RuleSize(2, 14)

    def statement_nextST(self, parent=None):
        with UnparserRuleContext(self, 'statement_nextST', parent) as current:
            self._reserve(9, self.NEXT, parent=current)
            self.SENTENCE(parent=current)
            return current
    statement_nextST.min_size = RuleSize(2, 14)

    def statement_performST(self, parent=None):
        with UnparserRuleContext(self, 'statement_performST', parent) as current:
            self._reserve(2, self.PERFORM, parent=current)
            self.paragraphname(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(3, 10), 0) as quant0:
                while quant0(current):
                    self._reserve(2, self.THROUGH, parent=current)
                    self.paragraphname(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 7), 0) as quant1:
                while quant1(current):
                    self._reserve(6, self.atomic, parent=current)
                    self.TIMES(parent=current)
            return current
    statement_performST.min_size = RuleSize(3, 10)

    def statement_signalST(self, parent=None):
        with UnparserRuleContext(self, 'statement_signalST', parent) as current:
            self._reserve(11, self.SIGNAL, parent=current)
            with AlternationContext(self, 0, (RuleSize(2, 4), RuleSize(3, 2)), 9, (1, 1)) as alt0:
                [self.OFF, self.paragraphname][alt0(current)](parent=current)
            self._reserve(6, self.ON, parent=current)
            self.ERROR(parent=current)
            return current
    statement_signalST.min_size = RuleSize(2, 18)

    def statement_stopST(self, parent=None):
        with UnparserRuleContext(self, 'statement_stopST', parent) as current:
            self.STOP(parent=current)
            return current
    statement_stopST.min_size = RuleSize(2, 5)

    def statement_subtractST(self, parent=None):
        local_ctx = dict(FIRST=[], SECOND=[])
        with UnparserRuleContext(self, 'statement_subtractST', parent) as current:
            self._reserve(7, self.SUBTRACT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(2, 1), 6) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
                    local_ctx['FIRST'].append(current.last_child)
            self._reserve(1, self.FROM, parent=current)
            with QuantifierContext(self, 1, 1, inf, RuleSize(2, 1), 0) as quant1:
                while quant1(current):
                    self.atomic(parent=current)
                    local_ctx['SECOND'].append(current.last_child)
            with QuantifierContext(self, 2, 0, inf, RuleSize(3, 9), 0) as quant2:
                while quant2(current):
                    self._reserve(2, self.GIVING, parent=current)
                    self.identifier(parent=current)
            return current
    statement_subtractST.min_size = RuleSize(2, 16)

    def arithmeticExpression_singleArithmeticExpression(self, parent=None):
        with UnparserRuleContext(self, 'arithmeticExpression_singleArithmeticExpression', parent) as current:
            self.atomic(parent=current)
            return current
    arithmeticExpression_singleArithmeticExpression.min_size = RuleSize(2, 1)

    def arithmeticExpression_multArithmeticExpression(self, parent=None):
        with UnparserRuleContext(self, 'arithmeticExpression_multArithmeticExpression', parent) as current:
            self._reserve(2, self.arithmeticExpression, parent=current)
            self._reserve(1, self.arithmeticOp, parent=current)
            self.arithmeticExpression(parent=current)
            return current
    arithmeticExpression_multArithmeticExpression.min_size = RuleSize(4, 3)

    def booleanExpression_trueExpr(self, parent=None):
        with UnparserRuleContext(self, 'booleanExpression_trueExpr', parent) as current:
            self.TRUE(parent=current)
            return current
    booleanExpression_trueExpr.min_size = RuleSize(2, 5)

    def booleanExpression_falseExpr(self, parent=None):
        with UnparserRuleContext(self, 'booleanExpression_falseExpr', parent) as current:
            self.FALSE(parent=current)
            return current
    booleanExpression_falseExpr.min_size = RuleSize(2, 6)

    def booleanExpression_arithmeticBoolean(self, parent=None):
        with UnparserRuleContext(self, 'booleanExpression_arithmeticBoolean', parent) as current:
            self._reserve(2, self.arithmeticExpression, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 4), 2) as quant0:
                while quant0(current):
                    self.NOT(parent=current)
            self._reserve(1, self.comparisonOp, parent=current)
            self.arithmeticExpression(parent=current)
            with QuantifierContext(self, 1, 0, inf, RuleSize(6, 4), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.booleanOp, parent=current)
                    self.contractedBoolean(parent=current)
            return current
    booleanExpression_arithmeticBoolean.min_size = RuleSize(4, 3)

    def booleanExpression_notBoolean(self, parent=None):
        with UnparserRuleContext(self, 'booleanExpression_notBoolean', parent) as current:
            self._reserve(1, self.NOT, parent=current)
            with AlternationContext(self, 0, (RuleSize(4, 3), RuleSize(6, 1)), 0, (1, 1)) as alt0:
                [self.booleanExpression, self.contractedBoolean][alt0(current)](parent=current)
            return current
    booleanExpression_notBoolean.min_size = RuleSize(4, 5)

    def booleanExpression_booleanExpr(self, parent=None):
        with UnparserRuleContext(self, 'booleanExpression_booleanExpr', parent) as current:
            self._reserve(6, self.booleanExpression, parent=current)
            self._reserve(3, self.booleanOp, parent=current)
            self.booleanExpression(parent=current)
            return current
    booleanExpression_booleanExpr.min_size = RuleSize(4, 9)

    def contractedBoolean_contractedArithmetic(self, parent=None):
        with UnparserRuleContext(self, 'contractedBoolean_contractedArithmetic', parent) as current:
            self.arithmeticExpression(parent=current)
            return current
    contractedBoolean_contractedArithmetic.min_size = RuleSize(4, 1)

    def contractedBoolean_contractedComparison(self, parent=None):
        with UnparserRuleContext(self, 'contractedBoolean_contractedComparison', parent) as current:
            self._reserve(1, self.comparisonOp, parent=current)
            self.arithmeticExpression(parent=current)
            return current
    contractedBoolean_contractedComparison.min_size = RuleSize(4, 2)

    def loopStatement_varyingLoop(self, parent=None):
        with UnparserRuleContext(self, 'loopStatement_varyingLoop', parent) as current:
            self.VARYING(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(3, 2), 0) as quant0:
                while quant0(current):
                    self.identifier(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 6), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.FROM, parent=current)
                    self.atomic(parent=current)
            with QuantifierContext(self, 2, 0, 1, RuleSize(2, 4), 0) as quant2:
                while quant2(current):
                    self._reserve(1, self.TO, parent=current)
                    self.atomic(parent=current)
            with QuantifierContext(self, 3, 0, 1, RuleSize(2, 4), 0) as quant3:
                while quant3(current):
                    self._reserve(1, self.BY, parent=current)
                    self.atomic(parent=current)
            return current
    loopStatement_varyingLoop.min_size = RuleSize(2, 8)

    def loopStatement_whileLoop(self, parent=None):
        with UnparserRuleContext(self, 'loopStatement_whileLoop', parent) as current:
            self._reserve(3, self.WHILE, parent=current)
            self.booleanExpression(parent=current)
            return current
    loopStatement_whileLoop.min_size = RuleSize(4, 9)

    def loopStatement_untilLoop(self, parent=None):
        with UnparserRuleContext(self, 'loopStatement_untilLoop', parent) as current:
            self._reserve(3, self.UNTIL, parent=current)
            self.booleanExpression(parent=current)
            return current
    loopStatement_untilLoop.min_size = RuleSize(4, 9)

    def loopStatement_statementLoop(self, parent=None):
        with UnparserRuleContext(self, 'loopStatement_statementLoop', parent) as current:
            self.statement(parent=current)
            return current
    loopStatement_statementLoop.min_size = RuleSize(4, 5)

    def type_picture(self, parent=None):
        with UnparserRuleContext(self, 'type_picture', parent) as current:
            self._reserve(4, self.PICTURE, parent=current)
            self._reserve(1, self.IS, parent=current)
            self.REPRESENTATION(parent=current)
            return current
    type_picture.min_size = RuleSize(2, 12)

    def type_likeId(self, parent=None):
        with UnparserRuleContext(self, 'type_likeId', parent) as current:
            self._reserve(2, self.LIKE, parent=current)
            self.DATA_DIVISION_ID(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(2, 5), 0) as quant0:
                while quant0(current):
                    self._reserve(2, self.Q_OF, parent=current)
                    self.DATA_DIVISION_ID(parent=current)
            return current
    type_likeId.min_size = RuleSize(2, 7)

    _default_rule = program

    _charsets = {
        0: list(itertools.chain.from_iterable([range(0x20, 0x7f)])),
        1: list(itertools.chain.from_iterable([range(0x9, 0xa), range(0x20, 0x21)])),
        2: list(itertools.chain.from_iterable([range(0x41, 0x5b), range(0x61, 0x7b)])),
        3: list(itertools.chain.from_iterable([range(0x30, 0x3a)])),
        4: list(itertools.chain.from_iterable([range(0x9, 0xa), range(0xa, 0xb), range(0xd, 0xe), range(0x20, 0x21)])),
        5: list(itertools.chain.from_iterable([range(0x24, 0x25), range(0x2a, 0x2b), range(0x2b, 0x2c), range(0x2c, 0x2d), range(0x2e, 0x2f), range(0x2f, 0x30), range(0x3a, 0x3b), range(0x3b, 0x3c), range(0x3c, 0x3d), range(0x3d, 0x3e), range(0x3e, 0x3f)])),
        6: list(itertools.chain.from_iterable([range(0x2b, 0x2c), range(0x2d, 0x2e)])),
        7: list(itertools.chain.from_iterable([range(0x2c, 0x2d), range(0x2e, 0x2f)])),
        8: list(itertools.chain.from_iterable([range(0x9, 0xa), range(0x20, 0x21), range(0x22, 0x23), range(0x24, 0x25), range(0x27, 0x28), range(0x28, 0x29), range(0x29, 0x2a), range(0x2a, 0x2b), range(0x2b, 0x2c), range(0x2c, 0x2d), range(0x2d, 0x2e), range(0x2e, 0x2f), range(0x2f, 0x30), range(0x3a, 0x3b), range(0x3b, 0x3c), range(0x3e, 0x3f)])),
        9: list(itertools.chain.from_iterable([range(0x41, 0x42), range(0x61, 0x62)])),
        10: list(itertools.chain.from_iterable([range(0x42, 0x43), range(0x62, 0x63)])),
        11: list(itertools.chain.from_iterable([range(0x43, 0x44), range(0x63, 0x64)])),
        12: list(itertools.chain.from_iterable([range(0x44, 0x45), range(0x64, 0x65)])),
        13: list(itertools.chain.from_iterable([range(0x45, 0x46), range(0x65, 0x66)])),
        14: list(itertools.chain.from_iterable([range(0x46, 0x47), range(0x66, 0x67)])),
        15: list(itertools.chain.from_iterable([range(0x47, 0x48), range(0x67, 0x68)])),
        16: list(itertools.chain.from_iterable([range(0x48, 0x49), range(0x68, 0x69)])),
        17: list(itertools.chain.from_iterable([range(0x49, 0x4a), range(0x69, 0x6a)])),
        18: list(itertools.chain.from_iterable([range(0x4a, 0x4b), range(0x6a, 0x6b)])),
        19: list(itertools.chain.from_iterable([range(0x4b, 0x4c), range(0x6b, 0x6c)])),
        20: list(itertools.chain.from_iterable([range(0x4c, 0x4d), range(0x6c, 0x6d)])),
        21: list(itertools.chain.from_iterable([range(0x4d, 0x4e), range(0x6d, 0x6e)])),
        22: list(itertools.chain.from_iterable([range(0x4e, 0x4f), range(0x6e, 0x6f)])),
        23: list(itertools.chain.from_iterable([range(0x4f, 0x50), range(0x6f, 0x70)])),
        24: list(itertools.chain.from_iterable([range(0x50, 0x51), range(0x70, 0x71)])),
        25: list(itertools.chain.from_iterable([range(0x51, 0x52), range(0x71, 0x72)])),
        26: list(itertools.chain.from_iterable([range(0x52, 0x53), range(0x72, 0x73)])),
        27: list(itertools.chain.from_iterable([range(0x53, 0x54), range(0x73, 0x74)])),
        28: list(itertools.chain.from_iterable([range(0x54, 0x55), range(0x74, 0x75)])),
        29: list(itertools.chain.from_iterable([range(0x55, 0x56), range(0x75, 0x76)])),
        30: list(itertools.chain.from_iterable([range(0x56, 0x57), range(0x76, 0x77)])),
        31: list(itertools.chain.from_iterable([range(0x57, 0x58), range(0x77, 0x78)])),
        32: list(itertools.chain.from_iterable([range(0x58, 0x59), range(0x78, 0x79)])),
        33: list(itertools.chain.from_iterable([range(0x59, 0x5a), range(0x79, 0x7a)])),
        34: list(itertools.chain.from_iterable([range(0x5a, 0x5b), range(0x7a, 0x7b)])),
        35: list(itertools.chain.from_iterable([range(0x39, 0x3a), range(0x41, 0x42), range(0x58, 0x59), range(0x5a, 0x5b)])),
    }
