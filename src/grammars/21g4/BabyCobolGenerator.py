# Generated by Grammarinator 23.7.post31+g3f15e2c.d20231108

import itertools

from math import inf
from grammarinator.runtime import *

class BabyCobolGenerator(Generator):


    def EOF(self, parent=None):
        pass
    EOF.min_size = RuleSize(0, 0)

    def program(self, parent=None):
        with UnparserRuleContext(self, 'program', parent) as current:
            self._reserve(1, self.identificationDivision, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(4, 18), 1) as quant0:
                while quant0(current):
                    self.dataDivision(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(3, 20), 1) as quant1:
                while quant1(current):
                    self.procedureDivision(parent=current)
            self.EOF(parent=current)
            return current
    program.min_size = RuleSize(3, 30)

    def identificationDivision(self, parent=None):
        with UnparserRuleContext(self, 'identificationDivision', parent) as current:
            self._reserve(14, self.IDENTIFICATION, parent=current)
            self._reserve(5, self.DIVISION, parent=current)
            self._reserve(4, self.DOT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(2, 4), 0) as quant0:
                while quant0(current):
                    self._reserve(3, self.divisionName, parent=current)
                    self._reserve(2, self.DOT, parent=current)
                    self._reserve(1, self.divisionName, parent=current)
                    self.DOT(parent=current)
            return current
    identificationDivision.min_size = RuleSize(2, 29)

    def dataDivision(self, parent=None):
        with UnparserRuleContext(self, 'dataDivision', parent) as current:
            self._reserve(13, self.DATA, parent=current)
            self._reserve(4, self.DIVISION, parent=current)
            self._reserve(3, self.DOT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 3), 0) as quant0:
                while quant0(current):
                    self.dataEntry(parent=current)
            return current
    dataDivision.min_size = RuleSize(3, 18)

    def procedureDivision(self, parent=None):
        with UnparserRuleContext(self, 'procedureDivision', parent) as current:
            self._reserve(10, self.PROCEDURE, parent=current)
            self._reserve(1, self.DIVISION, parent=current)
            self.DOT(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(5, 6), 0) as quant0:
                while quant0(current):
                    with QuantifierContext(self, 1, 1, inf, RuleSize(5, 6), 0) as quant1:
                        while quant1(current):
                            self.sentence(parent=current)
            with QuantifierContext(self, 2, 0, inf, RuleSize(6, 8), 0) as quant2:
                while quant2(current):
                    self.paragraph(parent=current)
            return current
    procedureDivision.min_size = RuleSize(2, 20)

    def divisionName(self, parent=None):
        with UnparserRuleContext(self, 'divisionName', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                [self.ID, self.NO_DOTS][alt0(current)](parent=current)
            return current
    divisionName.min_size = RuleSize(1, 1)

    def sentence(self, parent=None):
        with UnparserRuleContext(self, 'sentence', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(4, 5), 1) as quant0:
                while quant0(current):
                    self.stat(parent=current)
            self.DOT(parent=current)
            return current
    sentence.min_size = RuleSize(4, 6)

    def paragraph(self, parent=None):
        with UnparserRuleContext(self, 'paragraph', parent) as current:
            self._reserve(7, self.identifier, parent=current)
            self._reserve(6, self.DOT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(5, 6), 0) as quant0:
                while quant0(current):
                    self.sentence(parent=current)
            return current
    paragraph.min_size = RuleSize(5, 8)

    def dataEntry(self, parent=None):
        with UnparserRuleContext(self, 'dataEntry', parent) as current:
            self._reserve(2, self.INT_LIT, parent=current)
            self._reserve(1, self.identifier, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(3, 6), 1) as quant0:
                while quant0(current):
                    with AlternationContext(self, 0, (RuleSize(3, 12), RuleSize(3, 6)), 0, (1, 1)) as alt0:
                        [self.pictureClause, self.likeClause][alt0(current)](parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(3, 14), 1) as quant1:
                while quant1(current):
                    self.occursClause(parent=current)
            self.DOT(parent=current)
            return current
    dataEntry.min_size = RuleSize(2, 3)

    def pictureClause(self, parent=None):
        with UnparserRuleContext(self, 'pictureClause', parent) as current:
            self._reserve(4, self.PICTURE, parent=current)
            self._reserve(1, self.IS, parent=current)
            self.representation(parent=current)
            return current
    pictureClause.min_size = RuleSize(2, 12)

    def likeClause(self, parent=None):
        with UnparserRuleContext(self, 'likeClause', parent) as current:
            self._reserve(1, self.LIKE, parent=current)
            self.identifier(parent=current)
            return current
    likeClause.min_size = RuleSize(2, 6)

    def occursClause(self, parent=None):
        local_ctx = dict(n=None)
        with UnparserRuleContext(self, 'occursClause', parent) as current:
            self._reserve(7, self.OCCURS, parent=current)
            self._reserve(6, self.INT_LIT, parent=current)
            local_ctx['n'] = current.last_child
            self.TIMES(parent=current)
            return current
    occursClause.min_size = RuleSize(2, 14)

    def representation(self, parent=None):
        with UnparserRuleContext(self, 'representation', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                [self.ID, self.INT_LIT][alt0(current)](parent=current)
            return current
    representation.min_size = RuleSize(1, 1)

    def stat(self, parent=None):
        with UnparserRuleContext(self, 'stat', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 8), RuleSize(5, 9), RuleSize(5, 16), RuleSize(5, 14), RuleSize(6, 9), RuleSize(5, 14), RuleSize(3, 5), RuleSize(5, 20), RuleSize(5, 14), RuleSize(3, 6), RuleSize(3, 9)), 0, (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)) as alt0:
                [self.stat_acceptStat, self.stat_addStat, self.stat_subtractStat, self.stat_multiplyStat, self.stat_displayStat, self.stat_divideStat, self.stat_stopStat, self.stat_conditionalStat, self.stat_evaluateStat, self.stat_goToStat, self.stat_performStat][alt0(current)](parent=current)
            return current
    stat.min_size = RuleSize(3, 5)

    def anyExpr(self, parent=None):
        with UnparserRuleContext(self, 'anyExpr', parent) as current:
            with AlternationContext(self, 0, (RuleSize(6, 1), RuleSize(3, 3)), 0, (1, 1)) as alt0:
                [self.arithExpr, self.boolExpr][alt0(current)](parent=current)
            return current
    anyExpr.min_size = RuleSize(3, 1)

    def whenBlock(self, parent=None):
        with UnparserRuleContext(self, 'whenBlock', parent) as current:
            self._reserve(6, self.WHEN, parent=current)
            with AlternationContext(self, 0, (RuleSize(2, 6), RuleSize(4, 1)), 5, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.OTHER(parent=current)
                elif choice0 == 1:
                    with QuantifierContext(self, 0, 1, inf, RuleSize(4, 1), 0) as quant0:
                        while quant0(current):
                            self.atomic(parent=current)
            with QuantifierContext(self, 1, 1, inf, RuleSize(4, 5), 0) as quant1:
                while quant1(current):
                    self.stat(parent=current)
            return current
    whenBlock.min_size = RuleSize(4, 11)

    def dispOptions(self, parent=None):
        with UnparserRuleContext(self, 'dispOptions', parent) as current:
            self.atomic(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 14), 0) as quant0:
                while quant0(current):
                    self._reserve(4, self.DELIMITED, parent=current)
                    self._reserve(1, self.BY, parent=current)
                    with AlternationContext(self, 0, (RuleSize(2, 5), RuleSize(2, 6), RuleSize(3, 1)), 0, (1, 1, 1)) as alt0:
                        [self.SIZE, self.SPACE, self.literal][alt0(current)](parent=current)
            return current
    dispOptions.min_size = RuleSize(4, 1)

    def boolExpr(self, parent=None):
        with UnparserRuleContext(self, 'boolExpr', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 5), RuleSize(2, 6), RuleSize(6, 3), RuleSize(3, 7), RuleSize(3, 9)), 0, (1, 1, 1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.TRUE(parent=current)
                elif choice0 == 1:
                    self.FALSE(parent=current)
                elif choice0 == 2:
                    self._reserve(2, self.arithExpr, parent=current)
                    self._reserve(1, self.compOp, parent=current)
                    self.arithExpr(parent=current)
                elif choice0 == 3:
                    self._reserve(3, self.NOT, parent=current)
                    self.boolExpr(parent=current)
                elif choice0 == 4:
                    self._reserve(6, self.boolExpr, parent=current)
                    self._reserve(3, self.boolOp, parent=current)
                    self.boolExpr(parent=current)
            return current
    boolExpr.min_size = RuleSize(2, 3)

    def arithExpr(self, parent=None):
        with UnparserRuleContext(self, 'arithExpr', parent) as current:
            with AlternationContext(self, 0, (RuleSize(7, 3), RuleSize(7, 3), RuleSize(7, 3), RuleSize(5, 1)), 0, (1, 1, 1, 1)) as alt0:
                [self.arithExpr_powerExpr, self.arithExpr_mulDivExpr, self.arithExpr_addSubExpr, self.arithExpr_arithAtomic][alt0(current)](parent=current)
            return current
    arithExpr.min_size = RuleSize(5, 1)

    def atomic(self, parent=None):
        with UnparserRuleContext(self, 'atomic', parent) as current:
            with AlternationContext(self, 0, (RuleSize(4, 1), RuleSize(3, 1)), 0, (1, 1)) as alt0:
                [self.atomic_literalAtomic, self.atomic_idAtomic][alt0(current)](parent=current)
            return current
    atomic.min_size = RuleSize(3, 1)

    def literal(self, parent=None):
        with UnparserRuleContext(self, 'literal', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(2, 1), RuleSize(2, 1), RuleSize(3, 5), RuleSize(3, 6)), 0, (1, 1, 1, 1, 1)) as alt0:
                [self.literal_intLit, self.literal_numLit, self.literal_txtLit, self.literal_trueLit, self.literal_falseLit][alt0(current)](parent=current)
            return current
    literal.min_size = RuleSize(2, 1)

    def identifier(self, parent=None):
        with UnparserRuleContext(self, 'identifier', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 7), RuleSize(2, 4), RuleSize(2, 10), RuleSize(2, 4), RuleSize(2, 3), RuleSize(2, 5), RuleSize(2, 10), RuleSize(2, 8), RuleSize(2, 7), RuleSize(2, 9), RuleSize(2, 5), RuleSize(2, 4), RuleSize(2, 9), RuleSize(2, 6), RuleSize(2, 5), RuleSize(2, 7), RuleSize(2, 15), RuleSize(2, 3), RuleSize(2, 3), RuleSize(2, 9), RuleSize(2, 3), RuleSize(2, 4), RuleSize(2, 7), RuleSize(2, 3), RuleSize(2, 6), RuleSize(2, 3), RuleSize(2, 8), RuleSize(2, 10), RuleSize(2, 8), RuleSize(2, 5), RuleSize(2, 6), RuleSize(2, 5), RuleSize(2, 9), RuleSize(2, 5), RuleSize(2, 8), RuleSize(2, 3), RuleSize(2, 5), RuleSize(2, 5), RuleSize(2, 5), RuleSize(2, 4), RuleSize(2, 5), RuleSize(2, 2), RuleSize(1, 1)), 0, (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self.ACCEPT(parent=current)
                elif choice0 == 1:
                    self.ADD(parent=current)
                elif choice0 == 2:
                    self.ADVANCING(parent=current)
                elif choice0 == 3:
                    self.AND(parent=current)
                elif choice0 == 4:
                    self.BY(parent=current)
                elif choice0 == 5:
                    self.DATA(parent=current)
                elif choice0 == 6:
                    self.DELIMITED(parent=current)
                elif choice0 == 7:
                    self.DISPLAY(parent=current)
                elif choice0 == 8:
                    self.DIVIDE(parent=current)
                elif choice0 == 9:
                    self.DIVISION(parent=current)
                elif choice0 == 10:
                    self.ELSE(parent=current)
                elif choice0 == 11:
                    self.END(parent=current)
                elif choice0 == 12:
                    self.EVALUATE(parent=current)
                elif choice0 == 13:
                    self.FALSE(parent=current)
                elif choice0 == 14:
                    self.FROM(parent=current)
                elif choice0 == 15:
                    self.GIVING(parent=current)
                elif choice0 == 16:
                    self.IDENTIFICATION(parent=current)
                elif choice0 == 17:
                    self.IF(parent=current)
                elif choice0 == 18:
                    self.IS(parent=current)
                elif choice0 == 19:
                    self.MULTIPLY(parent=current)
                elif choice0 == 20:
                    self.NO(parent=current)
                elif choice0 == 21:
                    self.NOT(parent=current)
                elif choice0 == 22:
                    self.OCCURS(parent=current)
                elif choice0 == 23:
                    self.OF(parent=current)
                elif choice0 == 24:
                    self.OTHER(parent=current)
                elif choice0 == 25:
                    self.OR(parent=current)
                elif choice0 == 26:
                    self.PERFORM(parent=current)
                elif choice0 == 27:
                    self.PROCEDURE(parent=current)
                elif choice0 == 28:
                    self.PICTURE(parent=current)
                elif choice0 == 29:
                    self.SIZE(parent=current)
                elif choice0 == 30:
                    self.SPACE(parent=current)
                elif choice0 == 31:
                    self.STOP(parent=current)
                elif choice0 == 32:
                    self.SUBTRACT(parent=current)
                elif choice0 == 33:
                    self.THEN(parent=current)
                elif choice0 == 34:
                    self.THROUGH(parent=current)
                elif choice0 == 35:
                    self.TO(parent=current)
                elif choice0 == 36:
                    self.TRUE(parent=current)
                elif choice0 == 37:
                    self.WITH(parent=current)
                elif choice0 == 38:
                    self.WHEN(parent=current)
                elif choice0 == 39:
                    self.XOR(parent=current)
                elif choice0 == 40:
                    self._reserve(4, self.identifier, parent=current)
                    with QuantifierContext(self, 0, 1, inf, RuleSize(2, 4), 0) as quant0:
                        while quant0(current):
                            self._reserve(1, self.OF, parent=current)
                            self.identifier(parent=current)
                elif choice0 == 41:
                    self._reserve(1, self.identifier, parent=current)
                    self.INDEX(parent=current)
                elif choice0 == 42:
                    self.ID(parent=current)
            return current
    identifier.min_size = RuleSize(1, 1)

    def boolOp(self, parent=None):
        with UnparserRuleContext(self, 'boolOp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 4), RuleSize(2, 3), RuleSize(2, 4)), 0, (1, 1, 1)) as alt0:
                [self.AND, self.OR, self.XOR][alt0(current)](parent=current)
            return current
    boolOp.min_size = RuleSize(2, 3)

    def compOp(self, parent=None):
        with UnparserRuleContext(self, 'compOp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1, 1, 1, 1)) as alt0:
                [self.EQ, self.GT, self.LT, self.GE, self.LE][alt0(current)](parent=current)
            return current
    compOp.min_size = RuleSize(1, 1)

    def ACCEPT(self, parent=None):
        with UnlexerRuleContext(self, 'ACCEPT', parent) as current:
            self._reserve(5, self.A, parent=current)
            self._reserve(4, self.C, parent=current)
            self._reserve(3, self.C, parent=current)
            self._reserve(2, self.E, parent=current)
            self._reserve(1, self.P, parent=current)
            self.T(parent=current)
            return current
    ACCEPT.min_size = RuleSize(1, 6)

    def ADD(self, parent=None):
        with UnlexerRuleContext(self, 'ADD', parent) as current:
            self._reserve(2, self.A, parent=current)
            self._reserve(1, self.D, parent=current)
            self.D(parent=current)
            return current
    ADD.min_size = RuleSize(1, 3)

    def ADVANCING(self, parent=None):
        with UnlexerRuleContext(self, 'ADVANCING', parent) as current:
            self._reserve(8, self.A, parent=current)
            self._reserve(7, self.D, parent=current)
            self._reserve(6, self.V, parent=current)
            self._reserve(5, self.A, parent=current)
            self._reserve(4, self.N, parent=current)
            self._reserve(3, self.C, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.N, parent=current)
            self.G(parent=current)
            return current
    ADVANCING.min_size = RuleSize(1, 9)

    def AND(self, parent=None):
        with UnlexerRuleContext(self, 'AND', parent) as current:
            self._reserve(2, self.A, parent=current)
            self._reserve(1, self.N, parent=current)
            self.D(parent=current)
            return current
    AND.min_size = RuleSize(1, 3)

    def BY(self, parent=None):
        with UnlexerRuleContext(self, 'BY', parent) as current:
            self._reserve(1, self.B, parent=current)
            self.Y(parent=current)
            return current
    BY.min_size = RuleSize(1, 2)

    def DATA(self, parent=None):
        with UnlexerRuleContext(self, 'DATA', parent) as current:
            self._reserve(3, self.D, parent=current)
            self._reserve(2, self.A, parent=current)
            self._reserve(1, self.T, parent=current)
            self.A(parent=current)
            return current
    DATA.min_size = RuleSize(1, 4)

    def DELIMITED(self, parent=None):
        with UnlexerRuleContext(self, 'DELIMITED', parent) as current:
            self._reserve(8, self.D, parent=current)
            self._reserve(7, self.E, parent=current)
            self._reserve(6, self.L, parent=current)
            self._reserve(5, self.I, parent=current)
            self._reserve(4, self.M, parent=current)
            self._reserve(3, self.I, parent=current)
            self._reserve(2, self.T, parent=current)
            self._reserve(1, self.E, parent=current)
            self.D(parent=current)
            return current
    DELIMITED.min_size = RuleSize(1, 9)

    def DISPLAY(self, parent=None):
        with UnlexerRuleContext(self, 'DISPLAY', parent) as current:
            self._reserve(6, self.D, parent=current)
            self._reserve(5, self.I, parent=current)
            self._reserve(4, self.S, parent=current)
            self._reserve(3, self.P, parent=current)
            self._reserve(2, self.L, parent=current)
            self._reserve(1, self.A, parent=current)
            self.Y(parent=current)
            return current
    DISPLAY.min_size = RuleSize(1, 7)

    def DIVIDE(self, parent=None):
        with UnlexerRuleContext(self, 'DIVIDE', parent) as current:
            self._reserve(5, self.D, parent=current)
            self._reserve(4, self.I, parent=current)
            self._reserve(3, self.V, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.D, parent=current)
            self.E(parent=current)
            return current
    DIVIDE.min_size = RuleSize(1, 6)

    def DIVISION(self, parent=None):
        with UnlexerRuleContext(self, 'DIVISION', parent) as current:
            self._reserve(7, self.D, parent=current)
            self._reserve(6, self.I, parent=current)
            self._reserve(5, self.V, parent=current)
            self._reserve(4, self.I, parent=current)
            self._reserve(3, self.S, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.O, parent=current)
            self.N(parent=current)
            return current
    DIVISION.min_size = RuleSize(1, 8)

    def ELSE(self, parent=None):
        with UnlexerRuleContext(self, 'ELSE', parent) as current:
            self._reserve(3, self.E, parent=current)
            self._reserve(2, self.L, parent=current)
            self._reserve(1, self.S, parent=current)
            self.E(parent=current)
            return current
    ELSE.min_size = RuleSize(1, 4)

    def END(self, parent=None):
        with UnlexerRuleContext(self, 'END', parent) as current:
            self._reserve(2, self.E, parent=current)
            self._reserve(1, self.N, parent=current)
            self.D(parent=current)
            return current
    END.min_size = RuleSize(1, 3)

    def EVALUATE(self, parent=None):
        with UnlexerRuleContext(self, 'EVALUATE', parent) as current:
            self._reserve(7, self.E, parent=current)
            self._reserve(6, self.V, parent=current)
            self._reserve(5, self.A, parent=current)
            self._reserve(4, self.L, parent=current)
            self._reserve(3, self.U, parent=current)
            self._reserve(2, self.A, parent=current)
            self._reserve(1, self.T, parent=current)
            self.E(parent=current)
            return current
    EVALUATE.min_size = RuleSize(1, 8)

    def FALSE(self, parent=None):
        with UnlexerRuleContext(self, 'FALSE', parent) as current:
            self._reserve(4, self.F, parent=current)
            self._reserve(3, self.A, parent=current)
            self._reserve(2, self.L, parent=current)
            self._reserve(1, self.S, parent=current)
            self.E(parent=current)
            return current
    FALSE.min_size = RuleSize(1, 5)

    def FROM(self, parent=None):
        with UnlexerRuleContext(self, 'FROM', parent) as current:
            self._reserve(3, self.F, parent=current)
            self._reserve(2, self.R, parent=current)
            self._reserve(1, self.O, parent=current)
            self.M(parent=current)
            return current
    FROM.min_size = RuleSize(1, 4)

    def GIVING(self, parent=None):
        with UnlexerRuleContext(self, 'GIVING', parent) as current:
            self._reserve(5, self.G, parent=current)
            self._reserve(4, self.I, parent=current)
            self._reserve(3, self.V, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.N, parent=current)
            self.G(parent=current)
            return current
    GIVING.min_size = RuleSize(1, 6)

    def GO_TO(self, parent=None):
        with UnlexerRuleContext(self, 'GO_TO', parent) as current:
            self._reserve(3, self.G, parent=current)
            self._reserve(2, self.O, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 2) as quant0:
                while quant0(current):
                    self.WS(parent=current)
            self._reserve(1, self.T, parent=current)
            self.O(parent=current)
            return current
    GO_TO.min_size = RuleSize(1, 4)

    def IDENTIFICATION(self, parent=None):
        with UnlexerRuleContext(self, 'IDENTIFICATION', parent) as current:
            self._reserve(13, self.I, parent=current)
            self._reserve(12, self.D, parent=current)
            self._reserve(11, self.E, parent=current)
            self._reserve(10, self.N, parent=current)
            self._reserve(9, self.T, parent=current)
            self._reserve(8, self.I, parent=current)
            self._reserve(7, self.F, parent=current)
            self._reserve(6, self.I, parent=current)
            self._reserve(5, self.C, parent=current)
            self._reserve(4, self.A, parent=current)
            self._reserve(3, self.T, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.O, parent=current)
            self.N(parent=current)
            return current
    IDENTIFICATION.min_size = RuleSize(1, 14)

    def IF(self, parent=None):
        with UnlexerRuleContext(self, 'IF', parent) as current:
            self._reserve(1, self.I, parent=current)
            self.F(parent=current)
            return current
    IF.min_size = RuleSize(1, 2)

    def INTO(self, parent=None):
        with UnlexerRuleContext(self, 'INTO', parent) as current:
            self._reserve(3, self.I, parent=current)
            self._reserve(2, self.N, parent=current)
            self._reserve(1, self.T, parent=current)
            self.O(parent=current)
            return current
    INTO.min_size = RuleSize(1, 4)

    def IS(self, parent=None):
        with UnlexerRuleContext(self, 'IS', parent) as current:
            self._reserve(1, self.I, parent=current)
            self.S(parent=current)
            return current
    IS.min_size = RuleSize(1, 2)

    def LIKE(self, parent=None):
        with UnlexerRuleContext(self, 'LIKE', parent) as current:
            self._reserve(3, self.L, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.K, parent=current)
            self.E(parent=current)
            return current
    LIKE.min_size = RuleSize(1, 4)

    def MULTIPLY(self, parent=None):
        with UnlexerRuleContext(self, 'MULTIPLY', parent) as current:
            self._reserve(7, self.M, parent=current)
            self._reserve(6, self.U, parent=current)
            self._reserve(5, self.L, parent=current)
            self._reserve(4, self.T, parent=current)
            self._reserve(3, self.I, parent=current)
            self._reserve(2, self.P, parent=current)
            self._reserve(1, self.L, parent=current)
            self.Y(parent=current)
            return current
    MULTIPLY.min_size = RuleSize(1, 8)

    def NO(self, parent=None):
        with UnlexerRuleContext(self, 'NO', parent) as current:
            self._reserve(1, self.N, parent=current)
            self.O(parent=current)
            return current
    NO.min_size = RuleSize(1, 2)

    def NOT(self, parent=None):
        with UnlexerRuleContext(self, 'NOT', parent) as current:
            self._reserve(2, self.N, parent=current)
            self._reserve(1, self.O, parent=current)
            self.T(parent=current)
            return current
    NOT.min_size = RuleSize(1, 3)

    def OCCURS(self, parent=None):
        with UnlexerRuleContext(self, 'OCCURS', parent) as current:
            self._reserve(5, self.O, parent=current)
            self._reserve(4, self.C, parent=current)
            self._reserve(3, self.C, parent=current)
            self._reserve(2, self.U, parent=current)
            self._reserve(1, self.R, parent=current)
            self.S(parent=current)
            return current
    OCCURS.min_size = RuleSize(1, 6)

    def OF(self, parent=None):
        with UnlexerRuleContext(self, 'OF', parent) as current:
            self._reserve(1, self.O, parent=current)
            self.F(parent=current)
            return current
    OF.min_size = RuleSize(1, 2)

    def OTHER(self, parent=None):
        with UnlexerRuleContext(self, 'OTHER', parent) as current:
            self._reserve(4, self.O, parent=current)
            self._reserve(3, self.T, parent=current)
            self._reserve(2, self.H, parent=current)
            self._reserve(1, self.E, parent=current)
            self.R(parent=current)
            return current
    OTHER.min_size = RuleSize(1, 5)

    def OR(self, parent=None):
        with UnlexerRuleContext(self, 'OR', parent) as current:
            self._reserve(1, self.O, parent=current)
            self.R(parent=current)
            return current
    OR.min_size = RuleSize(1, 2)

    def PERFORM(self, parent=None):
        with UnlexerRuleContext(self, 'PERFORM', parent) as current:
            self._reserve(6, self.P, parent=current)
            self._reserve(5, self.E, parent=current)
            self._reserve(4, self.R, parent=current)
            self._reserve(3, self.F, parent=current)
            self._reserve(2, self.O, parent=current)
            self._reserve(1, self.R, parent=current)
            self.M(parent=current)
            return current
    PERFORM.min_size = RuleSize(1, 7)

    def PROCEDURE(self, parent=None):
        with UnlexerRuleContext(self, 'PROCEDURE', parent) as current:
            self._reserve(8, self.P, parent=current)
            self._reserve(7, self.R, parent=current)
            self._reserve(6, self.O, parent=current)
            self._reserve(5, self.C, parent=current)
            self._reserve(4, self.E, parent=current)
            self._reserve(3, self.D, parent=current)
            self._reserve(2, self.U, parent=current)
            self._reserve(1, self.R, parent=current)
            self.E(parent=current)
            return current
    PROCEDURE.min_size = RuleSize(1, 9)

    def PICTURE(self, parent=None):
        with UnlexerRuleContext(self, 'PICTURE', parent) as current:
            self._reserve(6, self.P, parent=current)
            self._reserve(5, self.I, parent=current)
            self._reserve(4, self.C, parent=current)
            self._reserve(3, self.T, parent=current)
            self._reserve(2, self.U, parent=current)
            self._reserve(1, self.R, parent=current)
            self.E(parent=current)
            return current
    PICTURE.min_size = RuleSize(1, 7)

    def REMAINDER(self, parent=None):
        with UnlexerRuleContext(self, 'REMAINDER', parent) as current:
            self._reserve(8, self.R, parent=current)
            self._reserve(7, self.E, parent=current)
            self._reserve(6, self.M, parent=current)
            self._reserve(5, self.A, parent=current)
            self._reserve(4, self.I, parent=current)
            self._reserve(3, self.N, parent=current)
            self._reserve(2, self.D, parent=current)
            self._reserve(1, self.E, parent=current)
            self.R(parent=current)
            return current
    REMAINDER.min_size = RuleSize(1, 9)

    def SIZE(self, parent=None):
        with UnlexerRuleContext(self, 'SIZE', parent) as current:
            self._reserve(3, self.S, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.Z, parent=current)
            self.E(parent=current)
            return current
    SIZE.min_size = RuleSize(1, 4)

    def SPACE(self, parent=None):
        with UnlexerRuleContext(self, 'SPACE', parent) as current:
            self._reserve(4, self.S, parent=current)
            self._reserve(3, self.P, parent=current)
            self._reserve(2, self.A, parent=current)
            self._reserve(1, self.C, parent=current)
            self.E(parent=current)
            return current
    SPACE.min_size = RuleSize(1, 5)

    def STOP(self, parent=None):
        with UnlexerRuleContext(self, 'STOP', parent) as current:
            self._reserve(3, self.S, parent=current)
            self._reserve(2, self.T, parent=current)
            self._reserve(1, self.O, parent=current)
            self.P(parent=current)
            return current
    STOP.min_size = RuleSize(1, 4)

    def SUBTRACT(self, parent=None):
        with UnlexerRuleContext(self, 'SUBTRACT', parent) as current:
            self._reserve(7, self.S, parent=current)
            self._reserve(6, self.U, parent=current)
            self._reserve(5, self.B, parent=current)
            self._reserve(4, self.T, parent=current)
            self._reserve(3, self.R, parent=current)
            self._reserve(2, self.A, parent=current)
            self._reserve(1, self.C, parent=current)
            self.T(parent=current)
            return current
    SUBTRACT.min_size = RuleSize(1, 8)

    def THEN(self, parent=None):
        with UnlexerRuleContext(self, 'THEN', parent) as current:
            self._reserve(3, self.T, parent=current)
            self._reserve(2, self.H, parent=current)
            self._reserve(1, self.E, parent=current)
            self.N(parent=current)
            return current
    THEN.min_size = RuleSize(1, 4)

    def THROUGH(self, parent=None):
        with UnlexerRuleContext(self, 'THROUGH', parent) as current:
            self._reserve(6, self.T, parent=current)
            self._reserve(5, self.H, parent=current)
            self._reserve(4, self.R, parent=current)
            self._reserve(3, self.O, parent=current)
            self._reserve(2, self.U, parent=current)
            self._reserve(1, self.G, parent=current)
            self.H(parent=current)
            return current
    THROUGH.min_size = RuleSize(1, 7)

    def TIMES(self, parent=None):
        with UnlexerRuleContext(self, 'TIMES', parent) as current:
            self._reserve(4, self.T, parent=current)
            self._reserve(3, self.I, parent=current)
            self._reserve(2, self.M, parent=current)
            self._reserve(1, self.E, parent=current)
            self.S(parent=current)
            return current
    TIMES.min_size = RuleSize(1, 5)

    def TO(self, parent=None):
        with UnlexerRuleContext(self, 'TO', parent) as current:
            self._reserve(1, self.T, parent=current)
            self.O(parent=current)
            return current
    TO.min_size = RuleSize(1, 2)

    def TRUE(self, parent=None):
        with UnlexerRuleContext(self, 'TRUE', parent) as current:
            self._reserve(3, self.T, parent=current)
            self._reserve(2, self.R, parent=current)
            self._reserve(1, self.U, parent=current)
            self.E(parent=current)
            return current
    TRUE.min_size = RuleSize(1, 4)

    def WITH(self, parent=None):
        with UnlexerRuleContext(self, 'WITH', parent) as current:
            self._reserve(3, self.W, parent=current)
            self._reserve(2, self.I, parent=current)
            self._reserve(1, self.T, parent=current)
            self.H(parent=current)
            return current
    WITH.min_size = RuleSize(1, 4)

    def WHEN(self, parent=None):
        with UnlexerRuleContext(self, 'WHEN', parent) as current:
            self._reserve(3, self.W, parent=current)
            self._reserve(2, self.H, parent=current)
            self._reserve(1, self.E, parent=current)
            self.N(parent=current)
            return current
    WHEN.min_size = RuleSize(1, 4)

    def XOR(self, parent=None):
        with UnlexerRuleContext(self, 'XOR', parent) as current:
            self._reserve(2, self.X, parent=current)
            self._reserve(1, self.O, parent=current)
            self.R(parent=current)
            return current
    XOR.min_size = RuleSize(1, 3)

    def EQ(self, parent=None):
        with UnlexerRuleContext(self, 'EQ', parent) as current:
            current.src += '='
            return current
    EQ.min_size = RuleSize(0, 0)

    def GE(self, parent=None):
        with UnlexerRuleContext(self, 'GE', parent) as current:
            current.src += '>='
            return current
    GE.min_size = RuleSize(0, 0)

    def LE(self, parent=None):
        with UnlexerRuleContext(self, 'LE', parent) as current:
            current.src += '<='
            return current
    LE.min_size = RuleSize(0, 0)

    def GT(self, parent=None):
        with UnlexerRuleContext(self, 'GT', parent) as current:
            current.src += '>'
            return current
    GT.min_size = RuleSize(0, 0)

    def LT(self, parent=None):
        with UnlexerRuleContext(self, 'LT', parent) as current:
            current.src += '<'
            return current
    LT.min_size = RuleSize(0, 0)

    def POW_OP(self, parent=None):
        with UnlexerRuleContext(self, 'POW_OP', parent) as current:
            current.src += '**'
            return current
    POW_OP.min_size = RuleSize(0, 0)

    def ADD_OP(self, parent=None):
        with UnlexerRuleContext(self, 'ADD_OP', parent) as current:
            current.src += '+'
            return current
    ADD_OP.min_size = RuleSize(0, 0)

    def SUB_OP(self, parent=None):
        with UnlexerRuleContext(self, 'SUB_OP', parent) as current:
            current.src += '-'
            return current
    SUB_OP.min_size = RuleSize(0, 0)

    def MUL_OP(self, parent=None):
        with UnlexerRuleContext(self, 'MUL_OP', parent) as current:
            current.src += '*'
            return current
    MUL_OP.min_size = RuleSize(0, 0)

    def DIV_OP(self, parent=None):
        with UnlexerRuleContext(self, 'DIV_OP', parent) as current:
            current.src += '/'
            return current
    DIV_OP.min_size = RuleSize(0, 0)

    def DOT(self, parent=None):
        with UnlexerRuleContext(self, 'DOT', parent) as current:
            current.src += '.'
            return current
    DOT.min_size = RuleSize(0, 0)

    def INT_LIT(self, parent=None):
        with UnlexerRuleContext(self, 'INT_LIT', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                        current.src += ['+', '-'][alt0(current)]
            with QuantifierContext(self, 1, 1, inf, RuleSize(0, 0), 0) as quant1:
                while quant1(current):
                    current.src += self._model.charset(current, 0, self._charsets[1])
            return current
    INT_LIT.min_size = RuleSize(0, 0)

    def NUM_LIT(self, parent=None):
        with UnlexerRuleContext(self, 'NUM_LIT', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                        current.src += ['+', '-'][alt0(current)]
            with QuantifierContext(self, 1, 0, inf, RuleSize(0, 0), 0) as quant1:
                while quant1(current):
                    current.src += self._model.charset(current, 0, self._charsets[1])
            with AlternationContext(self, 1, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt1:
                current.src += ['.', ','][alt1(current)]
            with QuantifierContext(self, 2, 1, inf, RuleSize(0, 0), 0) as quant2:
                while quant2(current):
                    current.src += self._model.charset(current, 1, self._charsets[1])
            return current
    NUM_LIT.min_size = RuleSize(0, 0)

    def TXT_LIT(self, parent=None):
        with UnlexerRuleContext(self, 'TXT_LIT', parent) as current:
            current.src += '"'
            with QuantifierContext(self, 0, 0, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[0])
            current.src += '"'
            return current
    TXT_LIT.min_size = RuleSize(0, 0)

    def INDEX(self, parent=None):
        with UnlexerRuleContext(self, 'INDEX', parent) as current:
            current.src += '('
            with QuantifierContext(self, 0, 0, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[2])
            with QuantifierContext(self, 1, 1, inf, RuleSize(0, 0), 0) as quant1:
                while quant1(current):
                    current.src += self._model.charset(current, 1, self._charsets[1])
            with QuantifierContext(self, 2, 0, inf, RuleSize(0, 0), 0) as quant2:
                while quant2(current):
                    current.src += self._model.charset(current, 2, self._charsets[2])
            current.src += ')'
            return current
    INDEX.min_size = RuleSize(0, 0)

    def ID(self, parent=None):
        with UnlexerRuleContext(self, 'ID', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[3])
            with QuantifierContext(self, 0, 0, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 1, self._charsets[4])
            return current
    ID.min_size = RuleSize(0, 0)

    def NO_DOTS(self, parent=None):
        with UnlexerRuleContext(self, 'NO_DOTS', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[5])
            return current
    NO_DOTS.min_size = RuleSize(0, 0)

    def NEW_LINE(self, parent=None):
        with UnlexerRuleContext(self, 'NEW_LINE', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[6])
            return current
    NEW_LINE.min_size = RuleSize(0, 0)

    def WS(self, parent=None):
        with UnlexerRuleContext(self, 'WS', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[2])
            return current
    WS.min_size = RuleSize(0, 0)

    def A(self, parent=None):
        with UnlexerRuleContext(self, 'A', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['a', 'A'][alt0(current)]
            return current
    A.min_size = RuleSize(0, 0)

    def B(self, parent=None):
        with UnlexerRuleContext(self, 'B', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['b', 'B'][alt0(current)]
            return current
    B.min_size = RuleSize(0, 0)

    def C(self, parent=None):
        with UnlexerRuleContext(self, 'C', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['c', 'C'][alt0(current)]
            return current
    C.min_size = RuleSize(0, 0)

    def D(self, parent=None):
        with UnlexerRuleContext(self, 'D', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['d', 'D'][alt0(current)]
            return current
    D.min_size = RuleSize(0, 0)

    def E(self, parent=None):
        with UnlexerRuleContext(self, 'E', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['e', 'E'][alt0(current)]
            return current
    E.min_size = RuleSize(0, 0)

    def F(self, parent=None):
        with UnlexerRuleContext(self, 'F', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['f', 'F'][alt0(current)]
            return current
    F.min_size = RuleSize(0, 0)

    def G(self, parent=None):
        with UnlexerRuleContext(self, 'G', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['g', 'G'][alt0(current)]
            return current
    G.min_size = RuleSize(0, 0)

    def H(self, parent=None):
        with UnlexerRuleContext(self, 'H', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['h', 'H'][alt0(current)]
            return current
    H.min_size = RuleSize(0, 0)

    def I(self, parent=None):
        with UnlexerRuleContext(self, 'I', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['i', 'I'][alt0(current)]
            return current
    I.min_size = RuleSize(0, 0)

    def J(self, parent=None):
        with UnlexerRuleContext(self, 'J', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['j', 'J'][alt0(current)]
            return current
    J.min_size = RuleSize(0, 0)

    def K(self, parent=None):
        with UnlexerRuleContext(self, 'K', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['k', 'K'][alt0(current)]
            return current
    K.min_size = RuleSize(0, 0)

    def L(self, parent=None):
        with UnlexerRuleContext(self, 'L', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['l', 'L'][alt0(current)]
            return current
    L.min_size = RuleSize(0, 0)

    def M(self, parent=None):
        with UnlexerRuleContext(self, 'M', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['m', 'M'][alt0(current)]
            return current
    M.min_size = RuleSize(0, 0)

    def N(self, parent=None):
        with UnlexerRuleContext(self, 'N', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['n', 'N'][alt0(current)]
            return current
    N.min_size = RuleSize(0, 0)

    def O(self, parent=None):
        with UnlexerRuleContext(self, 'O', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['o', 'O'][alt0(current)]
            return current
    O.min_size = RuleSize(0, 0)

    def P(self, parent=None):
        with UnlexerRuleContext(self, 'P', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['p', 'P'][alt0(current)]
            return current
    P.min_size = RuleSize(0, 0)

    def Q(self, parent=None):
        with UnlexerRuleContext(self, 'Q', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['q', 'Q'][alt0(current)]
            return current
    Q.min_size = RuleSize(0, 0)

    def R(self, parent=None):
        with UnlexerRuleContext(self, 'R', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['r', 'R'][alt0(current)]
            return current
    R.min_size = RuleSize(0, 0)

    def S(self, parent=None):
        with UnlexerRuleContext(self, 'S', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['s', 'S'][alt0(current)]
            return current
    S.min_size = RuleSize(0, 0)

    def T(self, parent=None):
        with UnlexerRuleContext(self, 'T', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['t', 'T'][alt0(current)]
            return current
    T.min_size = RuleSize(0, 0)

    def U(self, parent=None):
        with UnlexerRuleContext(self, 'U', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['u', 'U'][alt0(current)]
            return current
    U.min_size = RuleSize(0, 0)

    def V(self, parent=None):
        with UnlexerRuleContext(self, 'V', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['v', 'V'][alt0(current)]
            return current
    V.min_size = RuleSize(0, 0)

    def W(self, parent=None):
        with UnlexerRuleContext(self, 'W', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['w', 'W'][alt0(current)]
            return current
    W.min_size = RuleSize(0, 0)

    def X(self, parent=None):
        with UnlexerRuleContext(self, 'X', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['x', 'X'][alt0(current)]
            return current
    X.min_size = RuleSize(0, 0)

    def Y(self, parent=None):
        with UnlexerRuleContext(self, 'Y', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['y', 'Y'][alt0(current)]
            return current
    Y.min_size = RuleSize(0, 0)

    def Z(self, parent=None):
        with UnlexerRuleContext(self, 'Z', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['z', 'Z'][alt0(current)]
            return current
    Z.min_size = RuleSize(0, 0)

    def stat_acceptStat(self, parent=None):
        with UnparserRuleContext(self, 'stat_acceptStat', parent) as current:
            self._reserve(1, self.ACCEPT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(2, 1), 0) as quant0:
                while quant0(current):
                    self.identifier(parent=current)
            return current
    stat_acceptStat.min_size = RuleSize(2, 8)

    def stat_addStat(self, parent=None):
        local_ctx = dict(left=None, right=None)
        with UnparserRuleContext(self, 'stat_addStat', parent) as current:
            self._reserve(5, self.ADD, parent=current)
            self._reserve(4, self.atomic, parent=current)
            local_ctx['left'] = current.last_child
            self._reserve(1, self.TO, parent=current)
            self.atomic(parent=current)
            local_ctx['right'] = current.last_child
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 8), 0) as quant0:
                while quant0(current):
                    self._reserve(1, self.GIVING, parent=current)
                    self.identifier(parent=current)
            return current
    stat_addStat.min_size = RuleSize(4, 9)

    def stat_subtractStat(self, parent=None):
        local_ctx = dict(left=None, right=None)
        with UnparserRuleContext(self, 'stat_subtractStat', parent) as current:
            self._reserve(7, self.SUBTRACT, parent=current)
            self._reserve(6, self.atomic, parent=current)
            local_ctx['left'] = current.last_child
            self._reserve(1, self.FROM, parent=current)
            self.atomic(parent=current)
            local_ctx['right'] = current.last_child
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 8), 0) as quant0:
                while quant0(current):
                    self._reserve(1, self.GIVING, parent=current)
                    self.identifier(parent=current)
            return current
    stat_subtractStat.min_size = RuleSize(4, 16)

    def stat_multiplyStat(self, parent=None):
        local_ctx = dict(left=None, right=None)
        with UnparserRuleContext(self, 'stat_multiplyStat', parent) as current:
            self._reserve(5, self.MULTIPLY, parent=current)
            self._reserve(4, self.atomic, parent=current)
            local_ctx['left'] = current.last_child
            self._reserve(1, self.BY, parent=current)
            self.atomic(parent=current)
            local_ctx['right'] = current.last_child
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 8), 0) as quant0:
                while quant0(current):
                    self._reserve(1, self.GIVING, parent=current)
                    self.identifier(parent=current)
            return current
    stat_multiplyStat.min_size = RuleSize(4, 14)

    def stat_displayStat(self, parent=None):
        with UnparserRuleContext(self, 'stat_displayStat', parent) as current:
            self._reserve(1, self.DISPLAY, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(5, 1), 0) as quant0:
                while quant0(current):
                    self.dispOptions(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 18), 0) as quant1:
                while quant1(current):
                    self._reserve(13, self.WITH, parent=current)
                    self._reserve(10, self.NO, parent=current)
                    self.ADVANCING(parent=current)
            return current
    stat_displayStat.min_size = RuleSize(5, 9)

    def stat_divideStat(self, parent=None):
        local_ctx = dict(left=None, right=None)
        with UnparserRuleContext(self, 'stat_divideStat', parent) as current:
            self._reserve(7, self.DIVIDE, parent=current)
            self._reserve(6, self.atomic, parent=current)
            local_ctx['left'] = current.last_child
            self._reserve(1, self.INTO, parent=current)
            self.atomic(parent=current)
            local_ctx['right'] = current.last_child
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 8), 0) as quant0:
                while quant0(current):
                    self._reserve(1, self.GIVING, parent=current)
                    self.identifier(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 11), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.REMAINDER, parent=current)
                    self.identifier(parent=current)
            return current
    stat_divideStat.min_size = RuleSize(4, 14)

    def stat_stopStat(self, parent=None):
        with UnparserRuleContext(self, 'stat_stopStat', parent) as current:
            self.STOP(parent=current)
            return current
    stat_stopStat.min_size = RuleSize(2, 5)

    def stat_conditionalStat(self, parent=None):
        local_ctx = dict(ifStats=[], elseStats=[])
        with UnparserRuleContext(self, 'stat_conditionalStat', parent) as current:
            self._reserve(17, self.IF, parent=current)
            self._reserve(14, self.boolExpr, parent=current)
            self._reserve(9, self.THEN, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(4, 5), 4) as quant0:
                while quant0(current):
                    self.stat(parent=current)
                    local_ctx['ifStats'].append(current.last_child)
            with QuantifierContext(self, 1, 0, 1, RuleSize(4, 10), 4) as quant1:
                while quant1(current):
                    self._reserve(5, self.ELSE, parent=current)
                    with QuantifierContext(self, 2, 1, inf, RuleSize(4, 5), 0) as quant2:
                        while quant2(current):
                            self.stat(parent=current)
                            local_ctx['elseStats'].append(current.last_child)
            self.END(parent=current)
            return current
    stat_conditionalStat.min_size = RuleSize(4, 20)

    def stat_evaluateStat(self, parent=None):
        with UnparserRuleContext(self, 'stat_evaluateStat', parent) as current:
            self._reserve(5, self.EVALUATE, parent=current)
            self._reserve(4, self.anyExpr, parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(5, 11), 4) as quant0:
                while quant0(current):
                    self.whenBlock(parent=current)
            self.END(parent=current)
            return current
    stat_evaluateStat.min_size = RuleSize(4, 14)

    def stat_goToStat(self, parent=None):
        with UnparserRuleContext(self, 'stat_goToStat', parent) as current:
            self._reserve(1, self.GO_TO, parent=current)
            self.identifier(parent=current)
            return current
    stat_goToStat.min_size = RuleSize(2, 6)

    def stat_performStat(self, parent=None):
        local_ctx = dict(startProc=None, endProc=None)
        with UnparserRuleContext(self, 'stat_performStat', parent) as current:
            self._reserve(1, self.PERFORM, parent=current)
            self.identifier(parent=current)
            local_ctx['startProc'] = current.last_child
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 9), 0) as quant0:
                while quant0(current):
                    self._reserve(1, self.THROUGH, parent=current)
                    self.identifier(parent=current)
                    local_ctx['endProc'] = current.last_child
            with QuantifierContext(self, 1, 0, 1, RuleSize(4, 7), 0) as quant1:
                while quant1(current):
                    self._reserve(6, self.atomic, parent=current)
                    self.TIMES(parent=current)
            return current
    stat_performStat.min_size = RuleSize(2, 9)

    def arithExpr_powerExpr(self, parent=None):
        with UnparserRuleContext(self, 'arithExpr_powerExpr', parent) as current:
            self._reserve(2, self.arithExpr, parent=current)
            self._reserve(1, self.POW_OP, parent=current)
            self.arithExpr(parent=current)
            return current
    arithExpr_powerExpr.min_size = RuleSize(6, 3)

    def arithExpr_mulDivExpr(self, parent=None):
        with UnparserRuleContext(self, 'arithExpr_mulDivExpr', parent) as current:
            self._reserve(2, self.arithExpr, parent=current)
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 1, (1, 1)) as alt0:
                [self.MUL_OP, self.DIV_OP][alt0(current)](parent=current)
            self.arithExpr(parent=current)
            return current
    arithExpr_mulDivExpr.min_size = RuleSize(6, 3)

    def arithExpr_addSubExpr(self, parent=None):
        with UnparserRuleContext(self, 'arithExpr_addSubExpr', parent) as current:
            self._reserve(2, self.arithExpr, parent=current)
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 1, (1, 1)) as alt0:
                [self.ADD_OP, self.SUB_OP][alt0(current)](parent=current)
            self.arithExpr(parent=current)
            return current
    arithExpr_addSubExpr.min_size = RuleSize(6, 3)

    def arithExpr_arithAtomic(self, parent=None):
        with UnparserRuleContext(self, 'arithExpr_arithAtomic', parent) as current:
            self.atomic(parent=current)
            return current
    arithExpr_arithAtomic.min_size = RuleSize(4, 1)

    def atomic_literalAtomic(self, parent=None):
        with UnparserRuleContext(self, 'atomic_literalAtomic', parent) as current:
            self.literal(parent=current)
            return current
    atomic_literalAtomic.min_size = RuleSize(3, 1)

    def atomic_idAtomic(self, parent=None):
        with UnparserRuleContext(self, 'atomic_idAtomic', parent) as current:
            self.identifier(parent=current)
            return current
    atomic_idAtomic.min_size = RuleSize(2, 1)

    def literal_intLit(self, parent=None):
        with UnparserRuleContext(self, 'literal_intLit', parent) as current:
            self.INT_LIT(parent=current)
            return current
    literal_intLit.min_size = RuleSize(1, 1)

    def literal_numLit(self, parent=None):
        with UnparserRuleContext(self, 'literal_numLit', parent) as current:
            self.NUM_LIT(parent=current)
            return current
    literal_numLit.min_size = RuleSize(1, 1)

    def literal_txtLit(self, parent=None):
        with UnparserRuleContext(self, 'literal_txtLit', parent) as current:
            self.TXT_LIT(parent=current)
            return current
    literal_txtLit.min_size = RuleSize(1, 1)

    def literal_trueLit(self, parent=None):
        with UnparserRuleContext(self, 'literal_trueLit', parent) as current:
            self.TRUE(parent=current)
            return current
    literal_trueLit.min_size = RuleSize(2, 5)

    def literal_falseLit(self, parent=None):
        with UnparserRuleContext(self, 'literal_falseLit', parent) as current:
            self.FALSE(parent=current)
            return current
    literal_falseLit.min_size = RuleSize(2, 6)

    _default_rule = program

    _charsets = {
        0: list(itertools.chain.from_iterable([range(0x20, 0x7f)])),
        1: list(itertools.chain.from_iterable([range(0x30, 0x3a)])),
        2: list(itertools.chain.from_iterable([range(0x9, 0xa), range(0xd, 0xe), range(0x20, 0x21)])),
        3: list(itertools.chain.from_iterable([range(0x30, 0x3a), range(0x41, 0x5b), range(0x61, 0x7b)])),
        4: list(itertools.chain.from_iterable([range(0x2d, 0x2e), range(0x30, 0x3a), range(0x41, 0x5b), range(0x61, 0x7b)])),
        5: list(itertools.chain.from_iterable([range(0x21, 0x2e), range(0x2f, 0x7f)])),
        6: list(itertools.chain.from_iterable([range(0xa, 0xb)])),
    }
