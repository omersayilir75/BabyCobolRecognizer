# Generated by Grammarinator 23.7.post31+g3f15e2c.d20231108

import itertools

from math import inf
from grammarinator.runtime import *

class DaddyCobolGenerator(Generator):


    def EOF(self, parent=None):
        pass
    EOF.min_size = RuleSize(0, 0)

    def cobolProgram(self, parent=None):
        with UnparserRuleContext(self, 'cobolProgram', parent) as current:
            self._reserve(1, self.identificationDivision, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(5, 6), 1) as quant0:
                while quant0(current):
                    self.dataDivision(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(6, 8), 1) as quant1:
                while quant1(current):
                    self.procedureDivision(parent=current)
            self.EOF(parent=current)
            return current
    cobolProgram.min_size = RuleSize(2, 4)

    def identificationDivision(self, parent=None):
        with UnparserRuleContext(self, 'identificationDivision', parent) as current:
            self._reserve(2, self.IDENTIFICATION, parent=current)
            self._reserve(1, self.DIVISION, parent=current)
            self.DOT(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(3, 5), 0) as quant0:
                while quant0(current):
                    self.customIdentificationNameValue(parent=current)
            return current
    identificationDivision.min_size = RuleSize(1, 3)

    def customIdentificationNameValue(self, parent=None):
        with UnparserRuleContext(self, 'customIdentificationNameValue', parent) as current:
            self._reserve(3, self.STRING_LITERAL, parent=current)
            self._reserve(2, self.COLON, parent=current)
            self.STRING_LITERAL(parent=current)
            return current
    customIdentificationNameValue.min_size = RuleSize(2, 5)

    def dataDivision(self, parent=None):
        with UnparserRuleContext(self, 'dataDivision', parent) as current:
            self._reserve(5, self.DATA, parent=current)
            self._reserve(4, self.DIVISION, parent=current)
            self._reserve(3, self.DOT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(4, 3), 0) as quant0:
                while quant0(current):
                    self._reserve(1, self.dataDefinition, parent=current)
                    self.DOT(parent=current)
            return current
    dataDivision.min_size = RuleSize(4, 6)

    def dataDefinition(self, parent=None):
        with UnparserRuleContext(self, 'dataDefinition', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 2), RuleSize(4, 6), RuleSize(3, 4)), 0, (1, 1, 1)) as alt0:
                [self.dataDefinition_recordDef, self.dataDefinition_pictureDef, self.dataDefinition_likeDef][alt0(current)](parent=current)
            return current
    dataDefinition.min_size = RuleSize(3, 2)

    def dataOccurs(self, parent=None):
        with UnparserRuleContext(self, 'dataOccurs', parent) as current:
            self._reserve(2, self.OCCURS, parent=current)
            self._reserve(1, self.NUMERIC_LITERAL, parent=current)
            self.TIMES(parent=current)
            return current
    dataOccurs.min_size = RuleSize(1, 3)

    def dataLevel(self, parent=None):
        with UnparserRuleContext(self, 'dataLevel', parent) as current:
            self.NUMERIC_LITERAL(parent=current)
            return current
    dataLevel.min_size = RuleSize(1, 1)

    def pictureRepresentation(self, parent=None):
        with UnparserRuleContext(self, 'pictureRepresentation', parent) as current:
            self.STRING_LITERAL(parent=current)
            return current
    pictureRepresentation.min_size = RuleSize(2, 2)

    def procedureDivision(self, parent=None):
        with UnparserRuleContext(self, 'procedureDivision', parent) as current:
            self._reserve(7, self.PROCEDURE, parent=current)
            self._reserve(6, self.DIVISION, parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(4, 4), 6) as quant0:
                while quant0(current):
                    self.using(parent=current)
            self._reserve(5, self.DOT, parent=current)
            with QuantifierContext(self, 1, 0, inf, RuleSize(4, 2), 5) as quant1:
                while quant1(current):
                    self.sentence(parent=current)
            with QuantifierContext(self, 2, 1, inf, RuleSize(5, 5), 0) as quant2:
                while quant2(current):
                    self.paragraph(parent=current)
            return current
    procedureDivision.min_size = RuleSize(5, 8)

    def using(self, parent=None):
        with UnparserRuleContext(self, 'using', parent) as current:
            self._reserve(3, self.USING, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 3), 0) as quant0:
                while quant0(current):
                    self.usingEntry(parent=current)
            return current
    using.min_size = RuleSize(3, 4)

    def usingEntry(self, parent=None):
        with UnparserRuleContext(self, 'usingEntry', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 3), RuleSize(3, 3), RuleSize(3, 3)), 0, (1, 1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self._reserve(2, self.BY, parent=current)
                    self._reserve(1, self.REFERENCE, parent=current)
                    self.identifier(parent=current)
                elif choice0 == 1:
                    self._reserve(2, self.BY, parent=current)
                    self._reserve(1, self.CONTENT, parent=current)
                    self.atomic(parent=current)
                elif choice0 == 2:
                    self._reserve(2, self.BY, parent=current)
                    self._reserve(1, self.VALUE, parent=current)
                    self.atomic(parent=current)
            return current
    usingEntry.min_size = RuleSize(2, 3)

    def paragraph(self, parent=None):
        with UnparserRuleContext(self, 'paragraph', parent) as current:
            self._reserve(4, self.AT_SIGN, parent=current)
            self._reserve(3, self.identifier, parent=current)
            self._reserve(2, self.DOT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(4, 2), 0) as quant0:
                while quant0(current):
                    self.sentence(parent=current)
            return current
    paragraph.min_size = RuleSize(4, 5)

    def sentence(self, parent=None):
        with UnparserRuleContext(self, 'sentence', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 1) as quant0:
                while quant0(current):
                    self.statement(parent=current)
            self.DOT(parent=current)
            return current
    sentence.min_size = RuleSize(3, 2)

    def statement(self, parent=None):
        with UnparserRuleContext(self, 'statement', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 2), RuleSize(4, 4), RuleSize(4, 6), RuleSize(3, 2), RuleSize(4, 2), RuleSize(5, 2), RuleSize(4, 4), RuleSize(6, 6), RuleSize(4, 3), RuleSize(6, 4), RuleSize(2, 2), RuleSize(3, 4), RuleSize(4, 4), RuleSize(2, 2), RuleSize(4, 2), RuleSize(2, 4), RuleSize(2, 1), RuleSize(4, 4)), 0, (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)) as alt0:
                [self.statement_acceptStat, self.statement_addStat, self.statement_alterStat, self.statement_callStat, self.statement_copyStat, self.statement_displayStat, self.statement_divideStat, self.statement_evaluateStat, self.statement_goToStat, self.statement_ifStat, self.statement_loopStat, self.statement_moveStat, self.statement_multiplyStat, self.statement_nextSentenceStat, self.statement_performStat, self.statement_signalStat, self.statement_stopStat, self.statement_subtractStat][alt0(current)](parent=current)
            return current
    statement.min_size = RuleSize(2, 1)

    def displayExpression(self, parent=None):
        with UnparserRuleContext(self, 'displayExpression', parent) as current:
            self.atomic(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 3), 0) as quant0:
                while quant0(current):
                    self._reserve(2, self.DELIMITED, parent=current)
                    self._reserve(1, self.BY, parent=current)
                    with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(2, 1)), 0, (1, 1, 1)) as alt0:
                        [self.SPACE, self.SIZE, self.literal][alt0(current)](parent=current)
            return current
    displayExpression.min_size = RuleSize(3, 1)

    def remainder(self, parent=None):
        with UnparserRuleContext(self, 'remainder', parent) as current:
            self._reserve(1, self.REMAINDER, parent=current)
            self.identifier(parent=current)
            return current
    remainder.min_size = RuleSize(2, 2)

    def moveExpression(self, parent=None):
        with UnparserRuleContext(self, 'moveExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1, 1, 1)) as alt0:
                [self.atomic, self.HIGH_VALUES, self.LOW_VALUES, self.SPACES][alt0(current)](parent=current)
            return current
    moveExpression.min_size = RuleSize(1, 1)

    def expr(self, parent=None):
        with UnparserRuleContext(self, 'expr', parent) as current:
            with AlternationContext(self, 0, (RuleSize(6, 2), RuleSize(6, 3), RuleSize(6, 3), RuleSize(6, 3), RuleSize(6, 3), RuleSize(6, 3), RuleSize(6, 3), RuleSize(4, 1)), 0, (1, 1, 1, 1, 1, 1, 1, 1)) as alt0:
                [self.expr_unaryExpr, self.expr_powExpr, self.expr_multExpr, self.expr_addExpr, self.expr_compExpr, self.expr_logicExpr, self.expr_parExpr, self.expr_atomicExpr][alt0(current)](parent=current)
            return current
    expr.min_size = RuleSize(4, 1)

    def evaluateAlso(self, parent=None):
        with UnparserRuleContext(self, 'evaluateAlso', parent) as current:
            self._reserve(1, self.ALSO, parent=current)
            self.expr(parent=current)
            return current
    evaluateAlso.min_size = RuleSize(5, 2)

    def whenClause(self, parent=None):
        with UnparserRuleContext(self, 'whenClause', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 2), RuleSize(1, 2)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    self._reserve(1, self.WHEN, parent=current)
                    self.atomic(parent=current)
                    with QuantifierContext(self, 0, 0, 1, RuleSize(3, 2), 0) as quant0:
                        while quant0(current):
                            self._reserve(1, self.THROUGH, parent=current)
                            self.atomic(parent=current)
                    with QuantifierContext(self, 1, 0, inf, RuleSize(4, 2), 0) as quant1:
                        while quant1(current):
                            self.whenAlso(parent=current)
                elif choice0 == 1:
                    self._reserve(1, self.WHEN, parent=current)
                    self.OTHER(parent=current)
            return current
    whenClause.min_size = RuleSize(1, 2)

    def whenAlso(self, parent=None):
        with UnparserRuleContext(self, 'whenAlso', parent) as current:
            self._reserve(1, self.ALSO, parent=current)
            self.atomic(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(3, 2), 0) as quant0:
                while quant0(current):
                    self._reserve(1, self.THROUGH, parent=current)
                    self.atomic(parent=current)
            return current
    whenAlso.min_size = RuleSize(3, 2)

    def whenBody(self, parent=None):
        with UnparserRuleContext(self, 'whenBody', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.statement(parent=current)
            return current
    whenBody.min_size = RuleSize(3, 1)

    def contractedExpr(self, parent=None):
        with UnparserRuleContext(self, 'contractedExpr', parent) as current:
            self._reserve(1, self.logicOp, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 1), 1) as quant0:
                while quant0(current):
                    self.compOp(parent=current)
            self.expr(parent=current)
            return current
    contractedExpr.min_size = RuleSize(5, 2)

    def unaryOp(self, parent=None):
        with UnparserRuleContext(self, 'unaryOp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                [self.NOT, self.OP_SUB][alt0(current)](parent=current)
            return current
    unaryOp.min_size = RuleSize(1, 1)

    def multOp(self, parent=None):
        with UnparserRuleContext(self, 'multOp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                [self.OP_MULT, self.OP_DIV][alt0(current)](parent=current)
            return current
    multOp.min_size = RuleSize(1, 1)

    def addOp(self, parent=None):
        with UnparserRuleContext(self, 'addOp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                [self.OP_ADD, self.OP_SUB][alt0(current)](parent=current)
            return current
    addOp.min_size = RuleSize(1, 1)

    def compOp(self, parent=None):
        with UnparserRuleContext(self, 'compOp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1, 1, 1, 1)) as alt0:
                [self.OP_EQ, self.OP_GT, self.OP_GTE, self.OP_LT, self.OP_LTE][alt0(current)](parent=current)
            return current
    compOp.min_size = RuleSize(1, 1)

    def logicOp(self, parent=None):
        with UnparserRuleContext(self, 'logicOp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1, 1)) as alt0:
                [self.AND, self.XOR, self.OR][alt0(current)](parent=current)
            return current
    logicOp.min_size = RuleSize(1, 1)

    def loopStatement(self, parent=None):
        with UnparserRuleContext(self, 'loopStatement', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(6, 2), RuleSize(6, 2), RuleSize(4, 1)), 0, (1, 1, 1, 1)) as alt0:
                [self.loopStatement_varyingLoopStatement, self.loopStatement_whileLoopStatement, self.loopStatement_untilLoopStatement, self.loopStatement_statementLoopStatement][alt0(current)](parent=current)
            return current
    loopStatement.min_size = RuleSize(2, 1)

    def atomic(self, parent=None):
        with UnparserRuleContext(self, 'atomic', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(2, 1)), 0, (1, 1)) as alt0:
                [self.literal, self.identifier][alt0(current)](parent=current)
            return current
    atomic.min_size = RuleSize(2, 1)

    def literal(self, parent=None):
        with UnparserRuleContext(self, 'literal', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 2), RuleSize(1, 1), RuleSize(2, 2)), 0, (1, 1, 1)) as alt0:
                [self.STRING_LITERAL, self.NUMERIC_LITERAL, self.float][alt0(current)](parent=current)
            return current
    literal.min_size = RuleSize(1, 1)

    def float(self, parent=None):
        with UnparserRuleContext(self, 'float', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 2) as quant0:
                while quant0(current):
                    self.NUMERIC_LITERAL(parent=current)
            self._reserve(1, self.DOT, parent=current)
            self.NUMERIC_LITERAL(parent=current)
            return current
    float.min_size = RuleSize(1, 2)

    def procedureName(self, parent=None):
        with UnparserRuleContext(self, 'procedureName', parent) as current:
            self.identifier(parent=current)
            return current
    procedureName.min_size = RuleSize(2, 1)

    def identifier(self, parent=None):
        with UnparserRuleContext(self, 'identifier', parent) as current:
            self.IDENTIFIER(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(1, 2), 0) as quant0:
                while quant0(current):
                    self._reserve(1, self.OF, parent=current)
                    self.IDENTIFIER(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(4, 3), 0) as quant1:
                while quant1(current):
                    self.index(parent=current)
            return current
    identifier.min_size = RuleSize(1, 1)

    def index(self, parent=None):
        with UnparserRuleContext(self, 'index', parent) as current:
            self._reserve(2, self.T__0, parent=current)
            self._reserve(1, self.atomic, parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(3, 2), 1) as quant0:
                while quant0(current):
                    self._reserve(1, self.T__2, parent=current)
                    self.atomic(parent=current)
            self.T__1(parent=current)
            return current
    index.min_size = RuleSize(3, 3)

    def ALSO(self, parent=None):
        with UnlexerRuleContext(self, 'ALSO', parent) as current:
            current.src += 'ALSO'
            return current
    ALSO.min_size = RuleSize(0, 0)

    def OF(self, parent=None):
        with UnlexerRuleContext(self, 'OF', parent) as current:
            current.src += 'OF'
            return current
    OF.min_size = RuleSize(0, 0)

    def CALL(self, parent=None):
        with UnlexerRuleContext(self, 'CALL', parent) as current:
            current.src += 'CALL'
            return current
    CALL.min_size = RuleSize(0, 0)

    def USING(self, parent=None):
        with UnlexerRuleContext(self, 'USING', parent) as current:
            current.src += 'USING'
            return current
    USING.min_size = RuleSize(0, 0)

    def REFERENCE(self, parent=None):
        with UnlexerRuleContext(self, 'REFERENCE', parent) as current:
            current.src += 'REFERENCE'
            return current
    REFERENCE.min_size = RuleSize(0, 0)

    def CONTENT(self, parent=None):
        with UnlexerRuleContext(self, 'CONTENT', parent) as current:
            current.src += 'CONTENT'
            return current
    CONTENT.min_size = RuleSize(0, 0)

    def VALUE(self, parent=None):
        with UnlexerRuleContext(self, 'VALUE', parent) as current:
            current.src += 'VALUE'
            return current
    VALUE.min_size = RuleSize(0, 0)

    def PICTURE(self, parent=None):
        with UnlexerRuleContext(self, 'PICTURE', parent) as current:
            current.src += 'PICTURE'
            return current
    PICTURE.min_size = RuleSize(0, 0)

    def IS(self, parent=None):
        with UnlexerRuleContext(self, 'IS', parent) as current:
            current.src += 'IS'
            return current
    IS.min_size = RuleSize(0, 0)

    def LIKE(self, parent=None):
        with UnlexerRuleContext(self, 'LIKE', parent) as current:
            current.src += 'LIKE'
            return current
    LIKE.min_size = RuleSize(0, 0)

    def OCCURS(self, parent=None):
        with UnlexerRuleContext(self, 'OCCURS', parent) as current:
            current.src += 'OCCURS'
            return current
    OCCURS.min_size = RuleSize(0, 0)

    def DATA(self, parent=None):
        with UnlexerRuleContext(self, 'DATA', parent) as current:
            current.src += 'DATA'
            return current
    DATA.min_size = RuleSize(0, 0)

    def PROGRAM_ID(self, parent=None):
        with UnlexerRuleContext(self, 'PROGRAM_ID', parent) as current:
            current.src += 'PROGRAM-ID'
            return current
    PROGRAM_ID.min_size = RuleSize(0, 0)

    def IDENTIFICATION(self, parent=None):
        with UnlexerRuleContext(self, 'IDENTIFICATION', parent) as current:
            current.src += 'IDENTIFICATION'
            return current
    IDENTIFICATION.min_size = RuleSize(0, 0)

    def PROCEDURE(self, parent=None):
        with UnlexerRuleContext(self, 'PROCEDURE', parent) as current:
            current.src += 'PROCEDURE'
            return current
    PROCEDURE.min_size = RuleSize(0, 0)

    def DIVISION(self, parent=None):
        with UnlexerRuleContext(self, 'DIVISION', parent) as current:
            current.src += 'DIVISION'
            return current
    DIVISION.min_size = RuleSize(0, 0)

    def ACCEPT(self, parent=None):
        with UnlexerRuleContext(self, 'ACCEPT', parent) as current:
            current.src += 'ACCEPT'
            return current
    ACCEPT.min_size = RuleSize(0, 0)

    def GIVING(self, parent=None):
        with UnlexerRuleContext(self, 'GIVING', parent) as current:
            current.src += 'GIVING'
            return current
    GIVING.min_size = RuleSize(0, 0)

    def ADD(self, parent=None):
        with UnlexerRuleContext(self, 'ADD', parent) as current:
            current.src += 'ADD'
            return current
    ADD.min_size = RuleSize(0, 0)

    def ALTER(self, parent=None):
        with UnlexerRuleContext(self, 'ALTER', parent) as current:
            current.src += 'ALTER'
            return current
    ALTER.min_size = RuleSize(0, 0)

    def TO(self, parent=None):
        with UnlexerRuleContext(self, 'TO', parent) as current:
            current.src += 'TO'
            return current
    TO.min_size = RuleSize(0, 0)

    def PROCEED(self, parent=None):
        with UnlexerRuleContext(self, 'PROCEED', parent) as current:
            current.src += 'PROCEED'
            return current
    PROCEED.min_size = RuleSize(0, 0)

    def COPY(self, parent=None):
        with UnlexerRuleContext(self, 'COPY', parent) as current:
            current.src += 'COPY'
            return current
    COPY.min_size = RuleSize(0, 0)

    def REPLACING(self, parent=None):
        with UnlexerRuleContext(self, 'REPLACING', parent) as current:
            current.src += 'REPLACING'
            return current
    REPLACING.min_size = RuleSize(0, 0)

    def BY(self, parent=None):
        with UnlexerRuleContext(self, 'BY', parent) as current:
            current.src += 'BY'
            return current
    BY.min_size = RuleSize(0, 0)

    def DISPLAY(self, parent=None):
        with UnlexerRuleContext(self, 'DISPLAY', parent) as current:
            current.src += 'DISPLAY'
            return current
    DISPLAY.min_size = RuleSize(0, 0)

    def WITH(self, parent=None):
        with UnlexerRuleContext(self, 'WITH', parent) as current:
            current.src += 'WITH'
            return current
    WITH.min_size = RuleSize(0, 0)

    def NO(self, parent=None):
        with UnlexerRuleContext(self, 'NO', parent) as current:
            current.src += 'NO'
            return current
    NO.min_size = RuleSize(0, 0)

    def ADVANCING(self, parent=None):
        with UnlexerRuleContext(self, 'ADVANCING', parent) as current:
            current.src += 'ADVANCING'
            return current
    ADVANCING.min_size = RuleSize(0, 0)

    def DIVIDE(self, parent=None):
        with UnlexerRuleContext(self, 'DIVIDE', parent) as current:
            current.src += 'DIVIDE'
            return current
    DIVIDE.min_size = RuleSize(0, 0)

    def INTO(self, parent=None):
        with UnlexerRuleContext(self, 'INTO', parent) as current:
            current.src += 'INTO'
            return current
    INTO.min_size = RuleSize(0, 0)

    def REMAINDER(self, parent=None):
        with UnlexerRuleContext(self, 'REMAINDER', parent) as current:
            current.src += 'REMAINDER'
            return current
    REMAINDER.min_size = RuleSize(0, 0)

    def EVALUATE(self, parent=None):
        with UnlexerRuleContext(self, 'EVALUATE', parent) as current:
            current.src += 'EVALUATE'
            return current
    EVALUATE.min_size = RuleSize(0, 0)

    def END(self, parent=None):
        with UnlexerRuleContext(self, 'END', parent) as current:
            current.src += 'END'
            return current
    END.min_size = RuleSize(0, 0)

    def GO(self, parent=None):
        with UnlexerRuleContext(self, 'GO', parent) as current:
            current.src += 'GO'
            return current
    GO.min_size = RuleSize(0, 0)

    def IF(self, parent=None):
        with UnlexerRuleContext(self, 'IF', parent) as current:
            current.src += 'IF'
            return current
    IF.min_size = RuleSize(0, 0)

    def THEN(self, parent=None):
        with UnlexerRuleContext(self, 'THEN', parent) as current:
            current.src += 'THEN'
            return current
    THEN.min_size = RuleSize(0, 0)

    def ELSE(self, parent=None):
        with UnlexerRuleContext(self, 'ELSE', parent) as current:
            current.src += 'ELSE'
            return current
    ELSE.min_size = RuleSize(0, 0)

    def LOOP(self, parent=None):
        with UnlexerRuleContext(self, 'LOOP', parent) as current:
            current.src += 'LOOP'
            return current
    LOOP.min_size = RuleSize(0, 0)

    def MOVE(self, parent=None):
        with UnlexerRuleContext(self, 'MOVE', parent) as current:
            current.src += 'MOVE'
            return current
    MOVE.min_size = RuleSize(0, 0)

    def MULTIPLY(self, parent=None):
        with UnlexerRuleContext(self, 'MULTIPLY', parent) as current:
            current.src += 'MULTIPLY'
            return current
    MULTIPLY.min_size = RuleSize(0, 0)

    def NEXT(self, parent=None):
        with UnlexerRuleContext(self, 'NEXT', parent) as current:
            current.src += 'NEXT'
            return current
    NEXT.min_size = RuleSize(0, 0)

    def SENTENCE(self, parent=None):
        with UnlexerRuleContext(self, 'SENTENCE', parent) as current:
            current.src += 'SENTENCE'
            return current
    SENTENCE.min_size = RuleSize(0, 0)

    def PERFORM(self, parent=None):
        with UnlexerRuleContext(self, 'PERFORM', parent) as current:
            current.src += 'PERFORM'
            return current
    PERFORM.min_size = RuleSize(0, 0)

    def THROUGH(self, parent=None):
        with UnlexerRuleContext(self, 'THROUGH', parent) as current:
            current.src += 'THROUGH'
            return current
    THROUGH.min_size = RuleSize(0, 0)

    def TIMES(self, parent=None):
        with UnlexerRuleContext(self, 'TIMES', parent) as current:
            current.src += 'TIMES'
            return current
    TIMES.min_size = RuleSize(0, 0)

    def SIGNAL(self, parent=None):
        with UnlexerRuleContext(self, 'SIGNAL', parent) as current:
            current.src += 'SIGNAL'
            return current
    SIGNAL.min_size = RuleSize(0, 0)

    def OFF(self, parent=None):
        with UnlexerRuleContext(self, 'OFF', parent) as current:
            current.src += 'OFF'
            return current
    OFF.min_size = RuleSize(0, 0)

    def ON(self, parent=None):
        with UnlexerRuleContext(self, 'ON', parent) as current:
            current.src += 'ON'
            return current
    ON.min_size = RuleSize(0, 0)

    def ERROR(self, parent=None):
        with UnlexerRuleContext(self, 'ERROR', parent) as current:
            current.src += 'ERROR'
            return current
    ERROR.min_size = RuleSize(0, 0)

    def STOP(self, parent=None):
        with UnlexerRuleContext(self, 'STOP', parent) as current:
            current.src += 'STOP'
            return current
    STOP.min_size = RuleSize(0, 0)

    def SUBTRACT(self, parent=None):
        with UnlexerRuleContext(self, 'SUBTRACT', parent) as current:
            current.src += 'SUBTRACT'
            return current
    SUBTRACT.min_size = RuleSize(0, 0)

    def FROM(self, parent=None):
        with UnlexerRuleContext(self, 'FROM', parent) as current:
            current.src += 'FROM'
            return current
    FROM.min_size = RuleSize(0, 0)

    def DELIMITED(self, parent=None):
        with UnlexerRuleContext(self, 'DELIMITED', parent) as current:
            current.src += 'DELIMITED'
            return current
    DELIMITED.min_size = RuleSize(0, 0)

    def SPACE(self, parent=None):
        with UnlexerRuleContext(self, 'SPACE', parent) as current:
            current.src += 'SPACE'
            return current
    SPACE.min_size = RuleSize(0, 0)

    def SPACES(self, parent=None):
        with UnlexerRuleContext(self, 'SPACES', parent) as current:
            current.src += 'SPACES'
            return current
    SPACES.min_size = RuleSize(0, 0)

    def SIZE(self, parent=None):
        with UnlexerRuleContext(self, 'SIZE', parent) as current:
            current.src += 'SIZE'
            return current
    SIZE.min_size = RuleSize(0, 0)

    def HIGH_VALUES(self, parent=None):
        with UnlexerRuleContext(self, 'HIGH_VALUES', parent) as current:
            current.src += 'HIGH-VALUES'
            return current
    HIGH_VALUES.min_size = RuleSize(0, 0)

    def LOW_VALUES(self, parent=None):
        with UnlexerRuleContext(self, 'LOW_VALUES', parent) as current:
            current.src += 'LOW-VALUES'
            return current
    LOW_VALUES.min_size = RuleSize(0, 0)

    def WHEN(self, parent=None):
        with UnlexerRuleContext(self, 'WHEN', parent) as current:
            current.src += 'WHEN'
            return current
    WHEN.min_size = RuleSize(0, 0)

    def OTHER(self, parent=None):
        with UnlexerRuleContext(self, 'OTHER', parent) as current:
            current.src += 'OTHER'
            return current
    OTHER.min_size = RuleSize(0, 0)

    def TRUE(self, parent=None):
        with UnlexerRuleContext(self, 'TRUE', parent) as current:
            current.src += 'TRUE'
            return current
    TRUE.min_size = RuleSize(0, 0)

    def FALSE(self, parent=None):
        with UnlexerRuleContext(self, 'FALSE', parent) as current:
            current.src += 'FALSE'
            return current
    FALSE.min_size = RuleSize(0, 0)

    def NOT(self, parent=None):
        with UnlexerRuleContext(self, 'NOT', parent) as current:
            current.src += 'NOT'
            return current
    NOT.min_size = RuleSize(0, 0)

    def VARYING(self, parent=None):
        with UnlexerRuleContext(self, 'VARYING', parent) as current:
            current.src += 'VARYING'
            return current
    VARYING.min_size = RuleSize(0, 0)

    def WHILE(self, parent=None):
        with UnlexerRuleContext(self, 'WHILE', parent) as current:
            current.src += 'WHILE'
            return current
    WHILE.min_size = RuleSize(0, 0)

    def UNTIL(self, parent=None):
        with UnlexerRuleContext(self, 'UNTIL', parent) as current:
            current.src += 'UNTIL'
            return current
    UNTIL.min_size = RuleSize(0, 0)

    def AND(self, parent=None):
        with UnlexerRuleContext(self, 'AND', parent) as current:
            current.src += 'AND'
            return current
    AND.min_size = RuleSize(0, 0)

    def OR(self, parent=None):
        with UnlexerRuleContext(self, 'OR', parent) as current:
            current.src += 'OR'
            return current
    OR.min_size = RuleSize(0, 0)

    def XOR(self, parent=None):
        with UnlexerRuleContext(self, 'XOR', parent) as current:
            current.src += 'XOR'
            return current
    XOR.min_size = RuleSize(0, 0)

    def OP_EQ(self, parent=None):
        with UnlexerRuleContext(self, 'OP_EQ', parent) as current:
            current.src += '='
            return current
    OP_EQ.min_size = RuleSize(0, 0)

    def OP_GT(self, parent=None):
        with UnlexerRuleContext(self, 'OP_GT', parent) as current:
            current.src += '>'
            return current
    OP_GT.min_size = RuleSize(0, 0)

    def OP_GTE(self, parent=None):
        with UnlexerRuleContext(self, 'OP_GTE', parent) as current:
            current.src += '>='
            return current
    OP_GTE.min_size = RuleSize(0, 0)

    def OP_LT(self, parent=None):
        with UnlexerRuleContext(self, 'OP_LT', parent) as current:
            current.src += '<'
            return current
    OP_LT.min_size = RuleSize(0, 0)

    def OP_LTE(self, parent=None):
        with UnlexerRuleContext(self, 'OP_LTE', parent) as current:
            current.src += '<='
            return current
    OP_LTE.min_size = RuleSize(0, 0)

    def OP_ADD(self, parent=None):
        with UnlexerRuleContext(self, 'OP_ADD', parent) as current:
            current.src += '+'
            return current
    OP_ADD.min_size = RuleSize(0, 0)

    def OP_SUB(self, parent=None):
        with UnlexerRuleContext(self, 'OP_SUB', parent) as current:
            current.src += '-'
            return current
    OP_SUB.min_size = RuleSize(0, 0)

    def OP_MULT(self, parent=None):
        with UnlexerRuleContext(self, 'OP_MULT', parent) as current:
            current.src += '*'
            return current
    OP_MULT.min_size = RuleSize(0, 0)

    def OP_DIV(self, parent=None):
        with UnlexerRuleContext(self, 'OP_DIV', parent) as current:
            current.src += '/'
            return current
    OP_DIV.min_size = RuleSize(0, 0)

    def OP_POW(self, parent=None):
        with UnlexerRuleContext(self, 'OP_POW', parent) as current:
            current.src += '**'
            return current
    OP_POW.min_size = RuleSize(0, 0)

    def DOT(self, parent=None):
        with UnlexerRuleContext(self, 'DOT', parent) as current:
            current.src += '.'
            return current
    DOT.min_size = RuleSize(0, 0)

    def AT_SIGN(self, parent=None):
        with UnlexerRuleContext(self, 'AT_SIGN', parent) as current:
            current.src += '@'
            return current
    AT_SIGN.min_size = RuleSize(0, 0)

    def COLON(self, parent=None):
        with UnlexerRuleContext(self, 'COLON', parent) as current:
            current.src += ':'
            return current
    COLON.min_size = RuleSize(0, 0)

    def STRING_LITERAL(self, parent=None):
        with UnlexerRuleContext(self, 'STRING_LITERAL', parent) as current:
            self.UnterminatedStringLiteral(parent=current)
            current.src += '"'
            return current
    STRING_LITERAL.min_size = RuleSize(1, 1)

    def UnterminatedStringLiteral(self, parent=None):
        with UnlexerRuleContext(self, 'UnterminatedStringLiteral', parent) as current:
            current.src += '"'
            with QuantifierContext(self, 0, 0, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                        choice0 = alt0(current)
                        if choice0 == 0:
                            current.src += self._model.charset(current, 0, self._charsets[1])
                        elif choice0 == 1:
                            current.src += '\\'
                            with AlternationContext(self, 1, (RuleSize(0, 0), RuleSize(1, 1)), 0, (1, 1)) as alt1:
                                choice1 = alt1(current)
                                if choice1 == 0:
                                    current.src += self._model.charset(current, 1, self._charsets[0])
                                elif choice1 == 1:
                                    self.EOF(parent=current)
            return current
    UnterminatedStringLiteral.min_size = RuleSize(0, 0)

    def NUMERIC_LITERAL(self, parent=None):
        with UnlexerRuleContext(self, 'NUMERIC_LITERAL', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[2])
            return current
    NUMERIC_LITERAL.min_size = RuleSize(0, 0)

    def IDENTIFIER(self, parent=None):
        with UnlexerRuleContext(self, 'IDENTIFIER', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[3])
            with QuantifierContext(self, 1, 0, inf, RuleSize(0, 0), 0) as quant1:
                while quant1(current):
                    with QuantifierContext(self, 2, 1, inf, RuleSize(0, 0), 0) as quant2:
                        while quant2(current):
                            current.src += self._model.charset(current, 1, self._charsets[4])
                    with QuantifierContext(self, 3, 1, inf, RuleSize(0, 0), 0) as quant3:
                        while quant3(current):
                            current.src += self._model.charset(current, 2, self._charsets[3])
            return current
    IDENTIFIER.min_size = RuleSize(0, 0)

    def WS(self, parent=None):
        with UnlexerRuleContext(self, 'WS', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[5])
            return current
    WS.min_size = RuleSize(0, 0)

    def ANY_CHAR_EXCEPT_DOT(self, parent=None):
        with UnlexerRuleContext(self, 'ANY_CHAR_EXCEPT_DOT', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[6])
            return current
    ANY_CHAR_EXCEPT_DOT.min_size = RuleSize(0, 0)

    def dataDefinition_recordDef(self, parent=None):
        with UnparserRuleContext(self, 'dataDefinition_recordDef', parent) as current:
            self._reserve(1, self.dataLevel, parent=current)
            self.identifier(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 3), 0) as quant0:
                while quant0(current):
                    self.dataOccurs(parent=current)
            return current
    dataDefinition_recordDef.min_size = RuleSize(2, 2)

    def dataDefinition_pictureDef(self, parent=None):
        with UnparserRuleContext(self, 'dataDefinition_pictureDef', parent) as current:
            self._reserve(5, self.dataLevel, parent=current)
            self._reserve(4, self.identifier, parent=current)
            self._reserve(3, self.PICTURE, parent=current)
            self._reserve(2, self.IS, parent=current)
            self.pictureRepresentation(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 3), 0) as quant0:
                while quant0(current):
                    self.dataOccurs(parent=current)
            return current
    dataDefinition_pictureDef.min_size = RuleSize(3, 6)

    def dataDefinition_likeDef(self, parent=None):
        with UnparserRuleContext(self, 'dataDefinition_likeDef', parent) as current:
            self._reserve(3, self.dataLevel, parent=current)
            self._reserve(2, self.identifier, parent=current)
            self._reserve(1, self.LIKE, parent=current)
            self.identifier(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 3), 0) as quant0:
                while quant0(current):
                    self.dataOccurs(parent=current)
            return current
    dataDefinition_likeDef.min_size = RuleSize(2, 4)

    def statement_acceptStat(self, parent=None):
        with UnparserRuleContext(self, 'statement_acceptStat', parent) as current:
            self._reserve(1, self.ACCEPT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(2, 1), 0) as quant0:
                while quant0(current):
                    self.identifier(parent=current)
            return current
    statement_acceptStat.min_size = RuleSize(2, 2)

    def statement_addStat(self, parent=None):
        with UnparserRuleContext(self, 'statement_addStat', parent) as current:
            self._reserve(3, self.ADD, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 2) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
            self._reserve(1, self.TO, parent=current)
            self.atomic(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 2), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.GIVING, parent=current)
                    self.identifier(parent=current)
            return current
    statement_addStat.min_size = RuleSize(3, 4)

    def statement_alterStat(self, parent=None):
        with UnparserRuleContext(self, 'statement_alterStat', parent) as current:
            self._reserve(5, self.ALTER, parent=current)
            self._reserve(4, self.procedureName, parent=current)
            self._reserve(3, self.TO, parent=current)
            self._reserve(2, self.PROCEED, parent=current)
            self._reserve(1, self.TO, parent=current)
            self.procedureName(parent=current)
            return current
    statement_alterStat.min_size = RuleSize(3, 6)

    def statement_callStat(self, parent=None):
        with UnparserRuleContext(self, 'statement_callStat', parent) as current:
            self._reserve(1, self.CALL, parent=current)
            self.identifier(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(4, 4), 0) as quant0:
                while quant0(current):
                    self.using(parent=current)
            return current
    statement_callStat.min_size = RuleSize(2, 2)

    def statement_copyStat(self, parent=None):
        with UnparserRuleContext(self, 'statement_copyStat', parent) as current:
            self._reserve(1, self.COPY, parent=current)
            self.atomic(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 6), 0) as quant0:
                while quant0(current):
                    self._reserve(5, self.REPLACING, parent=current)
                    with QuantifierContext(self, 1, 1, inf, RuleSize(2, 5), 0) as quant1:
                        while quant1(current):
                            self._reserve(3, self.STRING_LITERAL, parent=current)
                            self._reserve(2, self.BY, parent=current)
                            self.STRING_LITERAL(parent=current)
            return current
    statement_copyStat.min_size = RuleSize(3, 2)

    def statement_displayStat(self, parent=None):
        with UnparserRuleContext(self, 'statement_displayStat', parent) as current:
            self._reserve(1, self.DISPLAY, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(4, 1), 0) as quant0:
                while quant0(current):
                    self.displayExpression(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(1, 3), 0) as quant1:
                while quant1(current):
                    self._reserve(2, self.WITH, parent=current)
                    self._reserve(1, self.NO, parent=current)
                    self.ADVANCING(parent=current)
            return current
    statement_displayStat.min_size = RuleSize(4, 2)

    def statement_divideStat(self, parent=None):
        with UnparserRuleContext(self, 'statement_divideStat', parent) as current:
            self._reserve(3, self.DIVIDE, parent=current)
            self._reserve(2, self.atomic, parent=current)
            self._reserve(1, self.INTO, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 2), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.GIVING, parent=current)
                    with QuantifierContext(self, 2, 1, inf, RuleSize(2, 1), 0) as quant2:
                        while quant2(current):
                            self.identifier(parent=current)
                    with QuantifierContext(self, 3, 0, 1, RuleSize(3, 2), 0) as quant3:
                        while quant3(current):
                            self.remainder(parent=current)
            return current
    statement_divideStat.min_size = RuleSize(3, 4)

    def statement_evaluateStat(self, parent=None):
        with UnparserRuleContext(self, 'statement_evaluateStat', parent) as current:
            self._reserve(5, self.EVALUATE, parent=current)
            self._reserve(4, self.expr, parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(6, 2), 4) as quant0:
                while quant0(current):
                    self.evaluateAlso(parent=current)
            with QuantifierContext(self, 1, 1, inf, RuleSize(4, 3), 1) as quant1:
                while quant1(current):
                    self._reserve(1, self.whenClause, parent=current)
                    self.whenBody(parent=current)
            self.END(parent=current)
            return current
    statement_evaluateStat.min_size = RuleSize(5, 6)

    def statement_goToStat(self, parent=None):
        with UnparserRuleContext(self, 'statement_goToStat', parent) as current:
            self._reserve(2, self.GO, parent=current)
            self._reserve(1, self.TO, parent=current)
            self.procedureName(parent=current)
            return current
    statement_goToStat.min_size = RuleSize(3, 3)

    def statement_ifStat(self, parent=None):
        with UnparserRuleContext(self, 'statement_ifStat', parent) as current:
            self._reserve(3, self.IF, parent=current)
            self._reserve(2, self.expr, parent=current)
            self._reserve(1, self.THEN, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.statement(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(3, 2), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.ELSE, parent=current)
                    with QuantifierContext(self, 2, 1, inf, RuleSize(3, 1), 0) as quant2:
                        while quant2(current):
                            self.statement(parent=current)
            with QuantifierContext(self, 3, 0, 1, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.END(parent=current)
            return current
    statement_ifStat.min_size = RuleSize(5, 4)

    def statement_loopStat(self, parent=None):
        with UnparserRuleContext(self, 'statement_loopStat', parent) as current:
            self._reserve(1, self.LOOP, parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(3, 1), 1) as quant0:
                while quant0(current):
                    self.loopStatement(parent=current)
            self.END(parent=current)
            return current
    statement_loopStat.min_size = RuleSize(1, 2)

    def statement_moveStat(self, parent=None):
        with UnparserRuleContext(self, 'statement_moveStat', parent) as current:
            self._reserve(3, self.MOVE, parent=current)
            self._reserve(2, self.moveExpression, parent=current)
            self._reserve(1, self.TO, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(2, 1), 0) as quant0:
                while quant0(current):
                    self.identifier(parent=current)
            return current
    statement_moveStat.min_size = RuleSize(2, 4)

    def statement_multiplyStat(self, parent=None):
        with UnparserRuleContext(self, 'statement_multiplyStat', parent) as current:
            self._reserve(3, self.MULTIPLY, parent=current)
            self._reserve(2, self.atomic, parent=current)
            self._reserve(1, self.BY, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 2), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.GIVING, parent=current)
                    self.identifier(parent=current)
            return current
    statement_multiplyStat.min_size = RuleSize(3, 4)

    def statement_nextSentenceStat(self, parent=None):
        with UnparserRuleContext(self, 'statement_nextSentenceStat', parent) as current:
            self._reserve(1, self.NEXT, parent=current)
            self.SENTENCE(parent=current)
            return current
    statement_nextSentenceStat.min_size = RuleSize(1, 2)

    def statement_performStat(self, parent=None):
        with UnparserRuleContext(self, 'statement_performStat', parent) as current:
            self._reserve(1, self.PERFORM, parent=current)
            self.procedureName(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(3, 2), 0) as quant0:
                while quant0(current):
                    self._reserve(1, self.THROUGH, parent=current)
                    self.procedureName(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(3, 2), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.atomic, parent=current)
                    self.TIMES(parent=current)
            return current
    statement_performStat.min_size = RuleSize(3, 2)

    def statement_signalStat(self, parent=None):
        with UnparserRuleContext(self, 'statement_signalStat', parent) as current:
            self._reserve(3, self.SIGNAL, parent=current)
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(3, 1)), 2, (1, 1)) as alt0:
                [self.OFF, self.procedureName][alt0(current)](parent=current)
            self._reserve(1, self.ON, parent=current)
            self.ERROR(parent=current)
            return current
    statement_signalStat.min_size = RuleSize(1, 4)

    def statement_stopStat(self, parent=None):
        with UnparserRuleContext(self, 'statement_stopStat', parent) as current:
            self.STOP(parent=current)
            return current
    statement_stopStat.min_size = RuleSize(1, 1)

    def statement_subtractStat(self, parent=None):
        with UnparserRuleContext(self, 'statement_subtractStat', parent) as current:
            self._reserve(3, self.SUBTRACT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 2) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
            self._reserve(1, self.FROM, parent=current)
            with QuantifierContext(self, 1, 1, inf, RuleSize(3, 1), 0) as quant1:
                while quant1(current):
                    self.atomic(parent=current)
            with QuantifierContext(self, 2, 0, inf, RuleSize(2, 2), 0) as quant2:
                while quant2(current):
                    self._reserve(1, self.GIVING, parent=current)
                    self.identifier(parent=current)
            return current
    statement_subtractStat.min_size = RuleSize(3, 4)

    def expr_unaryExpr(self, parent=None):
        with UnparserRuleContext(self, 'expr_unaryExpr', parent) as current:
            self._reserve(1, self.unaryOp, parent=current)
            self.expr(parent=current)
            return current
    expr_unaryExpr.min_size = RuleSize(5, 2)

    def expr_powExpr(self, parent=None):
        with UnparserRuleContext(self, 'expr_powExpr', parent) as current:
            self._reserve(2, self.expr, parent=current)
            self._reserve(1, self.OP_POW, parent=current)
            self.expr(parent=current)
            return current
    expr_powExpr.min_size = RuleSize(5, 3)

    def expr_multExpr(self, parent=None):
        with UnparserRuleContext(self, 'expr_multExpr', parent) as current:
            self._reserve(2, self.expr, parent=current)
            self._reserve(1, self.multOp, parent=current)
            self.expr(parent=current)
            return current
    expr_multExpr.min_size = RuleSize(5, 3)

    def expr_addExpr(self, parent=None):
        with UnparserRuleContext(self, 'expr_addExpr', parent) as current:
            self._reserve(2, self.expr, parent=current)
            self._reserve(1, self.addOp, parent=current)
            self.expr(parent=current)
            return current
    expr_addExpr.min_size = RuleSize(5, 3)

    def expr_compExpr(self, parent=None):
        with UnparserRuleContext(self, 'expr_compExpr', parent) as current:
            self._reserve(2, self.expr, parent=current)
            self._reserve(1, self.compOp, parent=current)
            self.expr(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(6, 2), 0) as quant0:
                while quant0(current):
                    self.contractedExpr(parent=current)
            return current
    expr_compExpr.min_size = RuleSize(5, 3)

    def expr_logicExpr(self, parent=None):
        with UnparserRuleContext(self, 'expr_logicExpr', parent) as current:
            self._reserve(2, self.expr, parent=current)
            self._reserve(1, self.logicOp, parent=current)
            self.expr(parent=current)
            return current
    expr_logicExpr.min_size = RuleSize(5, 3)

    def expr_parExpr(self, parent=None):
        with UnparserRuleContext(self, 'expr_parExpr', parent) as current:
            self._reserve(2, self.T__0, parent=current)
            self._reserve(1, self.expr, parent=current)
            self.T__1(parent=current)
            return current
    expr_parExpr.min_size = RuleSize(5, 3)

    def T__0(self, parent=None):
        with UnlexerRuleContext(self, 'T__0', parent) as current:
            current.src += '('
            return current
    T__0.min_size = RuleSize(0, 0)

    def T__1(self, parent=None):
        with UnlexerRuleContext(self, 'T__1', parent) as current:
            current.src += ')'
            return current
    T__1.min_size = RuleSize(0, 0)

    def expr_atomicExpr(self, parent=None):
        with UnparserRuleContext(self, 'expr_atomicExpr', parent) as current:
            self.atomic(parent=current)
            return current
    expr_atomicExpr.min_size = RuleSize(3, 1)

    def loopStatement_varyingLoopStatement(self, parent=None):
        with UnparserRuleContext(self, 'loopStatement_varyingLoopStatement', parent) as current:
            self.VARYING(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 1), 0) as quant0:
                while quant0(current):
                    self.identifier(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(3, 2), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.FROM, parent=current)
                    self.atomic(parent=current)
            with QuantifierContext(self, 2, 0, 1, RuleSize(3, 2), 0) as quant2:
                while quant2(current):
                    self._reserve(1, self.TO, parent=current)
                    self.atomic(parent=current)
            with QuantifierContext(self, 3, 0, 1, RuleSize(3, 2), 0) as quant3:
                while quant3(current):
                    self._reserve(1, self.BY, parent=current)
                    self.atomic(parent=current)
            return current
    loopStatement_varyingLoopStatement.min_size = RuleSize(1, 1)

    def loopStatement_whileLoopStatement(self, parent=None):
        with UnparserRuleContext(self, 'loopStatement_whileLoopStatement', parent) as current:
            self._reserve(1, self.WHILE, parent=current)
            self.expr(parent=current)
            return current
    loopStatement_whileLoopStatement.min_size = RuleSize(5, 2)

    def loopStatement_untilLoopStatement(self, parent=None):
        with UnparserRuleContext(self, 'loopStatement_untilLoopStatement', parent) as current:
            self._reserve(1, self.UNTIL, parent=current)
            self.expr(parent=current)
            return current
    loopStatement_untilLoopStatement.min_size = RuleSize(5, 2)

    def loopStatement_statementLoopStatement(self, parent=None):
        with UnparserRuleContext(self, 'loopStatement_statementLoopStatement', parent) as current:
            self.statement(parent=current)
            return current
    loopStatement_statementLoopStatement.min_size = RuleSize(3, 1)

    def T__2(self, parent=None):
        with UnlexerRuleContext(self, 'T__2', parent) as current:
            current.src += ','
            return current
    T__2.min_size = RuleSize(0, 0)

    _default_rule = cobolProgram

    _charsets = {
        0: list(itertools.chain.from_iterable([range(0x20, 0x7f)])),
        1: list(itertools.chain.from_iterable([range(0x20, 0x22), range(0x23, 0x5c), range(0x5d, 0x7f)])),
        2: list(itertools.chain.from_iterable([range(0x30, 0x3a)])),
        3: list(itertools.chain.from_iterable([range(0x30, 0x3a), range(0x41, 0x5b), range(0x61, 0x7b)])),
        4: list(itertools.chain.from_iterable([range(0x2d, 0x2e), range(0x5f, 0x60)])),
        5: list(itertools.chain.from_iterable([range(0x9, 0xa), range(0xa, 0xb), range(0xd, 0xe), range(0x20, 0x21)])),
        6: list(itertools.chain.from_iterable([range(0x20, 0x2e), range(0x2f, 0x7f)])),
    }
