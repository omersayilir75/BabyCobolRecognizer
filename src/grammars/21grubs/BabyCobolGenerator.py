# Generated by Grammarinator 23.7.post31+g3f15e2c.d20231108

import itertools

from math import inf
from grammarinator.runtime import *

class BabyCobolGenerator(Generator):


    def EOF(self, parent=None):
        pass
    EOF.min_size = RuleSize(0, 0)

    def ComparisonOp(self, parent=None):
        with UnlexerRuleContext(self, 'ComparisonOp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1, 1, 1, 1)) as alt0:
                current.src += ['=', '>', '<', '>=', '<='][alt0(current)]
            return current
    ComparisonOp.min_size = RuleSize(0, 0)

    def BooleanOp(self, parent=None):
        with UnlexerRuleContext(self, 'BooleanOp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1, 1)) as alt0:
                [self.OR, self.AND, self.XOR][alt0(current)](parent=current)
            return current
    BooleanOp.min_size = RuleSize(1, 1)

    def StringConcatOp(self, parent=None):
        with UnlexerRuleContext(self, 'StringConcatOp', parent) as current:
            current.src += '++'
            return current
    StringConcatOp.min_size = RuleSize(0, 0)

    def ArithmeticOp(self, parent=None):
        with UnlexerRuleContext(self, 'ArithmeticOp', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1, 1, 1, 1)) as alt0:
                current.src += ['+', '-', '*', '/', '**'][alt0(current)]
            return current
    ArithmeticOp.min_size = RuleSize(0, 0)

    def DOT(self, parent=None):
        with UnlexerRuleContext(self, 'DOT', parent) as current:
            current.src += '.'
            return current
    DOT.min_size = RuleSize(0, 0)

    def ACCEPT(self, parent=None):
        with UnlexerRuleContext(self, 'ACCEPT', parent) as current:
            current.src += 'ACCEPT'
            return current
    ACCEPT.min_size = RuleSize(0, 0)

    def ADD(self, parent=None):
        with UnlexerRuleContext(self, 'ADD', parent) as current:
            current.src += 'ADD'
            return current
    ADD.min_size = RuleSize(0, 0)

    def ADVANCING(self, parent=None):
        with UnlexerRuleContext(self, 'ADVANCING', parent) as current:
            current.src += 'ADVANCING'
            return current
    ADVANCING.min_size = RuleSize(0, 0)

    def AND(self, parent=None):
        with UnlexerRuleContext(self, 'AND', parent) as current:
            current.src += 'AND'
            return current
    AND.min_size = RuleSize(0, 0)

    def BY(self, parent=None):
        with UnlexerRuleContext(self, 'BY', parent) as current:
            current.src += 'BY'
            return current
    BY.min_size = RuleSize(0, 0)

    def DATA(self, parent=None):
        with UnlexerRuleContext(self, 'DATA', parent) as current:
            current.src += 'DATA'
            return current
    DATA.min_size = RuleSize(0, 0)

    def DELIMITED(self, parent=None):
        with UnlexerRuleContext(self, 'DELIMITED', parent) as current:
            current.src += 'DELIMITED'
            return current
    DELIMITED.min_size = RuleSize(0, 0)

    def DISPLAY(self, parent=None):
        with UnlexerRuleContext(self, 'DISPLAY', parent) as current:
            current.src += 'DISPLAY'
            return current
    DISPLAY.min_size = RuleSize(0, 0)

    def DIVIDE(self, parent=None):
        with UnlexerRuleContext(self, 'DIVIDE', parent) as current:
            current.src += 'DIVIDE'
            return current
    DIVIDE.min_size = RuleSize(0, 0)

    def DIVISION(self, parent=None):
        with UnlexerRuleContext(self, 'DIVISION', parent) as current:
            current.src += 'DIVISION'
            return current
    DIVISION.min_size = RuleSize(0, 0)

    def ELSE(self, parent=None):
        with UnlexerRuleContext(self, 'ELSE', parent) as current:
            current.src += 'ELSE'
            return current
    ELSE.min_size = RuleSize(0, 0)

    def END(self, parent=None):
        with UnlexerRuleContext(self, 'END', parent) as current:
            current.src += 'END'
            return current
    END.min_size = RuleSize(0, 0)

    def ERROR(self, parent=None):
        with UnlexerRuleContext(self, 'ERROR', parent) as current:
            current.src += 'ERROR'
            return current
    ERROR.min_size = RuleSize(0, 0)

    def EVALUATE(self, parent=None):
        with UnlexerRuleContext(self, 'EVALUATE', parent) as current:
            current.src += 'EVALUATE'
            return current
    EVALUATE.min_size = RuleSize(0, 0)

    def FALSE(self, parent=None):
        with UnlexerRuleContext(self, 'FALSE', parent) as current:
            current.src += 'FALSE'
            return current
    FALSE.min_size = RuleSize(0, 0)

    def FROM(self, parent=None):
        with UnlexerRuleContext(self, 'FROM', parent) as current:
            current.src += 'FROM'
            return current
    FROM.min_size = RuleSize(0, 0)

    def GIVING(self, parent=None):
        with UnlexerRuleContext(self, 'GIVING', parent) as current:
            current.src += 'GIVING'
            return current
    GIVING.min_size = RuleSize(0, 0)

    def GOTO(self, parent=None):
        with UnlexerRuleContext(self, 'GOTO', parent) as current:
            current.src += 'GO TO'
            return current
    GOTO.min_size = RuleSize(0, 0)

    def HIGHVALUES(self, parent=None):
        with UnlexerRuleContext(self, 'HIGHVALUES', parent) as current:
            current.src += 'HIGH-VALUES'
            return current
    HIGHVALUES.min_size = RuleSize(0, 0)

    def IDENTIFICATION(self, parent=None):
        with UnlexerRuleContext(self, 'IDENTIFICATION', parent) as current:
            current.src += 'IDENTIFICATION'
            return current
    IDENTIFICATION.min_size = RuleSize(0, 0)

    def IF(self, parent=None):
        with UnlexerRuleContext(self, 'IF', parent) as current:
            current.src += 'IF'
            return current
    IF.min_size = RuleSize(0, 0)

    def INTO(self, parent=None):
        with UnlexerRuleContext(self, 'INTO', parent) as current:
            current.src += 'INTO'
            return current
    INTO.min_size = RuleSize(0, 0)

    def IS(self, parent=None):
        with UnlexerRuleContext(self, 'IS', parent) as current:
            current.src += 'IS'
            return current
    IS.min_size = RuleSize(0, 0)

    def LIKE(self, parent=None):
        with UnlexerRuleContext(self, 'LIKE', parent) as current:
            current.src += 'LIKE'
            return current
    LIKE.min_size = RuleSize(0, 0)

    def LOOP(self, parent=None):
        with UnlexerRuleContext(self, 'LOOP', parent) as current:
            current.src += 'LOOP'
            return current
    LOOP.min_size = RuleSize(0, 0)

    def LOWVALUES(self, parent=None):
        with UnlexerRuleContext(self, 'LOWVALUES', parent) as current:
            current.src += 'LOW-VALUES'
            return current
    LOWVALUES.min_size = RuleSize(0, 0)

    def MOVE(self, parent=None):
        with UnlexerRuleContext(self, 'MOVE', parent) as current:
            current.src += 'MOVE'
            return current
    MOVE.min_size = RuleSize(0, 0)

    def MULTIPLY(self, parent=None):
        with UnlexerRuleContext(self, 'MULTIPLY', parent) as current:
            current.src += 'MULTIPLY'
            return current
    MULTIPLY.min_size = RuleSize(0, 0)

    def NEXT(self, parent=None):
        with UnlexerRuleContext(self, 'NEXT', parent) as current:
            current.src += 'NEXT'
            return current
    NEXT.min_size = RuleSize(0, 0)

    def NO(self, parent=None):
        with UnlexerRuleContext(self, 'NO', parent) as current:
            current.src += 'NO'
            return current
    NO.min_size = RuleSize(0, 0)

    def NOT(self, parent=None):
        with UnlexerRuleContext(self, 'NOT', parent) as current:
            current.src += 'NOT'
            return current
    NOT.min_size = RuleSize(0, 0)

    def OCCURS(self, parent=None):
        with UnlexerRuleContext(self, 'OCCURS', parent) as current:
            current.src += 'OCCURS'
            return current
    OCCURS.min_size = RuleSize(0, 0)

    def OF(self, parent=None):
        with UnlexerRuleContext(self, 'OF', parent) as current:
            current.src += 'OF'
            return current
    OF.min_size = RuleSize(0, 0)

    def OFF(self, parent=None):
        with UnlexerRuleContext(self, 'OFF', parent) as current:
            current.src += 'OFF'
            return current
    OFF.min_size = RuleSize(0, 0)

    def ON(self, parent=None):
        with UnlexerRuleContext(self, 'ON', parent) as current:
            current.src += 'ON'
            return current
    ON.min_size = RuleSize(0, 0)

    def OR(self, parent=None):
        with UnlexerRuleContext(self, 'OR', parent) as current:
            current.src += 'OR'
            return current
    OR.min_size = RuleSize(0, 0)

    def OTHER(self, parent=None):
        with UnlexerRuleContext(self, 'OTHER', parent) as current:
            current.src += 'OTHER'
            return current
    OTHER.min_size = RuleSize(0, 0)

    def PERFORM(self, parent=None):
        with UnlexerRuleContext(self, 'PERFORM', parent) as current:
            current.src += 'PERFORM'
            return current
    PERFORM.min_size = RuleSize(0, 0)

    def PICTURE(self, parent=None):
        with UnlexerRuleContext(self, 'PICTURE', parent) as current:
            current.src += 'PICTURE'
            return current
    PICTURE.min_size = RuleSize(0, 0)

    def PROCEDURE(self, parent=None):
        with UnlexerRuleContext(self, 'PROCEDURE', parent) as current:
            current.src += 'PROCEDURE'
            return current
    PROCEDURE.min_size = RuleSize(0, 0)

    def REMAINDER(self, parent=None):
        with UnlexerRuleContext(self, 'REMAINDER', parent) as current:
            current.src += 'REMAINDER'
            return current
    REMAINDER.min_size = RuleSize(0, 0)

    def SENTENCE(self, parent=None):
        with UnlexerRuleContext(self, 'SENTENCE', parent) as current:
            current.src += 'SENTENCE'
            return current
    SENTENCE.min_size = RuleSize(0, 0)

    def SIGNAL(self, parent=None):
        with UnlexerRuleContext(self, 'SIGNAL', parent) as current:
            current.src += 'SIGNAL'
            return current
    SIGNAL.min_size = RuleSize(0, 0)

    def SIZE(self, parent=None):
        with UnlexerRuleContext(self, 'SIZE', parent) as current:
            current.src += 'SIZE'
            return current
    SIZE.min_size = RuleSize(0, 0)

    def SPACE(self, parent=None):
        with UnlexerRuleContext(self, 'SPACE', parent) as current:
            current.src += 'SPACE'
            return current
    SPACE.min_size = RuleSize(0, 0)

    def SPACES(self, parent=None):
        with UnlexerRuleContext(self, 'SPACES', parent) as current:
            current.src += 'SPACES'
            return current
    SPACES.min_size = RuleSize(0, 0)

    def STOP(self, parent=None):
        with UnlexerRuleContext(self, 'STOP', parent) as current:
            current.src += 'STOP'
            return current
    STOP.min_size = RuleSize(0, 0)

    def SUBTRACT(self, parent=None):
        with UnlexerRuleContext(self, 'SUBTRACT', parent) as current:
            current.src += 'SUBTRACT'
            return current
    SUBTRACT.min_size = RuleSize(0, 0)

    def THEN(self, parent=None):
        with UnlexerRuleContext(self, 'THEN', parent) as current:
            current.src += 'THEN'
            return current
    THEN.min_size = RuleSize(0, 0)

    def THROUGH(self, parent=None):
        with UnlexerRuleContext(self, 'THROUGH', parent) as current:
            current.src += 'THROUGH'
            return current
    THROUGH.min_size = RuleSize(0, 0)

    def TIMES(self, parent=None):
        with UnlexerRuleContext(self, 'TIMES', parent) as current:
            current.src += 'TIMES'
            return current
    TIMES.min_size = RuleSize(0, 0)

    def TO(self, parent=None):
        with UnlexerRuleContext(self, 'TO', parent) as current:
            current.src += 'TO'
            return current
    TO.min_size = RuleSize(0, 0)

    def TRUE(self, parent=None):
        with UnlexerRuleContext(self, 'TRUE', parent) as current:
            current.src += 'TRUE'
            return current
    TRUE.min_size = RuleSize(0, 0)

    def UNTIL(self, parent=None):
        with UnlexerRuleContext(self, 'UNTIL', parent) as current:
            current.src += 'UNTIL'
            return current
    UNTIL.min_size = RuleSize(0, 0)

    def VARYING(self, parent=None):
        with UnlexerRuleContext(self, 'VARYING', parent) as current:
            current.src += 'VARYING'
            return current
    VARYING.min_size = RuleSize(0, 0)

    def WHEN(self, parent=None):
        with UnlexerRuleContext(self, 'WHEN', parent) as current:
            current.src += 'WHEN'
            return current
    WHEN.min_size = RuleSize(0, 0)

    def WHILE(self, parent=None):
        with UnlexerRuleContext(self, 'WHILE', parent) as current:
            current.src += 'WHILE'
            return current
    WHILE.min_size = RuleSize(0, 0)

    def WITH(self, parent=None):
        with UnlexerRuleContext(self, 'WITH', parent) as current:
            current.src += 'WITH'
            return current
    WITH.min_size = RuleSize(0, 0)

    def XOR(self, parent=None):
        with UnlexerRuleContext(self, 'XOR', parent) as current:
            current.src += 'XOR'
            return current
    XOR.min_size = RuleSize(0, 0)

    def STRINGLITERAL(self, parent=None):
        with UnlexerRuleContext(self, 'STRINGLITERAL', parent) as current:
            current.src += '"'
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[1])
            current.src += '"'
            return current
    STRINGLITERAL.min_size = RuleSize(0, 0)

    def INTEGER(self, parent=None):
        with UnlexerRuleContext(self, 'INTEGER', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 1) as quant0:
                while quant0(current):
                    self.SIGN(parent=current)
            with QuantifierContext(self, 1, 1, inf, RuleSize(1, 1), 0) as quant1:
                while quant1(current):
                    self.DIGIT(parent=current)
            return current
    INTEGER.min_size = RuleSize(1, 1)

    def FLOAT(self, parent=None):
        with UnlexerRuleContext(self, 'FLOAT', parent) as current:
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 2) as quant0:
                while quant0(current):
                    self.SIGN(parent=current)
            with QuantifierContext(self, 1, 0, inf, RuleSize(1, 1), 2) as quant1:
                while quant1(current):
                    self.DIGIT(parent=current)
            self._reserve(1, self.SEPARATOR, parent=current)
            with QuantifierContext(self, 2, 1, inf, RuleSize(1, 1), 0) as quant2:
                while quant2(current):
                    self.DIGIT(parent=current)
            return current
    FLOAT.min_size = RuleSize(1, 2)

    def ID(self, parent=None):
        with UnlexerRuleContext(self, 'ID', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1, 1)) as alt0:
                        [self.DIGIT, self.LETTER, self.ArithmeticOp][alt0(current)](parent=current)
            return current
    ID.min_size = RuleSize(1, 1)

    def DIGIT(self, parent=None):
        with UnlexerRuleContext(self, 'DIGIT', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[2])
            return current
    DIGIT.min_size = RuleSize(0, 0)

    def LETTER(self, parent=None):
        with UnlexerRuleContext(self, 'LETTER', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                choice0 = alt0(current)
                if choice0 == 0:
                    current.src += self._model.charset(current, 0, self._charsets[3])
                elif choice0 == 1:
                    current.src += self._model.charset(current, 1, self._charsets[4])
            return current
    LETTER.min_size = RuleSize(0, 0)

    def SIGN(self, parent=None):
        with UnlexerRuleContext(self, 'SIGN', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['-', '+'][alt0(current)]
            return current
    SIGN.min_size = RuleSize(0, 0)

    def SEPARATOR(self, parent=None):
        with UnlexerRuleContext(self, 'SEPARATOR', parent) as current:
            with AlternationContext(self, 0, (RuleSize(0, 0), RuleSize(0, 0)), 0, (1, 1)) as alt0:
                current.src += ['.', ','][alt0(current)]
            return current
    SEPARATOR.min_size = RuleSize(0, 0)

    def WS(self, parent=None):
        with UnlexerRuleContext(self, 'WS', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(0, 0), 0) as quant0:
                while quant0(current):
                    current.src += self._model.charset(current, 0, self._charsets[5])
            return current
    WS.min_size = RuleSize(0, 0)

    def NODOT(self, parent=None):
        with UnlexerRuleContext(self, 'NODOT', parent) as current:
            current.src += self._model.charset(current, 0, self._charsets[6])
            return current
    NODOT.min_size = RuleSize(0, 0)

    def program(self, parent=None):
        with UnparserRuleContext(self, 'program', parent) as current:
            self._reserve(1, self.identificationDivision, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(2, 3), 1) as quant0:
                while quant0(current):
                    self.dataDivision(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(6, 8), 1) as quant1:
                while quant1(current):
                    self.procedureDivision(parent=current)
            self.EOF(parent=current)
            return current
    program.min_size = RuleSize(4, 8)

    def identificationDivision(self, parent=None):
        with UnparserRuleContext(self, 'identificationDivision', parent) as current:
            self._reserve(6, self.IDENTIFICATION, parent=current)
            self._reserve(5, self.DIVISION, parent=current)
            self._reserve(4, self.DOT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 4), 0) as quant0:
                while quant0(current):
                    self.identificationStatement(parent=current)
            return current
    identificationDivision.min_size = RuleSize(3, 7)

    def identificationStatement(self, parent=None):
        local_ctx = dict(key=None, value=None)
        with UnparserRuleContext(self, 'identificationStatement', parent) as current:
            self._reserve(3, self.name, parent=current)
            local_ctx['key'] = current.last_child
            self._reserve(2, self.DOT, parent=current)
            self._reserve(1, self.name, parent=current)
            local_ctx['value'] = current.last_child
            self.DOT(parent=current)
            return current
    identificationStatement.min_size = RuleSize(2, 4)

    def dataDivision(self, parent=None):
        with UnparserRuleContext(self, 'dataDivision', parent) as current:
            self._reserve(2, self.DATA, parent=current)
            self._reserve(1, self.DIVISION, parent=current)
            self.DOT(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(3, 5), 0) as quant0:
                while quant0(current):
                    self.dataStatement(parent=current)
            return current
    dataDivision.min_size = RuleSize(1, 3)

    def dataStatement(self, parent=None):
        with UnparserRuleContext(self, 'dataStatement', parent) as current:
            self._reserve(3, self.INTEGER, parent=current)
            self._reserve(1, self.ID, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(3, 3), 1) as quant0:
                while quant0(current):
                    with AlternationContext(self, 0, (RuleSize(3, 4), RuleSize(3, 3)), 0, (1, 1)) as alt0:
                        choice0 = alt0(current)
                        if choice0 == 0:
                            self._reserve(3, self.PICTURE, parent=current)
                            self._reserve(2, self.IS, parent=current)
                            self.representation(parent=current)
                        elif choice0 == 1:
                            self._reserve(2, self.LIKE, parent=current)
                            self.variable(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(2, 4), 1) as quant1:
                while quant1(current):
                    self._reserve(3, self.OCCURS, parent=current)
                    self._reserve(1, self.INTEGER, parent=current)
                    self.TIMES(parent=current)
            self.DOT(parent=current)
            return current
    dataStatement.min_size = RuleSize(2, 5)

    def procedureDivision(self, parent=None):
        with UnparserRuleContext(self, 'procedureDivision', parent) as current:
            self._reserve(7, self.PROCEDURE, parent=current)
            self._reserve(6, self.DIVISION, parent=current)
            self._reserve(5, self.DOT, parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(4, 2), 5) as quant0:
                while quant0(current):
                    self.sentence(parent=current)
            with QuantifierContext(self, 1, 1, inf, RuleSize(5, 5), 0) as quant1:
                while quant1(current):
                    self.paragraph(parent=current)
            return current
    procedureDivision.min_size = RuleSize(5, 8)

    def paragraph(self, parent=None):
        with UnparserRuleContext(self, 'paragraph', parent) as current:
            self._reserve(3, self.ID, parent=current)
            self._reserve(2, self.DOT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(4, 2), 0) as quant0:
                while quant0(current):
                    self.sentence(parent=current)
            return current
    paragraph.min_size = RuleSize(4, 5)

    def sentence(self, parent=None):
        with UnparserRuleContext(self, 'sentence', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 1) as quant0:
                while quant0(current):
                    self.statement(parent=current)
            self.DOT(parent=current)
            return current
    sentence.min_size = RuleSize(3, 2)

    def statement(self, parent=None):
        with UnparserRuleContext(self, 'statement', parent) as current:
            with AlternationContext(self, 0, (RuleSize(4, 3), RuleSize(4, 4), RuleSize(2, 1), RuleSize(4, 4), RuleSize(5, 3), RuleSize(4, 4), RuleSize(2, 2), RuleSize(4, 5), RuleSize(4, 4), RuleSize(2, 2), RuleSize(4, 3), RuleSize(2, 4), RuleSize(2, 1), RuleSize(4, 4), RuleSize(4, 3)), 0, (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)) as alt0:
                [self.acceptStatement, self.addStatement, self.displayStatement, self.divideStatement, self.evaluateStatement, self.ifStatement, self.loopStatement, self.moveStatement, self.multiplyStatement, self.nextSentenceStatement, self.performStatement, self.signalStatement, self.stopStatement, self.subtractStatement, self.gotoStatement][alt0(current)](parent=current)
            return current
    statement.min_size = RuleSize(2, 1)

    def acceptStatement(self, parent=None):
        with UnparserRuleContext(self, 'acceptStatement', parent) as current:
            self._reserve(2, self.ACCEPT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 2), 0) as quant0:
                while quant0(current):
                    self.variable(parent=current)
            return current
    acceptStatement.min_size = RuleSize(3, 3)

    def addStatement(self, parent=None):
        with UnparserRuleContext(self, 'addStatement', parent) as current:
            self._reserve(3, self.ADD, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 2) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
            self._reserve(1, self.TO, parent=current)
            self.atomic(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(3, 3), 0) as quant1:
                while quant1(current):
                    self._reserve(2, self.GIVING, parent=current)
                    self.variable(parent=current)
            return current
    addStatement.min_size = RuleSize(3, 4)

    def displayStatement(self, parent=None):
        with UnparserRuleContext(self, 'displayStatement', parent) as current:
            self.DISPLAY(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(4, 1), 0) as quant0:
                while quant0(current):
                    self.displayExpression(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(1, 3), 0) as quant1:
                while quant1(current):
                    self._reserve(2, self.WITH, parent=current)
                    self._reserve(1, self.NO, parent=current)
                    self.ADVANCING(parent=current)
            return current
    displayStatement.min_size = RuleSize(1, 1)

    def divideStatement(self, parent=None):
        with UnparserRuleContext(self, 'divideStatement', parent) as current:
            self._reserve(3, self.DIVIDE, parent=current)
            self._reserve(2, self.atomic, parent=current)
            self._reserve(1, self.INTO, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(3, 3), 0) as quant1:
                while quant1(current):
                    self._reserve(2, self.GIVING, parent=current)
                    self.variable(parent=current)
            with QuantifierContext(self, 2, 0, 1, RuleSize(3, 3), 0) as quant2:
                while quant2(current):
                    self._reserve(2, self.REMAINDER, parent=current)
                    self.variable(parent=current)
            return current
    divideStatement.min_size = RuleSize(3, 4)

    def evaluateStatement(self, parent=None):
        with UnparserRuleContext(self, 'evaluateStatement', parent) as current:
            self._reserve(2, self.EVALUATE, parent=current)
            self._reserve(1, self.anyExpression, parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(5, 3), 1) as quant0:
                while quant0(current):
                    self.whenBlock(parent=current)
            self.END(parent=current)
            return current
    evaluateStatement.min_size = RuleSize(4, 3)

    def ifStatement(self, parent=None):
        local_ctx = dict(trueStatements=[], falseStatements=[])
        with UnparserRuleContext(self, 'ifStatement', parent) as current:
            self._reserve(3, self.IF, parent=current)
            self._reserve(2, self.booleanExpression, parent=current)
            self._reserve(1, self.THEN, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.statement(parent=current)
                    local_ctx['trueStatements'].append(current.last_child)
            with QuantifierContext(self, 1, 0, 1, RuleSize(3, 2), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.ELSE, parent=current)
                    with QuantifierContext(self, 2, 1, inf, RuleSize(3, 1), 0) as quant2:
                        while quant2(current):
                            self.statement(parent=current)
                            local_ctx['falseStatements'].append(current.last_child)
            with QuantifierContext(self, 3, 0, 1, RuleSize(1, 1), 0) as quant3:
                while quant3(current):
                    self.END(parent=current)
            return current
    ifStatement.min_size = RuleSize(3, 4)

    def loopStatement(self, parent=None):
        with UnparserRuleContext(self, 'loopStatement', parent) as current:
            self._reserve(1, self.LOOP, parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(3, 1), 1) as quant0:
                while quant0(current):
                    self.loopExpression(parent=current)
            self.END(parent=current)
            return current
    loopStatement.min_size = RuleSize(1, 2)

    def moveStatement(self, parent=None):
        with UnparserRuleContext(self, 'moveStatement', parent) as current:
            self._reserve(4, self.MOVE, parent=current)
            self._reserve(3, self.moveExpression, parent=current)
            self._reserve(2, self.TO, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 2), 0) as quant0:
                while quant0(current):
                    self.variable(parent=current)
            return current
    moveStatement.min_size = RuleSize(3, 5)

    def multiplyStatement(self, parent=None):
        with UnparserRuleContext(self, 'multiplyStatement', parent) as current:
            self._reserve(3, self.MULTIPLY, parent=current)
            self._reserve(2, self.atomic, parent=current)
            self._reserve(1, self.BY, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(3, 3), 0) as quant1:
                while quant1(current):
                    self._reserve(2, self.GIVING, parent=current)
                    self.variable(parent=current)
            return current
    multiplyStatement.min_size = RuleSize(3, 4)

    def nextSentenceStatement(self, parent=None):
        with UnparserRuleContext(self, 'nextSentenceStatement', parent) as current:
            self._reserve(1, self.NEXT, parent=current)
            self.SENTENCE(parent=current)
            return current
    nextSentenceStatement.min_size = RuleSize(1, 2)

    def performStatement(self, parent=None):
        with UnparserRuleContext(self, 'performStatement', parent) as current:
            self._reserve(2, self.PERFORM, parent=current)
            self.procedureName(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(3, 3), 0) as quant0:
                while quant0(current):
                    self._reserve(2, self.THROUGH, parent=current)
                    self.procedureName(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(3, 2), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.atomic, parent=current)
                    self.TIMES(parent=current)
            return current
    performStatement.min_size = RuleSize(3, 3)

    def signalStatement(self, parent=None):
        with UnparserRuleContext(self, 'signalStatement', parent) as current:
            self._reserve(3, self.SIGNAL, parent=current)
            with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(3, 2)), 2, (1, 1)) as alt0:
                [self.OFF, self.procedureName][alt0(current)](parent=current)
            self._reserve(1, self.ON, parent=current)
            self.ERROR(parent=current)
            return current
    signalStatement.min_size = RuleSize(1, 4)

    def stopStatement(self, parent=None):
        with UnparserRuleContext(self, 'stopStatement', parent) as current:
            self.STOP(parent=current)
            return current
    stopStatement.min_size = RuleSize(1, 1)

    def subtractStatement(self, parent=None):
        with UnparserRuleContext(self, 'subtractStatement', parent) as current:
            self._reserve(3, self.SUBTRACT, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 2) as quant0:
                while quant0(current):
                    self.atomic(parent=current)
            self._reserve(1, self.FROM, parent=current)
            self.atomic(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(3, 3), 0) as quant1:
                while quant1(current):
                    self._reserve(2, self.GIVING, parent=current)
                    self.variable(parent=current)
            return current
    subtractStatement.min_size = RuleSize(3, 4)

    def gotoStatement(self, parent=None):
        with UnparserRuleContext(self, 'gotoStatement', parent) as current:
            self._reserve(2, self.GOTO, parent=current)
            self.procedureName(parent=current)
            return current
    gotoStatement.min_size = RuleSize(3, 3)

    def whenBlock(self, parent=None):
        with UnparserRuleContext(self, 'whenBlock', parent) as current:
            with AlternationContext(self, 0, (RuleSize(5, 3), RuleSize(4, 3)), 0, (1, 1)) as alt0:
                [self.whenBlock_whenAnyBlock, self.whenBlock_whenOtherBlock][alt0(current)](parent=current)
            return current
    whenBlock.min_size = RuleSize(4, 3)

    def displayExpression(self, parent=None):
        with UnparserRuleContext(self, 'displayExpression', parent) as current:
            self.atomic(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 3), 0) as quant0:
                while quant0(current):
                    self._reserve(2, self.DELIMITED, parent=current)
                    self._reserve(1, self.BY, parent=current)
                    with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1)) as alt0:
                        [self.SPACE, self.SIZE][alt0(current)](parent=current)
            return current
    displayExpression.min_size = RuleSize(3, 1)

    def moveExpression(self, parent=None):
        with UnparserRuleContext(self, 'moveExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 1), RuleSize(1, 1), RuleSize(1, 1), RuleSize(1, 1)), 0, (1, 1, 1, 1)) as alt0:
                [self.atomic, self.SPACES, self.HIGHVALUES, self.LOWVALUES][alt0(current)](parent=current)
            return current
    moveExpression.min_size = RuleSize(1, 1)

    def anyExpression(self, parent=None):
        with UnparserRuleContext(self, 'anyExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(3, 1), RuleSize(5, 1), RuleSize(5, 1), RuleSize(3, 1)), 0, (1, 1, 1, 1)) as alt0:
                [self.atomic, self.arithmeticExpression, self.stringExpression, self.booleanExpression][alt0(current)](parent=current)
            return current
    anyExpression.min_size = RuleSize(3, 1)

    def arithmeticExpression(self, parent=None):
        with UnparserRuleContext(self, 'arithmeticExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(4, 1), RuleSize(6, 3)), 0, (1, 1)) as alt0:
                [self.arithmeticExpression_atomicArithmeticExpression, self.arithmeticExpression_arithmeticOpArithmeticExpression][alt0(current)](parent=current)
            return current
    arithmeticExpression.min_size = RuleSize(4, 1)

    def booleanExpression(self, parent=None):
        with UnparserRuleContext(self, 'booleanExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(2, 1), RuleSize(6, 3), RuleSize(4, 2), RuleSize(4, 4), RuleSize(7, 6)), 0, (1, 1, 1, 1, 1, 1)) as alt0:
                [self.booleanExpression_trueBooleanExpression, self.booleanExpression_falseBooleanExpression, self.booleanExpression_comparisonOpBooleanExpression, self.booleanExpression_notBooleanExpression, self.booleanExpression_booleanOpBooleanExpression, self.booleanExpression_contractedBooleanExpression][alt0(current)](parent=current)
            return current
    booleanExpression.min_size = RuleSize(2, 1)

    def contractedExpression(self, parent=None):
        with UnparserRuleContext(self, 'contractedExpression', parent) as current:
            self._reserve(1, self.BooleanOp, parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(1, 1), 1) as quant0:
                while quant0(current):
                    self.ComparisonOp(parent=current)
            self.arithmeticExpression(parent=current)
            return current
    contractedExpression.min_size = RuleSize(5, 3)

    def stringExpression(self, parent=None):
        with UnparserRuleContext(self, 'stringExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(4, 1), RuleSize(6, 3)), 0, (1, 1)) as alt0:
                [self.stringExpression_atomicStringExpression, self.stringExpression_stringConcatExpression][alt0(current)](parent=current)
            return current
    stringExpression.min_size = RuleSize(4, 1)

    def loopExpression(self, parent=None):
        with UnparserRuleContext(self, 'loopExpression', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 1), RuleSize(4, 2), RuleSize(4, 2), RuleSize(4, 1)), 0, (1, 1, 1, 1)) as alt0:
                [self.loopExpression_varyingLoopExpression, self.loopExpression_whileLoopExpression, self.loopExpression_untilLoopExpression, self.loopExpression_statementLoopExpression][alt0(current)](parent=current)
            return current
    loopExpression.min_size = RuleSize(2, 1)

    def procedureName(self, parent=None):
        with UnparserRuleContext(self, 'procedureName', parent) as current:
            self.ID(parent=current)
            return current
    procedureName.min_size = RuleSize(2, 2)

    def atomic(self, parent=None):
        with UnparserRuleContext(self, 'atomic', parent) as current:
            with AlternationContext(self, 0, (RuleSize(4, 2), RuleSize(4, 2), RuleSize(2, 1)), 0, (1, 1, 1)) as alt0:
                [self.atomic_variableAtomic, self.atomic_numberAtomic, self.atomic_stringAtomic][alt0(current)](parent=current)
            return current
    atomic.min_size = RuleSize(2, 1)

    def variable(self, parent=None):
        with UnparserRuleContext(self, 'variable', parent) as current:
            self.ID(parent=current)
            with QuantifierContext(self, 0, 0, inf, RuleSize(2, 3), 0) as quant0:
                while quant0(current):
                    self._reserve(2, self.OF, parent=current)
                    self.ID(parent=current)
            return current
    variable.min_size = RuleSize(2, 2)

    def name(self, parent=None):
        with UnparserRuleContext(self, 'name', parent) as current:
            with QuantifierContext(self, 0, 1, inf, RuleSize(1, 1), 0) as quant0:
                while quant0(current):
                    with AlternationContext(self, 0, (RuleSize(1, 1), RuleSize(2, 2), RuleSize(2, 2), RuleSize(2, 3), RuleSize(1, 1)), 0, (1, 1, 1, 1, 1)) as alt0:
                        [self.NODOT, self.ID, self.INTEGER, self.FLOAT, self.ArithmeticOp][alt0(current)](parent=current)
            return current
    name.min_size = RuleSize(1, 1)

    def representation(self, parent=None):
        with UnparserRuleContext(self, 'representation', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 2), RuleSize(2, 2)), 0, (1, 1)) as alt0:
                [self.ID, self.INTEGER][alt0(current)](parent=current)
            return current
    representation.min_size = RuleSize(2, 2)

    def number(self, parent=None):
        with UnparserRuleContext(self, 'number', parent) as current:
            with AlternationContext(self, 0, (RuleSize(2, 2), RuleSize(2, 3)), 0, (1, 1)) as alt0:
                [self.INTEGER, self.FLOAT][alt0(current)](parent=current)
            return current
    number.min_size = RuleSize(2, 2)

    def whenBlock_whenAnyBlock(self, parent=None):
        with UnparserRuleContext(self, 'whenBlock_whenAnyBlock', parent) as current:
            self._reserve(2, self.WHEN, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(4, 1), 1) as quant0:
                while quant0(current):
                    self.anyExpression(parent=current)
            with QuantifierContext(self, 1, 1, inf, RuleSize(3, 1), 0) as quant1:
                while quant1(current):
                    self.statement(parent=current)
            return current
    whenBlock_whenAnyBlock.min_size = RuleSize(4, 3)

    def whenBlock_whenOtherBlock(self, parent=None):
        with UnparserRuleContext(self, 'whenBlock_whenOtherBlock', parent) as current:
            self._reserve(2, self.WHEN, parent=current)
            self._reserve(1, self.OTHER, parent=current)
            with QuantifierContext(self, 0, 1, inf, RuleSize(3, 1), 0) as quant0:
                while quant0(current):
                    self.statement(parent=current)
            return current
    whenBlock_whenOtherBlock.min_size = RuleSize(3, 3)

    def arithmeticExpression_atomicArithmeticExpression(self, parent=None):
        with UnparserRuleContext(self, 'arithmeticExpression_atomicArithmeticExpression', parent) as current:
            self.atomic(parent=current)
            return current
    arithmeticExpression_atomicArithmeticExpression.min_size = RuleSize(3, 1)

    def arithmeticExpression_arithmeticOpArithmeticExpression(self, parent=None):
        local_ctx = dict(left=None, right=None)
        with UnparserRuleContext(self, 'arithmeticExpression_arithmeticOpArithmeticExpression', parent) as current:
            self._reserve(2, self.arithmeticExpression, parent=current)
            local_ctx['left'] = current.last_child
            self._reserve(1, self.ArithmeticOp, parent=current)
            self.arithmeticExpression(parent=current)
            local_ctx['right'] = current.last_child
            return current
    arithmeticExpression_arithmeticOpArithmeticExpression.min_size = RuleSize(5, 3)

    def booleanExpression_trueBooleanExpression(self, parent=None):
        with UnparserRuleContext(self, 'booleanExpression_trueBooleanExpression', parent) as current:
            self.TRUE(parent=current)
            return current
    booleanExpression_trueBooleanExpression.min_size = RuleSize(1, 1)

    def booleanExpression_falseBooleanExpression(self, parent=None):
        with UnparserRuleContext(self, 'booleanExpression_falseBooleanExpression', parent) as current:
            self.FALSE(parent=current)
            return current
    booleanExpression_falseBooleanExpression.min_size = RuleSize(1, 1)

    def booleanExpression_comparisonOpBooleanExpression(self, parent=None):
        local_ctx = dict(left=None, right=None)
        with UnparserRuleContext(self, 'booleanExpression_comparisonOpBooleanExpression', parent) as current:
            self._reserve(2, self.arithmeticExpression, parent=current)
            local_ctx['left'] = current.last_child
            self._reserve(1, self.ComparisonOp, parent=current)
            self.arithmeticExpression(parent=current)
            local_ctx['right'] = current.last_child
            return current
    booleanExpression_comparisonOpBooleanExpression.min_size = RuleSize(5, 3)

    def booleanExpression_notBooleanExpression(self, parent=None):
        with UnparserRuleContext(self, 'booleanExpression_notBooleanExpression', parent) as current:
            self._reserve(1, self.NOT, parent=current)
            self.booleanExpression(parent=current)
            return current
    booleanExpression_notBooleanExpression.min_size = RuleSize(3, 2)

    def booleanExpression_booleanOpBooleanExpression(self, parent=None):
        local_ctx = dict(left=None, right=None)
        with UnparserRuleContext(self, 'booleanExpression_booleanOpBooleanExpression', parent) as current:
            self._reserve(3, self.booleanExpression, parent=current)
            local_ctx['left'] = current.last_child
            self._reserve(1, self.BooleanOp, parent=current)
            self.booleanExpression(parent=current)
            local_ctx['right'] = current.last_child
            return current
    booleanExpression_booleanOpBooleanExpression.min_size = RuleSize(3, 4)

    def booleanExpression_contractedBooleanExpression(self, parent=None):
        local_ctx = dict(left=None, right=None)
        with UnparserRuleContext(self, 'booleanExpression_contractedBooleanExpression', parent) as current:
            self._reserve(5, self.arithmeticExpression, parent=current)
            local_ctx['left'] = current.last_child
            self._reserve(4, self.ComparisonOp, parent=current)
            self._reserve(3, self.arithmeticExpression, parent=current)
            local_ctx['right'] = current.last_child
            with QuantifierContext(self, 0, 1, inf, RuleSize(6, 3), 0) as quant0:
                while quant0(current):
                    self.contractedExpression(parent=current)
            return current
    booleanExpression_contractedBooleanExpression.min_size = RuleSize(6, 6)

    def stringExpression_atomicStringExpression(self, parent=None):
        with UnparserRuleContext(self, 'stringExpression_atomicStringExpression', parent) as current:
            self.atomic(parent=current)
            return current
    stringExpression_atomicStringExpression.min_size = RuleSize(3, 1)

    def stringExpression_stringConcatExpression(self, parent=None):
        local_ctx = dict(left=None, right=None)
        with UnparserRuleContext(self, 'stringExpression_stringConcatExpression', parent) as current:
            self._reserve(2, self.stringExpression, parent=current)
            local_ctx['left'] = current.last_child
            self._reserve(1, self.StringConcatOp, parent=current)
            self.stringExpression(parent=current)
            local_ctx['right'] = current.last_child
            return current
    stringExpression_stringConcatExpression.min_size = RuleSize(5, 3)

    def loopExpression_varyingLoopExpression(self, parent=None):
        local_ctx = dict(fr=None, to=None, by=None)
        with UnparserRuleContext(self, 'loopExpression_varyingLoopExpression', parent) as current:
            self.VARYING(parent=current)
            with QuantifierContext(self, 0, 0, 1, RuleSize(3, 2), 0) as quant0:
                while quant0(current):
                    self.variable(parent=current)
            with QuantifierContext(self, 1, 0, 1, RuleSize(3, 2), 0) as quant1:
                while quant1(current):
                    self._reserve(1, self.FROM, parent=current)
                    self.atomic(parent=current)
                    local_ctx['fr'] = current.last_child
            with QuantifierContext(self, 2, 0, 1, RuleSize(3, 2), 0) as quant2:
                while quant2(current):
                    self._reserve(1, self.TO, parent=current)
                    self.atomic(parent=current)
                    local_ctx['to'] = current.last_child
            with QuantifierContext(self, 3, 0, 1, RuleSize(3, 2), 0) as quant3:
                while quant3(current):
                    self._reserve(1, self.BY, parent=current)
                    self.atomic(parent=current)
                    local_ctx['by'] = current.last_child
            return current
    loopExpression_varyingLoopExpression.min_size = RuleSize(1, 1)

    def loopExpression_whileLoopExpression(self, parent=None):
        with UnparserRuleContext(self, 'loopExpression_whileLoopExpression', parent) as current:
            self._reserve(1, self.WHILE, parent=current)
            self.booleanExpression(parent=current)
            return current
    loopExpression_whileLoopExpression.min_size = RuleSize(3, 2)

    def loopExpression_untilLoopExpression(self, parent=None):
        with UnparserRuleContext(self, 'loopExpression_untilLoopExpression', parent) as current:
            self._reserve(1, self.UNTIL, parent=current)
            self.booleanExpression(parent=current)
            return current
    loopExpression_untilLoopExpression.min_size = RuleSize(3, 2)

    def loopExpression_statementLoopExpression(self, parent=None):
        with UnparserRuleContext(self, 'loopExpression_statementLoopExpression', parent) as current:
            self.statement(parent=current)
            return current
    loopExpression_statementLoopExpression.min_size = RuleSize(3, 1)

    def atomic_variableAtomic(self, parent=None):
        with UnparserRuleContext(self, 'atomic_variableAtomic', parent) as current:
            self.variable(parent=current)
            return current
    atomic_variableAtomic.min_size = RuleSize(3, 2)

    def atomic_numberAtomic(self, parent=None):
        with UnparserRuleContext(self, 'atomic_numberAtomic', parent) as current:
            self.number(parent=current)
            return current
    atomic_numberAtomic.min_size = RuleSize(3, 2)

    def atomic_stringAtomic(self, parent=None):
        with UnparserRuleContext(self, 'atomic_stringAtomic', parent) as current:
            self.STRINGLITERAL(parent=current)
            return current
    atomic_stringAtomic.min_size = RuleSize(1, 1)

    _default_rule = program

    _charsets = {
        0: list(itertools.chain.from_iterable([range(0x20, 0x7f)])),
        1: list(itertools.chain.from_iterable([range(0x20, 0x22), range(0x23, 0x7f)])),
        2: list(itertools.chain.from_iterable([range(0x30, 0x3a)])),
        3: list(itertools.chain.from_iterable([range(0x61, 0x7b)])),
        4: list(itertools.chain.from_iterable([range(0x41, 0x5b)])),
        5: list(itertools.chain.from_iterable([range(0x9, 0xa), range(0xa, 0xb), range(0xd, 0xe), range(0x20, 0x21)])),
        6: list(itertools.chain.from_iterable([range(0x20, 0x2e), range(0x2f, 0x7f)])),
    }
